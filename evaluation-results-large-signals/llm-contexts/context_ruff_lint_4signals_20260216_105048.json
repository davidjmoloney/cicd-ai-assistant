{
  "_debug_metadata": {
    "timestamp": "20260216_105048",
    "tool_id": "ruff",
    "signal_type": "lint",
    "num_signals": 4,
    "signal_files": [
      "authentication/clerk.py",
      "ria/services/company_service.py"
    ],
    "system_prompt_length": 8600,
    "user_prompt_length": 13959
  },
  "context": {
    "group": {
      "tool_id": "ruff",
      "signal_type": "lint",
      "group_size": 4
    },
    "signals": [
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "low",
          "rule_code": "UP006",
          "message": "Use `dict` instead of `Dict` for type annotation",
          "docs_url": "https://docs.astral.sh/ruff/rules/non-pep585-annotation",
          "file_path": "ria/services/company_service.py",
          "span": {
            "start": {
              "row": 33,
              "column": 41
            },
            "end": {
              "row": 33,
              "column": 45
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/services/company_service.py",
            "start_row": 3,
            "end_row": 63,
            "text": "\nThis service handles company detail operations including:\n- Getting company by CRD\n- Loading PDF records\n- Loading trend data\n\"\"\"\n\nimport json\nfrom typing import Dict, Any, List, Optional\n\nimport boto3\nimport pandas as pd\nimport polars as pl\nfrom botocore.exceptions import ClientError\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.services.pdf_cache_service import get_pdf_cache\nfrom ria.utils.constants import (\n    CRD_COLUMN, NAME_COLUMN, CITY_COLUMN, STATE_COLUMN, COUNTRY_COLUMN\n)\nfrom common.utils.config import get_s3_bucket, get_s3_prefix\nfrom common.utils.logging_config import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass CompanyService:\n    \"\"\"Service for company detail operations.\"\"\"\n    \n    @staticmethod\n    def get_company_by_crd(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Get company details from index by CRD number.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            Company record as dictionary\n        \"\"\"\n        index_cache = get_index_cache()\n        df = index_cache.load()\n        \n        # Filter by CRD - cast to int for comparison\n        company_df = df.filter(pl.col(CRD_COLUMN).cast(pl.Int64, strict=False) == crd)\n        \n        if company_df.is_empty():\n            raise ValueError(f\"CRD {crd} not found in RIA database\")\n        \n        company_data = company_df.to_dicts()[0]\n        return company_data\n    \n    @staticmethod\n    def get_company_pdfs(crd: int) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get PDF records for a specific CRD.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n"
          },
          "imports": {
            "file_path": "ria/services/company_service.py",
            "start_row": 1,
            "end_row": 20,
            "text": "\"\"\"\nCompany Service\n\nThis service handles company detail operations including:\n- Getting company by CRD\n- Loading PDF records\n- Loading trend data\n\"\"\"\n\nimport json\nfrom typing import Dict, Any, List, Optional\n\nimport boto3\nimport pandas as pd\nimport polars as pl\nfrom botocore.exceptions import ClientError\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.services.pdf_cache_service import get_pdf_cache\nfrom ria.utils.constants import (\n"
          },
          "enclosing_function": {
            "file_path": "ria/services/company_service.py",
            "start_row": 31,
            "end_row": 54,
            "text": "    \n    @staticmethod\n    def get_company_by_crd(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Get company details from index by CRD number.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            Company record as dictionary\n        \"\"\"\n        index_cache = get_index_cache()\n        df = index_cache.load()\n        \n        # Filter by CRD - cast to int for comparison\n        company_df = df.filter(pl.col(CRD_COLUMN).cast(pl.Int64, strict=False) == crd)\n        \n        if company_df.is_empty():\n            raise ValueError(f\"CRD {crd} not found in RIA database\")\n        \n        company_data = company_df.to_dicts()[0]\n        return company_data\n    \n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/services/company_service.py",
          "start_row": 31,
          "end_row": 35,
          "text": "    \n@staticmethod\ndef get_company_by_crd(crd: int) -> Dict[str, Any]:\n    \"\"\"\n    Get company details from index by CRD number.\n",
          "original_text": "    \n    @staticmethod\n    def get_company_by_crd(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Get company details from index by CRD number.\n",
          "error_line": 33,
          "error_line_in_snippet": 3,
          "snippet_length": 5,
          "base_indent": "    "
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": true,
          "applicability": "safe",
          "tool_message": "Replace with `dict`",
          "edits": [
            {
              "span": {
                "start": {
                  "row": 33,
                  "column": 41
                },
                "end": {
                  "row": 33,
                  "column": 45
                }
              },
              "content": "dict"
            }
          ]
        }
      },
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "low",
          "rule_code": "UP006",
          "message": "Use `list` instead of `List` for type annotation",
          "docs_url": "https://docs.astral.sh/ruff/rules/non-pep585-annotation",
          "file_path": "ria/services/company_service.py",
          "span": {
            "start": {
              "row": 56,
              "column": 39
            },
            "end": {
              "row": 56,
              "column": 43
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/services/company_service.py",
            "start_row": 26,
            "end_row": 86,
            "text": "logger = get_logger(__name__)\n\n\nclass CompanyService:\n    \"\"\"Service for company detail operations.\"\"\"\n    \n    @staticmethod\n    def get_company_by_crd(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Get company details from index by CRD number.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            Company record as dictionary\n        \"\"\"\n        index_cache = get_index_cache()\n        df = index_cache.load()\n        \n        # Filter by CRD - cast to int for comparison\n        company_df = df.filter(pl.col(CRD_COLUMN).cast(pl.Int64, strict=False) == crd)\n        \n        if company_df.is_empty():\n            raise ValueError(f\"CRD {crd} not found in RIA database\")\n        \n        company_data = company_df.to_dicts()[0]\n        return company_data\n    \n    @staticmethod\n    def get_company_pdfs(crd: int) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get PDF records for a specific CRD.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            List of PDF records\n        \"\"\"\n        return pdf_records_for_crd(crd)\n    \n    @staticmethod\n    def load_trends_json(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Load trend data for a specific CRD from S3.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            Trend data as dictionary\n        \"\"\"\n        return _load_trends_json(crd)\n\n\ndef _load_trends_json(crd: int) -> Dict[str, Any]:\n    \"\"\"Load trend data for a specific CRD from S3.\"\"\"\n    s3_client = boto3.client('s3')\n    bucket = get_s3_bucket()\n    \n"
          },
          "imports": {
            "file_path": "ria/services/company_service.py",
            "start_row": 1,
            "end_row": 20,
            "text": "\"\"\"\nCompany Service\n\nThis service handles company detail operations including:\n- Getting company by CRD\n- Loading PDF records\n- Loading trend data\n\"\"\"\n\nimport json\nfrom typing import Dict, Any, List, Optional\n\nimport boto3\nimport pandas as pd\nimport polars as pl\nfrom botocore.exceptions import ClientError\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.services.pdf_cache_service import get_pdf_cache\nfrom ria.utils.constants import (\n"
          },
          "enclosing_function": {
            "file_path": "ria/services/company_service.py",
            "start_row": 54,
            "end_row": 67,
            "text": "    \n    @staticmethod\n    def get_company_pdfs(crd: int) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get PDF records for a specific CRD.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            List of PDF records\n        \"\"\"\n        return pdf_records_for_crd(crd)\n    \n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/services/company_service.py",
          "start_row": 54,
          "end_row": 58,
          "text": "    \n@staticmethod\ndef get_company_pdfs(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"\n    Get PDF records for a specific CRD.\n",
          "original_text": "    \n    @staticmethod\n    def get_company_pdfs(crd: int) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get PDF records for a specific CRD.\n",
          "error_line": 56,
          "error_line_in_snippet": 3,
          "snippet_length": 5,
          "base_indent": "    "
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": true,
          "applicability": "safe",
          "tool_message": "Replace with `list`",
          "edits": [
            {
              "span": {
                "start": {
                  "row": 56,
                  "column": 39
                },
                "end": {
                  "row": 56,
                  "column": 43
                }
              },
              "content": "list"
            }
          ]
        }
      },
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "low",
          "rule_code": "UP006",
          "message": "Use `dict` instead of `Dict` for type annotation",
          "docs_url": "https://docs.astral.sh/ruff/rules/non-pep585-annotation",
          "file_path": "ria/services/company_service.py",
          "span": {
            "start": {
              "row": 104,
              "column": 43
            },
            "end": {
              "row": 104,
              "column": 47
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/services/company_service.py",
            "start_row": 74,
            "end_row": 129,
            "text": "            crd: Company CRD number\n            \n        Returns:\n            Trend data as dictionary\n        \"\"\"\n        return _load_trends_json(crd)\n\n\ndef _load_trends_json(crd: int) -> Dict[str, Any]:\n    \"\"\"Load trend data for a specific CRD from S3.\"\"\"\n    s3_client = boto3.client('s3')\n    bucket = get_s3_bucket()\n    \n    # S3 path structure: output/sec_ingestion/processed/trends/latest/crd={crd}/trends.v1.json\n    s3_path = f\"{get_s3_prefix()}/processed/trends/latest/crd={crd}/trends.v1.json\"\n    \n    try:\n        # Download trend data from S3\n        response = s3_client.get_object(Bucket=bucket, Key=s3_path)\n        content = response['Body'].read().decode('utf-8')\n        return json.loads(content)\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'NoSuchKey':\n            raise ValueError(f\"Trend data not found for CRD {crd}\")\n        else:\n            raise RuntimeError(f\"Failed to load trend data: {str(e)}\")\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid trend data format: {str(e)}\")\n\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"Get PDF records for a specific CRD.\"\"\"\n    logger.info(f\"Looking up PDF records for CRD: {crd}\")\n    \n    pdf_cache = get_pdf_cache()\n    pdf_df = pdf_cache.load().copy()\n    logger.info(f\"Loaded PDF data: {len(pdf_df)} rows, columns: {list(pdf_df.columns)}\")\n    \n    if \"crd\" not in pdf_df.columns:\n        logger.error(\"\u274c RIA latest.csv missing 'crd' column\")\n        raise RuntimeError(\"RIA latest.csv missing 'crd' column\")\n    \n    pdf_df[\"crd_numeric\"] = pd.to_numeric(pdf_df[\"crd\"], errors=\"coerce\")\n    subset = pdf_df[pdf_df[\"crd_numeric\"] == crd]\n    logger.info(f\"Found {len(subset)} PDF records for CRD {crd}\")\n    \n    if subset.empty:\n        logger.warning(f\"No PDF records found for CRD {crd}\")\n        return []\n    \n    subset = subset.drop(columns=[\"crd_numeric\"], errors=\"ignore\")\n    subset = subset.where(pd.notnull(subset), None)\n    records = subset.to_dict(orient=\"records\")\n    logger.info(f\"Returning {len(records)} PDF records for CRD {crd}\")\n    return records\n\n"
          },
          "imports": {
            "file_path": "ria/services/company_service.py",
            "start_row": 1,
            "end_row": 20,
            "text": "\"\"\"\nCompany Service\n\nThis service handles company detail operations including:\n- Getting company by CRD\n- Loading PDF records\n- Loading trend data\n\"\"\"\n\nimport json\nfrom typing import Dict, Any, List, Optional\n\nimport boto3\nimport pandas as pd\nimport polars as pl\nfrom botocore.exceptions import ClientError\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.services.pdf_cache_service import get_pdf_cache\nfrom ria.utils.constants import (\n"
          },
          "enclosing_function": {
            "file_path": "ria/services/company_service.py",
            "start_row": 102,
            "end_row": 129,
            "text": "\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"Get PDF records for a specific CRD.\"\"\"\n    logger.info(f\"Looking up PDF records for CRD: {crd}\")\n    \n    pdf_cache = get_pdf_cache()\n    pdf_df = pdf_cache.load().copy()\n    logger.info(f\"Loaded PDF data: {len(pdf_df)} rows, columns: {list(pdf_df.columns)}\")\n    \n    if \"crd\" not in pdf_df.columns:\n        logger.error(\"\u274c RIA latest.csv missing 'crd' column\")\n        raise RuntimeError(\"RIA latest.csv missing 'crd' column\")\n    \n    pdf_df[\"crd_numeric\"] = pd.to_numeric(pdf_df[\"crd\"], errors=\"coerce\")\n    subset = pdf_df[pdf_df[\"crd_numeric\"] == crd]\n    logger.info(f\"Found {len(subset)} PDF records for CRD {crd}\")\n    \n    if subset.empty:\n        logger.warning(f\"No PDF records found for CRD {crd}\")\n        return []\n    \n    subset = subset.drop(columns=[\"crd_numeric\"], errors=\"ignore\")\n    subset = subset.where(pd.notnull(subset), None)\n    records = subset.to_dict(orient=\"records\")\n    logger.info(f\"Returning {len(records)} PDF records for CRD {crd}\")\n    return records\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/services/company_service.py",
          "start_row": 102,
          "end_row": 106,
          "text": "\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"Get PDF records for a specific CRD.\"\"\"\n    logger.info(f\"Looking up PDF records for CRD: {crd}\")\n",
          "original_text": "\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"Get PDF records for a specific CRD.\"\"\"\n    logger.info(f\"Looking up PDF records for CRD: {crd}\")\n",
          "error_line": 104,
          "error_line_in_snippet": 3,
          "snippet_length": 5,
          "base_indent": ""
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": true,
          "applicability": "safe",
          "tool_message": "Replace with `dict`",
          "edits": [
            {
              "span": {
                "start": {
                  "row": 104,
                  "column": 43
                },
                "end": {
                  "row": 104,
                  "column": 47
                }
              },
              "content": "dict"
            }
          ]
        }
      },
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "low",
          "rule_code": "UP037",
          "message": "Remove quotes from type annotation",
          "docs_url": "https://docs.astral.sh/ruff/rules/quoted-annotation",
          "file_path": "authentication/clerk.py",
          "span": {
            "start": {
              "row": 45,
              "column": 29
            },
            "end": {
              "row": 45,
              "column": 44
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "authentication/clerk.py",
            "start_row": 15,
            "end_row": 75,
            "text": "from jwcrypto import jwk as jwcrypto_jwk\n\nfrom common.utils.config import (\n    get_clerk_audience,\n    get_clerk_issuer,\n    get_clerk_jwks_url,\n    get_lp_clerk_audience,\n    get_lp_clerk_issuer,\n    get_lp_clerk_jwks_url,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass ClerkTokenError(RuntimeError):\n    \"\"\"Raised when a Clerk token fails validation.\"\"\"\n\n\nclass ClerkConfigurationError(ClerkTokenError):\n    \"\"\"Raised when mandatory Clerk configuration values are missing.\"\"\"\n\n\n@dataclass(frozen=True)\nclass ClerkSettings:\n    jwks_url: str\n    issuer: str\n    audience: Optional[str] = None\n    cache_ttl_seconds: int = 300\n\n    @classmethod\n    def from_config(cls) -> \"ClerkSettings\":\n        jwks_url = get_clerk_jwks_url()\n        issuer = get_clerk_issuer()\n        audience = get_clerk_audience()\n\n        missing = [name for name, value in (\n            (\"CLERK_JWKS_URL\", jwks_url),\n            (\"CLERK_ISSUER\", issuer),\n        ) if not value]\n        if missing:\n            raise ClerkConfigurationError(\n                f\"Missing Clerk configuration value(s): {', '.join(missing)}\"\n            )\n\n        return cls(jwks_url=jwks_url, issuer=issuer, audience=audience)\n\n\ndef get_clerk_settings() -> ClerkSettings:\n    \"\"\"Load Clerk token validation settings from config helpers.\"\"\"\n    return ClerkSettings.from_config()\n\n\ndef get_lp_clerk_settings() -> ClerkSettings:\n    jwks_url = get_lp_clerk_jwks_url()\n    issuer = get_lp_clerk_issuer()\n    audience = get_lp_clerk_audience()\n\n    missing = [name for name, value in (\n        (\"LP_CLERK_JWKS_URL\", jwks_url),\n        (\"LP_CLERK_ISSUER\", issuer),\n    ) if not value]\n"
          },
          "imports": null,
          "enclosing_function": {
            "file_path": "authentication/clerk.py",
            "start_row": 43,
            "end_row": 61,
            "text": "\n    @classmethod\n    def from_config(cls) -> \"ClerkSettings\":\n        jwks_url = get_clerk_jwks_url()\n        issuer = get_clerk_issuer()\n        audience = get_clerk_audience()\n\n        missing = [name for name, value in (\n            (\"CLERK_JWKS_URL\", jwks_url),\n            (\"CLERK_ISSUER\", issuer),\n        ) if not value]\n        if missing:\n            raise ClerkConfigurationError(\n                f\"Missing Clerk configuration value(s): {', '.join(missing)}\"\n            )\n\n        return cls(jwks_url=jwks_url, issuer=issuer, audience=audience)\n\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "authentication/clerk.py",
          "start_row": 43,
          "end_row": 47,
          "text": "\n@classmethod\ndef from_config(cls) -> \"ClerkSettings\":\n    jwks_url = get_clerk_jwks_url()\n    issuer = get_clerk_issuer()\n",
          "original_text": "\n    @classmethod\n    def from_config(cls) -> \"ClerkSettings\":\n        jwks_url = get_clerk_jwks_url()\n        issuer = get_clerk_issuer()\n",
          "error_line": 45,
          "error_line_in_snippet": 3,
          "snippet_length": 5,
          "base_indent": "    "
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": true,
          "applicability": "safe",
          "tool_message": "Remove quotes",
          "edits": [
            {
              "span": {
                "start": {
                  "row": 45,
                  "column": 29
                },
                "end": {
                  "row": 45,
                  "column": 44
                }
              },
              "content": "ClerkSettings"
            }
          ]
        }
      }
    ],
    "merged_snippet_groups": [],
    "standalone_signal_indices": [
      0,
      1,
      2,
      3
    ]
  },
  "prompts": {
    "system_prompt": "You are an expert code repair agent. Your task is to make MINIMAL, SURGICAL fixes to code errors.\n\n## CRITICAL PRINCIPLE: MINIMAL CHANGES ONLY\n\nYour job is to fix ONLY the specific error mentioned. You are NOT improving, refactoring, or cleaning up code.\n\n**THE GOLDEN RULE**: Every line in your output that is NOT directly part of the fix MUST be IDENTICAL to the input - same content, same whitespace, same everything.\n\n## How This Works\n\nFor each error signal, you will receive:\n\n1. **Error Information**: Type, message, severity, and rule code\n2. **Edit Snippet**: A small code snippet (~13 lines) containing the error\n   - This is what you need to FIX and RETURN\n   - The error location within the snippet is indicated (e.g., \"Error on line 4 of 13\")\n3. **Context Window**: A larger code window (~30 lines) around the error for understanding\n   - Use this to understand the surrounding code, but DON'T return it\n\n4. **Tailored Context** (varies by signal type - optimized to reduce token usage):\n   - **Imports**: The file's import block (for type definitions, dependencies)\n     - Included for: type errors, undefined names, most issues\n     - Excluded for: import-only errors, bare except blocks\n   - **Enclosing Function**: The function containing the error (for understanding scope/logic)\n     - Included for: type errors, docstring errors, function-level issues\n     - Excluded for: import errors (global scope), bare except (sent separately)\n   - **Try/Except Block**: The try/except block containing the error\n     - Included for: bare except errors (E722)\n     - Excluded for: most other errors\n\nNote: Context is carefully selected to provide what you need while minimizing token usage.\nNot all context is present for every error - you'll only receive relevant context.\n\n## Response Format\n\nFor EACH signal/snippet you receive, respond with this EXACT format:\n\n```\n===== FIX FOR: <file_path> =====\nCONFIDENCE: <0.0-1.0>\nREASONING: <brief explanation of the fix>\n\n```FIXED_CODE\n<complete fixed snippet - ALL lines from edit_snippet, with ONLY the fix applied>\n```\n\nWARNINGS: <any caveats, or \"None\">\n===== END FIX =====\n```\n\n## CRITICAL Rules - READ CAREFULLY\n\n1. **MINIMAL CHANGES ONLY** - Change ONLY what is necessary to fix the specific error. Nothing more.\n\n2. **PRESERVE EVERYTHING ELSE EXACTLY** - Every line that is NOT part of the fix must be returned EXACTLY as it appeared in the input, character-for-character, including:\n   - Comments and documentation\n   - Blank lines (including leading and trailing blank lines)\n   - All whitespace (including trailing newlines at the end of the snippet)\n   - Other variable declarations\n   - Function definitions\n   - String content (including multi-line strings)\n\n   **CRITICAL**: If the input snippet ends with blank lines or newlines, your output MUST end with the exact same number of blank lines/newlines. Do NOT trim trailing whitespace.\n\n3. **DO NOT under any circumstances**:\n   - Delete lines that aren't related to the fix\n   - Add code that isn't required for the fix\n   - \"Clean up\" or \"improve\" surrounding code\n   - Modify comments or documentation\n   - Change formatting on unrelated lines\n   - Remove blank lines\n   - Add blank lines (unless the fix specifically requires it)\n   - Modify string literals or docstrings\n   - Delete function definitions\n   - Remove dictionary entries or list items unrelated to the fix\n\n4. **Maintain RELATIVE indentation** - The snippet has had its base indentation removed. Preserve relative indentation exactly. If a line has 4 spaces in the input, it must have 4 spaces in your output.\n\n5. **One fix block per signal** - If multiple signals, provide multiple fix blocks\n\n6. **Use context for understanding only** - The context window, imports, and enclosing function help you understand the code, but you only return the fixed edit_snippet\n\n## Example - Correct Minimal Fix\n\nInput:\n- Error: \"Need type annotation for 'cache'\" on line 173\n- Edit Snippet (error on line 4 of 7, lines 170-176):\n```\n}\n\nDEPRIORITIZE_QUERIES = {}\ncache = {}\n\n# Model configuration\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n(Note: The snippet ends with a newline after the last line - this MUST be preserved)\n\nCORRECT Response (only `cache = {}` changed to `cache: dict = {}`):\n```\n===== FIX FOR: app/config/tier_queries.py =====\nCONFIDENCE: 0.95\nREASONING: Added dict type annotation to cache variable to satisfy mypy\n\n```FIXED_CODE\n}\n\nDEPRIORITIZE_QUERIES = {}\ncache: dict = {}\n\n# Model configuration\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n\nWARNINGS: None\n===== END FIX =====\n```\n(Note: The output preserves the exact same trailing newline as the input)\n\n## Example - Preserving Trailing Whitespace\n\nInput snippet ending with blank lines (note the TWO newlines after the return statement):\n```\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n\n\n```\n\nCORRECT - Preserves both trailing newlines:\n```FIXED_CODE\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n\n\n```\n(Output MUST have the same TWO trailing newlines)\n\nWRONG - Trimming trailing newlines:\n```FIXED_CODE\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n```\n^ This is WRONG because it removed trailing newlines. The snippet MUST end with the same whitespace as the input.\n\n## Example - WRONG (Deleting Unrelated Content)\n\nIf the input snippet contains documentation or other code, you MUST preserve it:\n\nWRONG - Deleting unrelated lines:\n```FIXED_CODE\ncache: dict = {}\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n^ This is WRONG because it deleted the closing brace, blank lines, DEPRIORITIZE_QUERIES, and the comment.\n\n## Confidence Guidelines\n- High (>0.8): Simple fixes like type annotations, obvious corrections\n- Medium (0.5-0.8): Logic changes, type guards, refactoring\n- Low (<0.5): Complex changes, unclear intent - add detailed warnings\n\n\n\n## Ruff Lint Error Fixing - Specialized Guidance\n\nYou are fixing LINTING errors from Ruff. These are code quality, style, and\nbest practice issues - NOT security or type correctness.\n\nRisk Level: LOW to MEDIUM\nThese fixes should improve code quality without changing behavior.\n\nCommon Ruff Rule Categories:\n\nF (Pyflakes):\n- Unused imports/variables\n- Undefined names\n- Duplicate arguments\n- Invalid format strings\n\nE/W (pycodestyle):\n- Line length (E501)\n- Whitespace issues (E203, W291)\n- Indentation (E111, E114)\n- Blank lines (E302, E303)\n\nC (McCabe):\n- Complexity warnings (C901)\n- Too many branches/statements\n\nN (pep8-naming):\n- Naming conventions (N801-N818)\n- Lowercase function names\n- CamelCase class names\n\nI (isort):\n- Import sorting/organization\n\nUP (pyupgrade):\n- Outdated syntax\n- Type hint modernization\n\nFixing Strategies:\n\n1. **Remove Unused Code** - But verify it's truly unused\n   \u2705 Remove unused imports\n   \u2705 Remove unused variables\n   \u26a0\ufe0f Check for side effects first!\n\n2. **Simplify Logic** - Follow Python idioms\n   \u2705 `if x == True:` \u2192 `if x:`\n   \u2705 `if len(list) > 0:` \u2192 `if list:`\n   \u2705 Use comprehensions instead of loops\n\n3. **Fix Naming** - Follow PEP 8\n   \u2705 `MyFunction` \u2192 `my_function`\n   \u2705 `my_class` \u2192 `MyClass`\n\n4. **Modernize Syntax** - Use newer Python features\n   \u2705 `Union[str, int]` \u2192 `str | int` (Python 3.10+)\n   \u2705 `Optional[str]` \u2192 `str | None` (Python 3.10+)\n\n5. **Organize Imports** - Sort and group properly\n   \u2705 Standard library first\n   \u2705 Third-party second\n   \u2705 Local imports last\n\nNEVER do these:\n\u274c Remove code that has side effects (initializers, registrations)\n\u274c Change behavior to fix style\n\u274c Break working code to satisfy complexity metrics\n\u274c Remove \"unused\" variables that are part of unpacking\n\nSpecial Cases:\n\nComplexity Warnings (C901):\n- Don't just suppress with # noqa\n- Consider refactoring if genuinely complex\n- But set confidence < 0.7 for refactoring suggestions\n\nUnused Variables:\n- `x, y, z = tuple` - y might be \"unused\" but needed for unpacking\n- Consider renaming to `_` if truly unused: `x, _, z = tuple`\n\nLine Length (E501):\n- Can often be fixed by breaking long lines\n- But some URLs or strings are legitimately long\n- Use # noqa: E501 with comment explaining why\n\nConfidence Guidelines:\n- High (>0.8): Remove unused imports, fix obvious naming\n- Medium (0.5-0.8): Simplify logic, organize imports\n- Low (<0.5): Refactoring suggestions, complex changes\n\nRemember: Preserve behavior. These are style improvements, not bug fixes.\n",
    "user_prompt": "Tool: ruff\nSignal Type: lint\nNumber of Signals: 4\n\n============================================================\nSIGNAL 1\n============================================================\n\n## Error Information\n- File: ria/services/company_service.py\n- Message: Use `dict` instead of `Dict` for type annotation\n- Rule Code: UP006\n- Severity: low\n- Location: Line 33, Column 41\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 31-35 (error on line 3 of 5)\n```python\n    \n@staticmethod\ndef get_company_by_crd(crd: int) -> Dict[str, Any]:\n    \"\"\"\n    Get company details from index by CRD number.\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 3-63\n```python\n\nThis service handles company detail operations including:\n- Getting company by CRD\n- Loading PDF records\n- Loading trend data\n\"\"\"\n\nimport json\nfrom typing import Dict, Any, List, Optional\n\nimport boto3\nimport pandas as pd\nimport polars as pl\nfrom botocore.exceptions import ClientError\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.services.pdf_cache_service import get_pdf_cache\nfrom ria.utils.constants import (\n    CRD_COLUMN, NAME_COLUMN, CITY_COLUMN, STATE_COLUMN, COUNTRY_COLUMN\n)\nfrom common.utils.config import get_s3_bucket, get_s3_prefix\nfrom common.utils.logging_config import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass CompanyService:\n    \"\"\"Service for company detail operations.\"\"\"\n    \n    @staticmethod\n    def get_company_by_crd(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Get company details from index by CRD number.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            Company record as dictionary\n        \"\"\"\n        index_cache = get_index_cache()\n        df = index_cache.load()\n        \n        # Filter by CRD - cast to int for comparison\n        company_df = df.filter(pl.col(CRD_COLUMN).cast(pl.Int64, strict=False) == crd)\n        \n        if company_df.is_empty():\n            raise ValueError(f\"CRD {crd} not found in RIA database\")\n        \n        company_data = company_df.to_dicts()[0]\n        return company_data\n    \n    @staticmethod\n    def get_company_pdfs(crd: int) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get PDF records for a specific CRD.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n\n```\n\n## Imports\n```python\n\"\"\"\nCompany Service\n\nThis service handles company detail operations including:\n- Getting company by CRD\n- Loading PDF records\n- Loading trend data\n\"\"\"\n\nimport json\nfrom typing import Dict, Any, List, Optional\n\nimport boto3\nimport pandas as pd\nimport polars as pl\nfrom botocore.exceptions import ClientError\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.services.pdf_cache_service import get_pdf_cache\nfrom ria.utils.constants import (\n\n```\n\n## Enclosing Function\nLines 31-54\n```python\n    \n    @staticmethod\n    def get_company_by_crd(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Get company details from index by CRD number.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            Company record as dictionary\n        \"\"\"\n        index_cache = get_index_cache()\n        df = index_cache.load()\n        \n        # Filter by CRD - cast to int for comparison\n        company_df = df.filter(pl.col(CRD_COLUMN).cast(pl.Int64, strict=False) == crd)\n        \n        if company_df.is_empty():\n            raise ValueError(f\"CRD {crd} not found in RIA database\")\n        \n        company_data = company_df.to_dicts()[0]\n        return company_data\n    \n\n```\n\n\n============================================================\nSIGNAL 2\n============================================================\n\n## Error Information\n- File: ria/services/company_service.py\n- Message: Use `list` instead of `List` for type annotation\n- Rule Code: UP006\n- Severity: low\n- Location: Line 56, Column 39\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 54-58 (error on line 3 of 5)\n```python\n    \n@staticmethod\ndef get_company_pdfs(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"\n    Get PDF records for a specific CRD.\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 26-86\n```python\nlogger = get_logger(__name__)\n\n\nclass CompanyService:\n    \"\"\"Service for company detail operations.\"\"\"\n    \n    @staticmethod\n    def get_company_by_crd(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Get company details from index by CRD number.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            Company record as dictionary\n        \"\"\"\n        index_cache = get_index_cache()\n        df = index_cache.load()\n        \n        # Filter by CRD - cast to int for comparison\n        company_df = df.filter(pl.col(CRD_COLUMN).cast(pl.Int64, strict=False) == crd)\n        \n        if company_df.is_empty():\n            raise ValueError(f\"CRD {crd} not found in RIA database\")\n        \n        company_data = company_df.to_dicts()[0]\n        return company_data\n    \n    @staticmethod\n    def get_company_pdfs(crd: int) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get PDF records for a specific CRD.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            List of PDF records\n        \"\"\"\n        return pdf_records_for_crd(crd)\n    \n    @staticmethod\n    def load_trends_json(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Load trend data for a specific CRD from S3.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            Trend data as dictionary\n        \"\"\"\n        return _load_trends_json(crd)\n\n\ndef _load_trends_json(crd: int) -> Dict[str, Any]:\n    \"\"\"Load trend data for a specific CRD from S3.\"\"\"\n    s3_client = boto3.client('s3')\n    bucket = get_s3_bucket()\n    \n\n```\n\n## Imports\n```python\n\"\"\"\nCompany Service\n\nThis service handles company detail operations including:\n- Getting company by CRD\n- Loading PDF records\n- Loading trend data\n\"\"\"\n\nimport json\nfrom typing import Dict, Any, List, Optional\n\nimport boto3\nimport pandas as pd\nimport polars as pl\nfrom botocore.exceptions import ClientError\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.services.pdf_cache_service import get_pdf_cache\nfrom ria.utils.constants import (\n\n```\n\n## Enclosing Function\nLines 54-67\n```python\n    \n    @staticmethod\n    def get_company_pdfs(crd: int) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get PDF records for a specific CRD.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            List of PDF records\n        \"\"\"\n        return pdf_records_for_crd(crd)\n    \n\n```\n\n\n============================================================\nSIGNAL 3\n============================================================\n\n## Error Information\n- File: ria/services/company_service.py\n- Message: Use `dict` instead of `Dict` for type annotation\n- Rule Code: UP006\n- Severity: low\n- Location: Line 104, Column 43\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 102-106 (error on line 3 of 5)\n```python\n\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"Get PDF records for a specific CRD.\"\"\"\n    logger.info(f\"Looking up PDF records for CRD: {crd}\")\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 74-129\n```python\n            crd: Company CRD number\n            \n        Returns:\n            Trend data as dictionary\n        \"\"\"\n        return _load_trends_json(crd)\n\n\ndef _load_trends_json(crd: int) -> Dict[str, Any]:\n    \"\"\"Load trend data for a specific CRD from S3.\"\"\"\n    s3_client = boto3.client('s3')\n    bucket = get_s3_bucket()\n    \n    # S3 path structure: output/sec_ingestion/processed/trends/latest/crd={crd}/trends.v1.json\n    s3_path = f\"{get_s3_prefix()}/processed/trends/latest/crd={crd}/trends.v1.json\"\n    \n    try:\n        # Download trend data from S3\n        response = s3_client.get_object(Bucket=bucket, Key=s3_path)\n        content = response['Body'].read().decode('utf-8')\n        return json.loads(content)\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'NoSuchKey':\n            raise ValueError(f\"Trend data not found for CRD {crd}\")\n        else:\n            raise RuntimeError(f\"Failed to load trend data: {str(e)}\")\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid trend data format: {str(e)}\")\n\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"Get PDF records for a specific CRD.\"\"\"\n    logger.info(f\"Looking up PDF records for CRD: {crd}\")\n    \n    pdf_cache = get_pdf_cache()\n    pdf_df = pdf_cache.load().copy()\n    logger.info(f\"Loaded PDF data: {len(pdf_df)} rows, columns: {list(pdf_df.columns)}\")\n    \n    if \"crd\" not in pdf_df.columns:\n        logger.error(\"\u274c RIA latest.csv missing 'crd' column\")\n        raise RuntimeError(\"RIA latest.csv missing 'crd' column\")\n    \n    pdf_df[\"crd_numeric\"] = pd.to_numeric(pdf_df[\"crd\"], errors=\"coerce\")\n    subset = pdf_df[pdf_df[\"crd_numeric\"] == crd]\n    logger.info(f\"Found {len(subset)} PDF records for CRD {crd}\")\n    \n    if subset.empty:\n        logger.warning(f\"No PDF records found for CRD {crd}\")\n        return []\n    \n    subset = subset.drop(columns=[\"crd_numeric\"], errors=\"ignore\")\n    subset = subset.where(pd.notnull(subset), None)\n    records = subset.to_dict(orient=\"records\")\n    logger.info(f\"Returning {len(records)} PDF records for CRD {crd}\")\n    return records\n\n\n```\n\n## Imports\n```python\n\"\"\"\nCompany Service\n\nThis service handles company detail operations including:\n- Getting company by CRD\n- Loading PDF records\n- Loading trend data\n\"\"\"\n\nimport json\nfrom typing import Dict, Any, List, Optional\n\nimport boto3\nimport pandas as pd\nimport polars as pl\nfrom botocore.exceptions import ClientError\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.services.pdf_cache_service import get_pdf_cache\nfrom ria.utils.constants import (\n\n```\n\n## Enclosing Function\nLines 102-129\n```python\n\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"Get PDF records for a specific CRD.\"\"\"\n    logger.info(f\"Looking up PDF records for CRD: {crd}\")\n    \n    pdf_cache = get_pdf_cache()\n    pdf_df = pdf_cache.load().copy()\n    logger.info(f\"Loaded PDF data: {len(pdf_df)} rows, columns: {list(pdf_df.columns)}\")\n    \n    if \"crd\" not in pdf_df.columns:\n        logger.error(\"\u274c RIA latest.csv missing 'crd' column\")\n        raise RuntimeError(\"RIA latest.csv missing 'crd' column\")\n    \n    pdf_df[\"crd_numeric\"] = pd.to_numeric(pdf_df[\"crd\"], errors=\"coerce\")\n    subset = pdf_df[pdf_df[\"crd_numeric\"] == crd]\n    logger.info(f\"Found {len(subset)} PDF records for CRD {crd}\")\n    \n    if subset.empty:\n        logger.warning(f\"No PDF records found for CRD {crd}\")\n        return []\n    \n    subset = subset.drop(columns=[\"crd_numeric\"], errors=\"ignore\")\n    subset = subset.where(pd.notnull(subset), None)\n    records = subset.to_dict(orient=\"records\")\n    logger.info(f\"Returning {len(records)} PDF records for CRD {crd}\")\n    return records\n\n\n```\n\n\n============================================================\nSIGNAL 4\n============================================================\n\n## Error Information\n- File: authentication/clerk.py\n- Message: Remove quotes from type annotation\n- Rule Code: UP037\n- Severity: low\n- Location: Line 45, Column 29\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 43-47 (error on line 3 of 5)\n```python\n\n@classmethod\ndef from_config(cls) -> \"ClerkSettings\":\n    jwks_url = get_clerk_jwks_url()\n    issuer = get_clerk_issuer()\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 15-75\n```python\nfrom jwcrypto import jwk as jwcrypto_jwk\n\nfrom common.utils.config import (\n    get_clerk_audience,\n    get_clerk_issuer,\n    get_clerk_jwks_url,\n    get_lp_clerk_audience,\n    get_lp_clerk_issuer,\n    get_lp_clerk_jwks_url,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass ClerkTokenError(RuntimeError):\n    \"\"\"Raised when a Clerk token fails validation.\"\"\"\n\n\nclass ClerkConfigurationError(ClerkTokenError):\n    \"\"\"Raised when mandatory Clerk configuration values are missing.\"\"\"\n\n\n@dataclass(frozen=True)\nclass ClerkSettings:\n    jwks_url: str\n    issuer: str\n    audience: Optional[str] = None\n    cache_ttl_seconds: int = 300\n\n    @classmethod\n    def from_config(cls) -> \"ClerkSettings\":\n        jwks_url = get_clerk_jwks_url()\n        issuer = get_clerk_issuer()\n        audience = get_clerk_audience()\n\n        missing = [name for name, value in (\n            (\"CLERK_JWKS_URL\", jwks_url),\n            (\"CLERK_ISSUER\", issuer),\n        ) if not value]\n        if missing:\n            raise ClerkConfigurationError(\n                f\"Missing Clerk configuration value(s): {', '.join(missing)}\"\n            )\n\n        return cls(jwks_url=jwks_url, issuer=issuer, audience=audience)\n\n\ndef get_clerk_settings() -> ClerkSettings:\n    \"\"\"Load Clerk token validation settings from config helpers.\"\"\"\n    return ClerkSettings.from_config()\n\n\ndef get_lp_clerk_settings() -> ClerkSettings:\n    jwks_url = get_lp_clerk_jwks_url()\n    issuer = get_lp_clerk_issuer()\n    audience = get_lp_clerk_audience()\n\n    missing = [name for name, value in (\n        (\"LP_CLERK_JWKS_URL\", jwks_url),\n        (\"LP_CLERK_ISSUER\", issuer),\n    ) if not value]\n\n```\n\n## Enclosing Function\nLines 43-61\n```python\n\n    @classmethod\n    def from_config(cls) -> \"ClerkSettings\":\n        jwks_url = get_clerk_jwks_url()\n        issuer = get_clerk_issuer()\n        audience = get_clerk_audience()\n\n        missing = [name for name, value in (\n            (\"CLERK_JWKS_URL\", jwks_url),\n            (\"CLERK_ISSUER\", issuer),\n        ) if not value]\n        if missing:\n            raise ClerkConfigurationError(\n                f\"Missing Clerk configuration value(s): {', '.join(missing)}\"\n            )\n\n        return cls(jwks_url=jwks_url, issuer=issuer, audience=audience)\n\n\n\n```\n\n\nPlease provide fixes for the above signals using the specified response format."
  },
  "llm_response": [
    "===== FIX FOR: ria/services/company_service.py =====\n",
    "CONFIDENCE: 0.95\n",
    "REASONING: Modernizing type annotation from Dict to dict for Python 3.9+ compatibility\n",
    "\n",
    "```FIXED_CODE\n",
    "    \n",
    "@staticmethod\n",
    "def get_company_by_crd(crd: int) -> dict[str, Any]:\n",
    "    \"\"\"\n",
    "    Get company details from index by CRD number.\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: ria/services/company_service.py =====\n",
    "CONFIDENCE: 0.95\n",
    "REASONING: Modernizing type annotation from List[Dict[str, Any]] to list[dict[str, Any]] for Python 3.9+ compatibility\n",
    "\n",
    "```FIXED_CODE\n",
    "    \n",
    "@staticmethod\n",
    "def get_company_pdfs(crd: int) -> list[dict[str, Any]]:\n",
    "    \"\"\"\n",
    "    Get PDF records for a specific CRD.\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: ria/services/company_service.py =====\n",
    "CONFIDENCE: 0.95\n",
    "REASONING: Modernizing type annotation from List[Dict[str, Any]] to list[dict[str, Any]] for Python 3.9+ compatibility\n",
    "\n",
    "```FIXED_CODE\n",
    "\n",
    "\n",
    "def pdf_records_for_crd(crd: int) -> list[dict[str, Any]]:\n",
    "    \"\"\"Get PDF records for a specific CRD.\"\"\"\n",
    "    logger.info(f\"Looking up PDF records for CRD: {crd}\")\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: authentication/clerk.py =====\n",
    "CONFIDENCE: 0.95\n",
    "REASONING: Removing quotes from type annotation as the class is already defined in the same scope\n",
    "\n",
    "```FIXED_CODE\n",
    "\n",
    "@classmethod\n",
    "def from_config(cls) -> ClerkSettings:\n",
    "    jwks_url = get_clerk_jwks_url()\n",
    "    issuer = get_clerk_issuer()\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX ====="
  ]
}