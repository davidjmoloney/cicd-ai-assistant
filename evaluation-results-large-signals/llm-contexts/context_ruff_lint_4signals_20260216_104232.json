{
  "_debug_metadata": {
    "timestamp": "20260216_104232",
    "tool_id": "ruff",
    "signal_type": "lint",
    "num_signals": 4,
    "signal_files": [
      "authentication/utils.py",
      "ria/utils/helpers.py",
      "ria/services/company_service.py"
    ],
    "system_prompt_length": 8600,
    "user_prompt_length": 14282
  },
  "context": {
    "group": {
      "tool_id": "ruff",
      "signal_type": "lint",
      "group_size": 4
    },
    "signals": [
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "medium",
          "rule_code": "UP045",
          "message": "Use `X | None` for type annotations",
          "docs_url": "https://docs.astral.sh/ruff/rules/non-pep604-annotation-optional",
          "file_path": "authentication/utils.py",
          "span": {
            "start": {
              "row": 6,
              "column": 48
            },
            "end": {
              "row": 6,
              "column": 61
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "authentication/utils.py",
            "start_row": 1,
            "end_row": 36,
            "text": "\"\"\"Helper functions for extracting data from Clerk JWT claims.\"\"\"\n\nfrom typing import Optional\n\n\ndef extract_email_from_claims(claims: dict) -> Optional[str]:\n    \"\"\"Extract email from Clerk claims.\"\"\"\n    email = claims.get(\"email\")\n    if email:\n        return email.lower().strip()\n    # Clerk may nest email inside email_addresses array\n    email_addresses = claims.get(\"email_addresses\") or []\n    for entry in email_addresses:\n        if entry.get(\"id\") == claims.get(\"email_address_id\"):\n            extracted_email = entry.get(\"email_address\")\n            if extracted_email:\n                return extracted_email.lower().strip()\n    return None\n\n\ndef extract_roles_from_claims(claims: dict) -> list[str]:\n    \"\"\"Extract roles from Clerk claims.\"\"\"\n    metadata = claims.get(\"public_metadata\") or {}\n    roles = metadata.get(\"roles\")\n    if isinstance(roles, list):\n        return [str(role) for role in roles]\n    if isinstance(roles, str):\n        return [roles]\n    return []\n\n\ndef extract_daily_override_from_claims(claims: dict) -> Optional[int]:\n    metadata = claims.get(\"private_metadata\") or {}\n    override = metadata.get(\"dailyLimitOverride\")\n    try:\n        return int(override) if override is not None else None\n"
          },
          "imports": null,
          "enclosing_function": {
            "file_path": "authentication/utils.py",
            "start_row": 4,
            "end_row": 20,
            "text": "\n\ndef extract_email_from_claims(claims: dict) -> Optional[str]:\n    \"\"\"Extract email from Clerk claims.\"\"\"\n    email = claims.get(\"email\")\n    if email:\n        return email.lower().strip()\n    # Clerk may nest email inside email_addresses array\n    email_addresses = claims.get(\"email_addresses\") or []\n    for entry in email_addresses:\n        if entry.get(\"id\") == claims.get(\"email_address_id\"):\n            extracted_email = entry.get(\"email_address\")\n            if extracted_email:\n                return extracted_email.lower().strip()\n    return None\n\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "authentication/utils.py",
          "start_row": 1,
          "end_row": 13,
          "text": "\"\"\"Helper functions for extracting data from Clerk JWT claims.\"\"\"\n\nfrom typing import Optional\n\n\ndef extract_email_from_claims(claims: dict) -> Optional[str]:\n    \"\"\"Extract email from Clerk claims.\"\"\"\n    email = claims.get(\"email\")\n    if email:\n        return email.lower().strip()\n    # Clerk may nest email inside email_addresses array\n    email_addresses = claims.get(\"email_addresses\") or []\n    for entry in email_addresses:\n",
          "original_text": "\"\"\"Helper functions for extracting data from Clerk JWT claims.\"\"\"\n\nfrom typing import Optional\n\n\ndef extract_email_from_claims(claims: dict) -> Optional[str]:\n    \"\"\"Extract email from Clerk claims.\"\"\"\n    email = claims.get(\"email\")\n    if email:\n        return email.lower().strip()\n    # Clerk may nest email inside email_addresses array\n    email_addresses = claims.get(\"email_addresses\") or []\n    for entry in email_addresses:\n",
          "error_line": 6,
          "error_line_in_snippet": 6,
          "snippet_length": 13,
          "base_indent": ""
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": true,
          "applicability": "safe",
          "tool_message": "Convert to `X | None`",
          "edits": [
            {
              "span": {
                "start": {
                  "row": 6,
                  "column": 48
                },
                "end": {
                  "row": 6,
                  "column": 61
                }
              },
              "content": "str | None"
            }
          ]
        }
      },
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "medium",
          "rule_code": "UP045",
          "message": "Use `X | None` for type annotations",
          "docs_url": "https://docs.astral.sh/ruff/rules/non-pep604-annotation-optional",
          "file_path": "authentication/utils.py",
          "span": {
            "start": {
              "row": 32,
              "column": 57
            },
            "end": {
              "row": 32,
              "column": 70
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "authentication/utils.py",
            "start_row": 2,
            "end_row": 47,
            "text": "\nfrom typing import Optional\n\n\ndef extract_email_from_claims(claims: dict) -> Optional[str]:\n    \"\"\"Extract email from Clerk claims.\"\"\"\n    email = claims.get(\"email\")\n    if email:\n        return email.lower().strip()\n    # Clerk may nest email inside email_addresses array\n    email_addresses = claims.get(\"email_addresses\") or []\n    for entry in email_addresses:\n        if entry.get(\"id\") == claims.get(\"email_address_id\"):\n            extracted_email = entry.get(\"email_address\")\n            if extracted_email:\n                return extracted_email.lower().strip()\n    return None\n\n\ndef extract_roles_from_claims(claims: dict) -> list[str]:\n    \"\"\"Extract roles from Clerk claims.\"\"\"\n    metadata = claims.get(\"public_metadata\") or {}\n    roles = metadata.get(\"roles\")\n    if isinstance(roles, list):\n        return [str(role) for role in roles]\n    if isinstance(roles, str):\n        return [roles]\n    return []\n\n\ndef extract_daily_override_from_claims(claims: dict) -> Optional[int]:\n    metadata = claims.get(\"private_metadata\") or {}\n    override = metadata.get(\"dailyLimitOverride\")\n    try:\n        return int(override) if override is not None else None\n    except (TypeError, ValueError):\n        return None\n\n\ndef normalize_roles(roles: list[str], is_admin: bool = False) -> list[str]:\n    \"\"\"Normalize roles list. Add admin if is_admin is True.\"\"\"\n    normalized = set(roles)\n    if is_admin:\n        normalized.add(\"admin\")\n    return sorted(list(normalized))\n\n"
          },
          "imports": null,
          "enclosing_function": {
            "file_path": "authentication/utils.py",
            "start_row": 30,
            "end_row": 40,
            "text": "\n\ndef extract_daily_override_from_claims(claims: dict) -> Optional[int]:\n    metadata = claims.get(\"private_metadata\") or {}\n    override = metadata.get(\"dailyLimitOverride\")\n    try:\n        return int(override) if override is not None else None\n    except (TypeError, ValueError):\n        return None\n\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "authentication/utils.py",
          "start_row": 25,
          "end_row": 39,
          "text": "    if isinstance(roles, list):\n        return [str(role) for role in roles]\n    if isinstance(roles, str):\n        return [roles]\n    return []\n\n\ndef extract_daily_override_from_claims(claims: dict) -> Optional[int]:\n    metadata = claims.get(\"private_metadata\") or {}\n    override = metadata.get(\"dailyLimitOverride\")\n    try:\n        return int(override) if override is not None else None\n    except (TypeError, ValueError):\n        return None\n\n",
          "original_text": "    if isinstance(roles, list):\n        return [str(role) for role in roles]\n    if isinstance(roles, str):\n        return [roles]\n    return []\n\n\ndef extract_daily_override_from_claims(claims: dict) -> Optional[int]:\n    metadata = claims.get(\"private_metadata\") or {}\n    override = metadata.get(\"dailyLimitOverride\")\n    try:\n        return int(override) if override is not None else None\n    except (TypeError, ValueError):\n        return None\n\n",
          "error_line": 32,
          "error_line_in_snippet": 8,
          "snippet_length": 15,
          "base_indent": ""
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": true,
          "applicability": "safe",
          "tool_message": "Convert to `X | None`",
          "edits": [
            {
              "span": {
                "start": {
                  "row": 32,
                  "column": 57
                },
                "end": {
                  "row": 32,
                  "column": 70
                }
              },
              "content": "int | None"
            }
          ]
        }
      },
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "medium",
          "rule_code": "UP045",
          "message": "Use `X | None` for type annotations",
          "docs_url": "https://docs.astral.sh/ruff/rules/non-pep604-annotation-optional",
          "file_path": "ria/utils/helpers.py",
          "span": {
            "start": {
              "row": 22,
              "column": 40
            },
            "end": {
              "row": 22,
              "column": 54
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/utils/helpers.py",
            "start_row": 1,
            "end_row": 52,
            "text": "\"\"\"\nRIA Helper Functions\n\nThis module contains utility functions for RIA operations including:\n- Search ID generation\n- Search context extraction\n- Session ID management\n- Search parameter formatting\n\"\"\"\n\nimport json\nimport time\nimport uuid\nfrom typing import Optional, Dict, Any\n\n\ndef generate_search_id() -> str:\n    \"\"\"Generate a unique search ID for tracking related activities.\"\"\"\n    return f\"search_{int(time.time() * 1000)}_{uuid.uuid4().hex[:9]}\"\n\n\ndef extract_search_context(request) -> Optional[dict]:\n    # Django uses request.META for headers (prefixed with HTTP_)\n    # FastAPI uses request.headers\n    search_context_header = None\n    \n    # Try Django-style header access\n    if hasattr(request, 'META'):\n        search_context_header = request.META.get('HTTP_X_SEARCH_CONTEXT')\n    # Try FastAPI-style header access (for backward compatibility)\n    elif hasattr(request, 'headers'):\n        search_context_header = request.headers.get(\"X-Search-Context\")\n    \n    if not search_context_header:\n        return None\n    \n    try:\n        return json.loads(search_context_header)\n    except json.JSONDecodeError:\n        from common.utils.logging_config import get_logger\n        logger = get_logger(__name__)\n        logger.warning(f\"Invalid search context header: {search_context_header}\")\n        return None\n\n\ndef get_session_id_from_request(request) -> str:\n    \"\"\"\n    Extract session ID from request headers or generate a new one.\n    \n    Args:\n        request: Django request object\n    \n"
          },
          "imports": {
            "file_path": "ria/utils/helpers.py",
            "start_row": 1,
            "end_row": 16,
            "text": "\"\"\"\nRIA Helper Functions\n\nThis module contains utility functions for RIA operations including:\n- Search ID generation\n- Search context extraction\n- Session ID management\n- Search parameter formatting\n\"\"\"\n\nimport json\nimport time\nimport uuid\nfrom typing import Optional, Dict, Any\n\n\n"
          },
          "enclosing_function": {
            "file_path": "ria/utils/helpers.py",
            "start_row": 20,
            "end_row": 45,
            "text": "\n\ndef extract_search_context(request) -> Optional[dict]:\n    # Django uses request.META for headers (prefixed with HTTP_)\n    # FastAPI uses request.headers\n    search_context_header = None\n    \n    # Try Django-style header access\n    if hasattr(request, 'META'):\n        search_context_header = request.META.get('HTTP_X_SEARCH_CONTEXT')\n    # Try FastAPI-style header access (for backward compatibility)\n    elif hasattr(request, 'headers'):\n        search_context_header = request.headers.get(\"X-Search-Context\")\n    \n    if not search_context_header:\n        return None\n    \n    try:\n        return json.loads(search_context_header)\n    except json.JSONDecodeError:\n        from common.utils.logging_config import get_logger\n        logger = get_logger(__name__)\n        logger.warning(f\"Invalid search context header: {search_context_header}\")\n        return None\n\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/utils/helpers.py",
          "start_row": 15,
          "end_row": 29,
          "text": "\n\ndef generate_search_id() -> str:\n    \"\"\"Generate a unique search ID for tracking related activities.\"\"\"\n    return f\"search_{int(time.time() * 1000)}_{uuid.uuid4().hex[:9]}\"\n\n\ndef extract_search_context(request) -> Optional[dict]:\n    # Django uses request.META for headers (prefixed with HTTP_)\n    # FastAPI uses request.headers\n    search_context_header = None\n    \n    # Try Django-style header access\n    if hasattr(request, 'META'):\n        search_context_header = request.META.get('HTTP_X_SEARCH_CONTEXT')\n",
          "original_text": "\n\ndef generate_search_id() -> str:\n    \"\"\"Generate a unique search ID for tracking related activities.\"\"\"\n    return f\"search_{int(time.time() * 1000)}_{uuid.uuid4().hex[:9]}\"\n\n\ndef extract_search_context(request) -> Optional[dict]:\n    # Django uses request.META for headers (prefixed with HTTP_)\n    # FastAPI uses request.headers\n    search_context_header = None\n    \n    # Try Django-style header access\n    if hasattr(request, 'META'):\n        search_context_header = request.META.get('HTTP_X_SEARCH_CONTEXT')\n",
          "error_line": 22,
          "error_line_in_snippet": 8,
          "snippet_length": 15,
          "base_indent": ""
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": true,
          "applicability": "safe",
          "tool_message": "Convert to `X | None`",
          "edits": [
            {
              "span": {
                "start": {
                  "row": 22,
                  "column": 40
                },
                "end": {
                  "row": 22,
                  "column": 54
                }
              },
              "content": "dict | None"
            }
          ]
        }
      },
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "medium",
          "rule_code": "B904",
          "message": "Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling",
          "docs_url": "https://docs.astral.sh/ruff/rules/raise-without-from-inside-except",
          "file_path": "ria/services/company_service.py",
          "span": {
            "start": {
              "row": 97,
              "column": 13
            },
            "end": {
              "row": 97,
              "column": 68
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/services/company_service.py",
            "start_row": 67,
            "end_row": 127,
            "text": "    \n    @staticmethod\n    def load_trends_json(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Load trend data for a specific CRD from S3.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            Trend data as dictionary\n        \"\"\"\n        return _load_trends_json(crd)\n\n\ndef _load_trends_json(crd: int) -> Dict[str, Any]:\n    \"\"\"Load trend data for a specific CRD from S3.\"\"\"\n    s3_client = boto3.client('s3')\n    bucket = get_s3_bucket()\n    \n    # S3 path structure: output/sec_ingestion/processed/trends/latest/crd={crd}/trends.v1.json\n    s3_path = f\"{get_s3_prefix()}/processed/trends/latest/crd={crd}/trends.v1.json\"\n    \n    try:\n        # Download trend data from S3\n        response = s3_client.get_object(Bucket=bucket, Key=s3_path)\n        content = response['Body'].read().decode('utf-8')\n        return json.loads(content)\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'NoSuchKey':\n            raise ValueError(f\"Trend data not found for CRD {crd}\")\n        else:\n            raise RuntimeError(f\"Failed to load trend data: {str(e)}\")\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid trend data format: {str(e)}\")\n\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"Get PDF records for a specific CRD.\"\"\"\n    logger.info(f\"Looking up PDF records for CRD: {crd}\")\n    \n    pdf_cache = get_pdf_cache()\n    pdf_df = pdf_cache.load().copy()\n    logger.info(f\"Loaded PDF data: {len(pdf_df)} rows, columns: {list(pdf_df.columns)}\")\n    \n    if \"crd\" not in pdf_df.columns:\n        logger.error(\"\u274c RIA latest.csv missing 'crd' column\")\n        raise RuntimeError(\"RIA latest.csv missing 'crd' column\")\n    \n    pdf_df[\"crd_numeric\"] = pd.to_numeric(pdf_df[\"crd\"], errors=\"coerce\")\n    subset = pdf_df[pdf_df[\"crd_numeric\"] == crd]\n    logger.info(f\"Found {len(subset)} PDF records for CRD {crd}\")\n    \n    if subset.empty:\n        logger.warning(f\"No PDF records found for CRD {crd}\")\n        return []\n    \n    subset = subset.drop(columns=[\"crd_numeric\"], errors=\"ignore\")\n    subset = subset.where(pd.notnull(subset), None)\n    records = subset.to_dict(orient=\"records\")\n    logger.info(f\"Returning {len(records)} PDF records for CRD {crd}\")\n"
          },
          "imports": {
            "file_path": "ria/services/company_service.py",
            "start_row": 1,
            "end_row": 20,
            "text": "\"\"\"\nCompany Service\n\nThis service handles company detail operations including:\n- Getting company by CRD\n- Loading PDF records\n- Loading trend data\n\"\"\"\n\nimport json\nfrom typing import Dict, Any, List, Optional\n\nimport boto3\nimport pandas as pd\nimport polars as pl\nfrom botocore.exceptions import ClientError\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.services.pdf_cache_service import get_pdf_cache\nfrom ria.utils.constants import (\n"
          },
          "enclosing_function": {
            "file_path": "ria/services/company_service.py",
            "start_row": 80,
            "end_row": 103,
            "text": "\n\ndef _load_trends_json(crd: int) -> Dict[str, Any]:\n    \"\"\"Load trend data for a specific CRD from S3.\"\"\"\n    s3_client = boto3.client('s3')\n    bucket = get_s3_bucket()\n    \n    # S3 path structure: output/sec_ingestion/processed/trends/latest/crd={crd}/trends.v1.json\n    s3_path = f\"{get_s3_prefix()}/processed/trends/latest/crd={crd}/trends.v1.json\"\n    \n    try:\n        # Download trend data from S3\n        response = s3_client.get_object(Bucket=bucket, Key=s3_path)\n        content = response['Body'].read().decode('utf-8')\n        return json.loads(content)\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'NoSuchKey':\n            raise ValueError(f\"Trend data not found for CRD {crd}\")\n        else:\n            raise RuntimeError(f\"Failed to load trend data: {str(e)}\")\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid trend data format: {str(e)}\")\n\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/services/company_service.py",
          "start_row": 90,
          "end_row": 104,
          "text": "    try:\n        # Download trend data from S3\n        response = s3_client.get_object(Bucket=bucket, Key=s3_path)\n        content = response['Body'].read().decode('utf-8')\n        return json.loads(content)\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'NoSuchKey':\n            raise ValueError(f\"Trend data not found for CRD {crd}\")\n        else:\n            raise RuntimeError(f\"Failed to load trend data: {str(e)}\")\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid trend data format: {str(e)}\")\n\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n",
          "original_text": "    try:\n        # Download trend data from S3\n        response = s3_client.get_object(Bucket=bucket, Key=s3_path)\n        content = response['Body'].read().decode('utf-8')\n        return json.loads(content)\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'NoSuchKey':\n            raise ValueError(f\"Trend data not found for CRD {crd}\")\n        else:\n            raise RuntimeError(f\"Failed to load trend data: {str(e)}\")\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid trend data format: {str(e)}\")\n\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n",
          "error_line": 97,
          "error_line_in_snippet": 8,
          "snippet_length": 15,
          "base_indent": ""
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": false
        }
      }
    ],
    "merged_snippet_groups": [],
    "standalone_signal_indices": [
      0,
      1,
      2,
      3
    ]
  },
  "prompts": {
    "system_prompt": "You are an expert code repair agent. Your task is to make MINIMAL, SURGICAL fixes to code errors.\n\n## CRITICAL PRINCIPLE: MINIMAL CHANGES ONLY\n\nYour job is to fix ONLY the specific error mentioned. You are NOT improving, refactoring, or cleaning up code.\n\n**THE GOLDEN RULE**: Every line in your output that is NOT directly part of the fix MUST be IDENTICAL to the input - same content, same whitespace, same everything.\n\n## How This Works\n\nFor each error signal, you will receive:\n\n1. **Error Information**: Type, message, severity, and rule code\n2. **Edit Snippet**: A small code snippet (~13 lines) containing the error\n   - This is what you need to FIX and RETURN\n   - The error location within the snippet is indicated (e.g., \"Error on line 4 of 13\")\n3. **Context Window**: A larger code window (~30 lines) around the error for understanding\n   - Use this to understand the surrounding code, but DON'T return it\n\n4. **Tailored Context** (varies by signal type - optimized to reduce token usage):\n   - **Imports**: The file's import block (for type definitions, dependencies)\n     - Included for: type errors, undefined names, most issues\n     - Excluded for: import-only errors, bare except blocks\n   - **Enclosing Function**: The function containing the error (for understanding scope/logic)\n     - Included for: type errors, docstring errors, function-level issues\n     - Excluded for: import errors (global scope), bare except (sent separately)\n   - **Try/Except Block**: The try/except block containing the error\n     - Included for: bare except errors (E722)\n     - Excluded for: most other errors\n\nNote: Context is carefully selected to provide what you need while minimizing token usage.\nNot all context is present for every error - you'll only receive relevant context.\n\n## Response Format\n\nFor EACH signal/snippet you receive, respond with this EXACT format:\n\n```\n===== FIX FOR: <file_path> =====\nCONFIDENCE: <0.0-1.0>\nREASONING: <brief explanation of the fix>\n\n```FIXED_CODE\n<complete fixed snippet - ALL lines from edit_snippet, with ONLY the fix applied>\n```\n\nWARNINGS: <any caveats, or \"None\">\n===== END FIX =====\n```\n\n## CRITICAL Rules - READ CAREFULLY\n\n1. **MINIMAL CHANGES ONLY** - Change ONLY what is necessary to fix the specific error. Nothing more.\n\n2. **PRESERVE EVERYTHING ELSE EXACTLY** - Every line that is NOT part of the fix must be returned EXACTLY as it appeared in the input, character-for-character, including:\n   - Comments and documentation\n   - Blank lines (including leading and trailing blank lines)\n   - All whitespace (including trailing newlines at the end of the snippet)\n   - Other variable declarations\n   - Function definitions\n   - String content (including multi-line strings)\n\n   **CRITICAL**: If the input snippet ends with blank lines or newlines, your output MUST end with the exact same number of blank lines/newlines. Do NOT trim trailing whitespace.\n\n3. **DO NOT under any circumstances**:\n   - Delete lines that aren't related to the fix\n   - Add code that isn't required for the fix\n   - \"Clean up\" or \"improve\" surrounding code\n   - Modify comments or documentation\n   - Change formatting on unrelated lines\n   - Remove blank lines\n   - Add blank lines (unless the fix specifically requires it)\n   - Modify string literals or docstrings\n   - Delete function definitions\n   - Remove dictionary entries or list items unrelated to the fix\n\n4. **Maintain RELATIVE indentation** - The snippet has had its base indentation removed. Preserve relative indentation exactly. If a line has 4 spaces in the input, it must have 4 spaces in your output.\n\n5. **One fix block per signal** - If multiple signals, provide multiple fix blocks\n\n6. **Use context for understanding only** - The context window, imports, and enclosing function help you understand the code, but you only return the fixed edit_snippet\n\n## Example - Correct Minimal Fix\n\nInput:\n- Error: \"Need type annotation for 'cache'\" on line 173\n- Edit Snippet (error on line 4 of 7, lines 170-176):\n```\n}\n\nDEPRIORITIZE_QUERIES = {}\ncache = {}\n\n# Model configuration\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n(Note: The snippet ends with a newline after the last line - this MUST be preserved)\n\nCORRECT Response (only `cache = {}` changed to `cache: dict = {}`):\n```\n===== FIX FOR: app/config/tier_queries.py =====\nCONFIDENCE: 0.95\nREASONING: Added dict type annotation to cache variable to satisfy mypy\n\n```FIXED_CODE\n}\n\nDEPRIORITIZE_QUERIES = {}\ncache: dict = {}\n\n# Model configuration\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n\nWARNINGS: None\n===== END FIX =====\n```\n(Note: The output preserves the exact same trailing newline as the input)\n\n## Example - Preserving Trailing Whitespace\n\nInput snippet ending with blank lines (note the TWO newlines after the return statement):\n```\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n\n\n```\n\nCORRECT - Preserves both trailing newlines:\n```FIXED_CODE\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n\n\n```\n(Output MUST have the same TWO trailing newlines)\n\nWRONG - Trimming trailing newlines:\n```FIXED_CODE\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n```\n^ This is WRONG because it removed trailing newlines. The snippet MUST end with the same whitespace as the input.\n\n## Example - WRONG (Deleting Unrelated Content)\n\nIf the input snippet contains documentation or other code, you MUST preserve it:\n\nWRONG - Deleting unrelated lines:\n```FIXED_CODE\ncache: dict = {}\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n^ This is WRONG because it deleted the closing brace, blank lines, DEPRIORITIZE_QUERIES, and the comment.\n\n## Confidence Guidelines\n- High (>0.8): Simple fixes like type annotations, obvious corrections\n- Medium (0.5-0.8): Logic changes, type guards, refactoring\n- Low (<0.5): Complex changes, unclear intent - add detailed warnings\n\n\n\n## Ruff Lint Error Fixing - Specialized Guidance\n\nYou are fixing LINTING errors from Ruff. These are code quality, style, and\nbest practice issues - NOT security or type correctness.\n\nRisk Level: LOW to MEDIUM\nThese fixes should improve code quality without changing behavior.\n\nCommon Ruff Rule Categories:\n\nF (Pyflakes):\n- Unused imports/variables\n- Undefined names\n- Duplicate arguments\n- Invalid format strings\n\nE/W (pycodestyle):\n- Line length (E501)\n- Whitespace issues (E203, W291)\n- Indentation (E111, E114)\n- Blank lines (E302, E303)\n\nC (McCabe):\n- Complexity warnings (C901)\n- Too many branches/statements\n\nN (pep8-naming):\n- Naming conventions (N801-N818)\n- Lowercase function names\n- CamelCase class names\n\nI (isort):\n- Import sorting/organization\n\nUP (pyupgrade):\n- Outdated syntax\n- Type hint modernization\n\nFixing Strategies:\n\n1. **Remove Unused Code** - But verify it's truly unused\n   \u2705 Remove unused imports\n   \u2705 Remove unused variables\n   \u26a0\ufe0f Check for side effects first!\n\n2. **Simplify Logic** - Follow Python idioms\n   \u2705 `if x == True:` \u2192 `if x:`\n   \u2705 `if len(list) > 0:` \u2192 `if list:`\n   \u2705 Use comprehensions instead of loops\n\n3. **Fix Naming** - Follow PEP 8\n   \u2705 `MyFunction` \u2192 `my_function`\n   \u2705 `my_class` \u2192 `MyClass`\n\n4. **Modernize Syntax** - Use newer Python features\n   \u2705 `Union[str, int]` \u2192 `str | int` (Python 3.10+)\n   \u2705 `Optional[str]` \u2192 `str | None` (Python 3.10+)\n\n5. **Organize Imports** - Sort and group properly\n   \u2705 Standard library first\n   \u2705 Third-party second\n   \u2705 Local imports last\n\nNEVER do these:\n\u274c Remove code that has side effects (initializers, registrations)\n\u274c Change behavior to fix style\n\u274c Break working code to satisfy complexity metrics\n\u274c Remove \"unused\" variables that are part of unpacking\n\nSpecial Cases:\n\nComplexity Warnings (C901):\n- Don't just suppress with # noqa\n- Consider refactoring if genuinely complex\n- But set confidence < 0.7 for refactoring suggestions\n\nUnused Variables:\n- `x, y, z = tuple` - y might be \"unused\" but needed for unpacking\n- Consider renaming to `_` if truly unused: `x, _, z = tuple`\n\nLine Length (E501):\n- Can often be fixed by breaking long lines\n- But some URLs or strings are legitimately long\n- Use # noqa: E501 with comment explaining why\n\nConfidence Guidelines:\n- High (>0.8): Remove unused imports, fix obvious naming\n- Medium (0.5-0.8): Simplify logic, organize imports\n- Low (<0.5): Refactoring suggestions, complex changes\n\nRemember: Preserve behavior. These are style improvements, not bug fixes.\n",
    "user_prompt": "Tool: ruff\nSignal Type: lint\nNumber of Signals: 4\n\n============================================================\nSIGNAL 1\n============================================================\n\n## Error Information\n- File: authentication/utils.py\n- Message: Use `X | None` for type annotations\n- Rule Code: UP045\n- Severity: medium\n- Location: Line 6, Column 48\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 1-13 (error on line 6 of 13)\n```python\n\"\"\"Helper functions for extracting data from Clerk JWT claims.\"\"\"\n\nfrom typing import Optional\n\n\ndef extract_email_from_claims(claims: dict) -> Optional[str]:\n    \"\"\"Extract email from Clerk claims.\"\"\"\n    email = claims.get(\"email\")\n    if email:\n        return email.lower().strip()\n    # Clerk may nest email inside email_addresses array\n    email_addresses = claims.get(\"email_addresses\") or []\n    for entry in email_addresses:\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 1-36\n```python\n\"\"\"Helper functions for extracting data from Clerk JWT claims.\"\"\"\n\nfrom typing import Optional\n\n\ndef extract_email_from_claims(claims: dict) -> Optional[str]:\n    \"\"\"Extract email from Clerk claims.\"\"\"\n    email = claims.get(\"email\")\n    if email:\n        return email.lower().strip()\n    # Clerk may nest email inside email_addresses array\n    email_addresses = claims.get(\"email_addresses\") or []\n    for entry in email_addresses:\n        if entry.get(\"id\") == claims.get(\"email_address_id\"):\n            extracted_email = entry.get(\"email_address\")\n            if extracted_email:\n                return extracted_email.lower().strip()\n    return None\n\n\ndef extract_roles_from_claims(claims: dict) -> list[str]:\n    \"\"\"Extract roles from Clerk claims.\"\"\"\n    metadata = claims.get(\"public_metadata\") or {}\n    roles = metadata.get(\"roles\")\n    if isinstance(roles, list):\n        return [str(role) for role in roles]\n    if isinstance(roles, str):\n        return [roles]\n    return []\n\n\ndef extract_daily_override_from_claims(claims: dict) -> Optional[int]:\n    metadata = claims.get(\"private_metadata\") or {}\n    override = metadata.get(\"dailyLimitOverride\")\n    try:\n        return int(override) if override is not None else None\n\n```\n\n## Enclosing Function\nLines 4-20\n```python\n\n\ndef extract_email_from_claims(claims: dict) -> Optional[str]:\n    \"\"\"Extract email from Clerk claims.\"\"\"\n    email = claims.get(\"email\")\n    if email:\n        return email.lower().strip()\n    # Clerk may nest email inside email_addresses array\n    email_addresses = claims.get(\"email_addresses\") or []\n    for entry in email_addresses:\n        if entry.get(\"id\") == claims.get(\"email_address_id\"):\n            extracted_email = entry.get(\"email_address\")\n            if extracted_email:\n                return extracted_email.lower().strip()\n    return None\n\n\n\n```\n\n\n============================================================\nSIGNAL 2\n============================================================\n\n## Error Information\n- File: authentication/utils.py\n- Message: Use `X | None` for type annotations\n- Rule Code: UP045\n- Severity: medium\n- Location: Line 32, Column 57\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 25-39 (error on line 8 of 15)\n```python\n    if isinstance(roles, list):\n        return [str(role) for role in roles]\n    if isinstance(roles, str):\n        return [roles]\n    return []\n\n\ndef extract_daily_override_from_claims(claims: dict) -> Optional[int]:\n    metadata = claims.get(\"private_metadata\") or {}\n    override = metadata.get(\"dailyLimitOverride\")\n    try:\n        return int(override) if override is not None else None\n    except (TypeError, ValueError):\n        return None\n\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 2-47\n```python\n\nfrom typing import Optional\n\n\ndef extract_email_from_claims(claims: dict) -> Optional[str]:\n    \"\"\"Extract email from Clerk claims.\"\"\"\n    email = claims.get(\"email\")\n    if email:\n        return email.lower().strip()\n    # Clerk may nest email inside email_addresses array\n    email_addresses = claims.get(\"email_addresses\") or []\n    for entry in email_addresses:\n        if entry.get(\"id\") == claims.get(\"email_address_id\"):\n            extracted_email = entry.get(\"email_address\")\n            if extracted_email:\n                return extracted_email.lower().strip()\n    return None\n\n\ndef extract_roles_from_claims(claims: dict) -> list[str]:\n    \"\"\"Extract roles from Clerk claims.\"\"\"\n    metadata = claims.get(\"public_metadata\") or {}\n    roles = metadata.get(\"roles\")\n    if isinstance(roles, list):\n        return [str(role) for role in roles]\n    if isinstance(roles, str):\n        return [roles]\n    return []\n\n\ndef extract_daily_override_from_claims(claims: dict) -> Optional[int]:\n    metadata = claims.get(\"private_metadata\") or {}\n    override = metadata.get(\"dailyLimitOverride\")\n    try:\n        return int(override) if override is not None else None\n    except (TypeError, ValueError):\n        return None\n\n\ndef normalize_roles(roles: list[str], is_admin: bool = False) -> list[str]:\n    \"\"\"Normalize roles list. Add admin if is_admin is True.\"\"\"\n    normalized = set(roles)\n    if is_admin:\n        normalized.add(\"admin\")\n    return sorted(list(normalized))\n\n\n```\n\n## Enclosing Function\nLines 30-40\n```python\n\n\ndef extract_daily_override_from_claims(claims: dict) -> Optional[int]:\n    metadata = claims.get(\"private_metadata\") or {}\n    override = metadata.get(\"dailyLimitOverride\")\n    try:\n        return int(override) if override is not None else None\n    except (TypeError, ValueError):\n        return None\n\n\n\n```\n\n\n============================================================\nSIGNAL 3\n============================================================\n\n## Error Information\n- File: ria/utils/helpers.py\n- Message: Use `X | None` for type annotations\n- Rule Code: UP045\n- Severity: medium\n- Location: Line 22, Column 40\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 15-29 (error on line 8 of 15)\n```python\n\n\ndef generate_search_id() -> str:\n    \"\"\"Generate a unique search ID for tracking related activities.\"\"\"\n    return f\"search_{int(time.time() * 1000)}_{uuid.uuid4().hex[:9]}\"\n\n\ndef extract_search_context(request) -> Optional[dict]:\n    # Django uses request.META for headers (prefixed with HTTP_)\n    # FastAPI uses request.headers\n    search_context_header = None\n    \n    # Try Django-style header access\n    if hasattr(request, 'META'):\n        search_context_header = request.META.get('HTTP_X_SEARCH_CONTEXT')\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 1-52\n```python\n\"\"\"\nRIA Helper Functions\n\nThis module contains utility functions for RIA operations including:\n- Search ID generation\n- Search context extraction\n- Session ID management\n- Search parameter formatting\n\"\"\"\n\nimport json\nimport time\nimport uuid\nfrom typing import Optional, Dict, Any\n\n\ndef generate_search_id() -> str:\n    \"\"\"Generate a unique search ID for tracking related activities.\"\"\"\n    return f\"search_{int(time.time() * 1000)}_{uuid.uuid4().hex[:9]}\"\n\n\ndef extract_search_context(request) -> Optional[dict]:\n    # Django uses request.META for headers (prefixed with HTTP_)\n    # FastAPI uses request.headers\n    search_context_header = None\n    \n    # Try Django-style header access\n    if hasattr(request, 'META'):\n        search_context_header = request.META.get('HTTP_X_SEARCH_CONTEXT')\n    # Try FastAPI-style header access (for backward compatibility)\n    elif hasattr(request, 'headers'):\n        search_context_header = request.headers.get(\"X-Search-Context\")\n    \n    if not search_context_header:\n        return None\n    \n    try:\n        return json.loads(search_context_header)\n    except json.JSONDecodeError:\n        from common.utils.logging_config import get_logger\n        logger = get_logger(__name__)\n        logger.warning(f\"Invalid search context header: {search_context_header}\")\n        return None\n\n\ndef get_session_id_from_request(request) -> str:\n    \"\"\"\n    Extract session ID from request headers or generate a new one.\n    \n    Args:\n        request: Django request object\n    \n\n```\n\n## Imports\n```python\n\"\"\"\nRIA Helper Functions\n\nThis module contains utility functions for RIA operations including:\n- Search ID generation\n- Search context extraction\n- Session ID management\n- Search parameter formatting\n\"\"\"\n\nimport json\nimport time\nimport uuid\nfrom typing import Optional, Dict, Any\n\n\n\n```\n\n## Enclosing Function\nLines 20-45\n```python\n\n\ndef extract_search_context(request) -> Optional[dict]:\n    # Django uses request.META for headers (prefixed with HTTP_)\n    # FastAPI uses request.headers\n    search_context_header = None\n    \n    # Try Django-style header access\n    if hasattr(request, 'META'):\n        search_context_header = request.META.get('HTTP_X_SEARCH_CONTEXT')\n    # Try FastAPI-style header access (for backward compatibility)\n    elif hasattr(request, 'headers'):\n        search_context_header = request.headers.get(\"X-Search-Context\")\n    \n    if not search_context_header:\n        return None\n    \n    try:\n        return json.loads(search_context_header)\n    except json.JSONDecodeError:\n        from common.utils.logging_config import get_logger\n        logger = get_logger(__name__)\n        logger.warning(f\"Invalid search context header: {search_context_header}\")\n        return None\n\n\n\n```\n\n\n============================================================\nSIGNAL 4\n============================================================\n\n## Error Information\n- File: ria/services/company_service.py\n- Message: Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling\n- Rule Code: B904\n- Severity: medium\n- Location: Line 97, Column 13\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 90-104 (error on line 8 of 15)\n```python\n    try:\n        # Download trend data from S3\n        response = s3_client.get_object(Bucket=bucket, Key=s3_path)\n        content = response['Body'].read().decode('utf-8')\n        return json.loads(content)\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'NoSuchKey':\n            raise ValueError(f\"Trend data not found for CRD {crd}\")\n        else:\n            raise RuntimeError(f\"Failed to load trend data: {str(e)}\")\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid trend data format: {str(e)}\")\n\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 67-127\n```python\n    \n    @staticmethod\n    def load_trends_json(crd: int) -> Dict[str, Any]:\n        \"\"\"\n        Load trend data for a specific CRD from S3.\n        \n        Args:\n            crd: Company CRD number\n            \n        Returns:\n            Trend data as dictionary\n        \"\"\"\n        return _load_trends_json(crd)\n\n\ndef _load_trends_json(crd: int) -> Dict[str, Any]:\n    \"\"\"Load trend data for a specific CRD from S3.\"\"\"\n    s3_client = boto3.client('s3')\n    bucket = get_s3_bucket()\n    \n    # S3 path structure: output/sec_ingestion/processed/trends/latest/crd={crd}/trends.v1.json\n    s3_path = f\"{get_s3_prefix()}/processed/trends/latest/crd={crd}/trends.v1.json\"\n    \n    try:\n        # Download trend data from S3\n        response = s3_client.get_object(Bucket=bucket, Key=s3_path)\n        content = response['Body'].read().decode('utf-8')\n        return json.loads(content)\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'NoSuchKey':\n            raise ValueError(f\"Trend data not found for CRD {crd}\")\n        else:\n            raise RuntimeError(f\"Failed to load trend data: {str(e)}\")\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid trend data format: {str(e)}\")\n\n\ndef pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n    \"\"\"Get PDF records for a specific CRD.\"\"\"\n    logger.info(f\"Looking up PDF records for CRD: {crd}\")\n    \n    pdf_cache = get_pdf_cache()\n    pdf_df = pdf_cache.load().copy()\n    logger.info(f\"Loaded PDF data: {len(pdf_df)} rows, columns: {list(pdf_df.columns)}\")\n    \n    if \"crd\" not in pdf_df.columns:\n        logger.error(\"\u274c RIA latest.csv missing 'crd' column\")\n        raise RuntimeError(\"RIA latest.csv missing 'crd' column\")\n    \n    pdf_df[\"crd_numeric\"] = pd.to_numeric(pdf_df[\"crd\"], errors=\"coerce\")\n    subset = pdf_df[pdf_df[\"crd_numeric\"] == crd]\n    logger.info(f\"Found {len(subset)} PDF records for CRD {crd}\")\n    \n    if subset.empty:\n        logger.warning(f\"No PDF records found for CRD {crd}\")\n        return []\n    \n    subset = subset.drop(columns=[\"crd_numeric\"], errors=\"ignore\")\n    subset = subset.where(pd.notnull(subset), None)\n    records = subset.to_dict(orient=\"records\")\n    logger.info(f\"Returning {len(records)} PDF records for CRD {crd}\")\n\n```\n\n## Imports\n```python\n\"\"\"\nCompany Service\n\nThis service handles company detail operations including:\n- Getting company by CRD\n- Loading PDF records\n- Loading trend data\n\"\"\"\n\nimport json\nfrom typing import Dict, Any, List, Optional\n\nimport boto3\nimport pandas as pd\nimport polars as pl\nfrom botocore.exceptions import ClientError\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.services.pdf_cache_service import get_pdf_cache\nfrom ria.utils.constants import (\n\n```\n\n## Enclosing Function\nLines 80-103\n```python\n\n\ndef _load_trends_json(crd: int) -> Dict[str, Any]:\n    \"\"\"Load trend data for a specific CRD from S3.\"\"\"\n    s3_client = boto3.client('s3')\n    bucket = get_s3_bucket()\n    \n    # S3 path structure: output/sec_ingestion/processed/trends/latest/crd={crd}/trends.v1.json\n    s3_path = f\"{get_s3_prefix()}/processed/trends/latest/crd={crd}/trends.v1.json\"\n    \n    try:\n        # Download trend data from S3\n        response = s3_client.get_object(Bucket=bucket, Key=s3_path)\n        content = response['Body'].read().decode('utf-8')\n        return json.loads(content)\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'NoSuchKey':\n            raise ValueError(f\"Trend data not found for CRD {crd}\")\n        else:\n            raise RuntimeError(f\"Failed to load trend data: {str(e)}\")\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid trend data format: {str(e)}\")\n\n\n\n```\n\n\nPlease provide fixes for the above signals using the specified response format."
  },
  "llm_response": [
    "===== FIX FOR: authentication/utils.py =====\n",
    "CONFIDENCE: 0.95\n",
    "REASONING: Modernizing type annotation from Optional[str] to str | None as recommended by UP045\n",
    "\n",
    "```FIXED_CODE\n",
    "\"\"\"Helper functions for extracting data from Clerk JWT claims.\"\"\"\n",
    "\n",
    "from typing import Optional\n",
    "\n",
    "\n",
    "def extract_email_from_claims(claims: dict) -> str | None:\n",
    "    \"\"\"Extract email from Clerk claims.\"\"\"\n",
    "    email = claims.get(\"email\")\n",
    "    if email:\n",
    "        return email.lower().strip()\n",
    "    # Clerk may nest email inside email_addresses array\n",
    "    email_addresses = claims.get(\"email_addresses\") or []\n",
    "    for entry in email_addresses:\n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: authentication/utils.py =====\n",
    "CONFIDENCE: 0.95\n",
    "REASONING: Modernizing type annotation from Optional[int] to int | None as recommended by UP045\n",
    "\n",
    "```FIXED_CODE\n",
    "    if isinstance(roles, list):\n",
    "        return [str(role) for role in roles]\n",
    "    if isinstance(roles, str):\n",
    "        return [roles]\n",
    "    return []\n",
    "\n",
    "\n",
    "def extract_daily_override_from_claims(claims: dict) -> int | None:\n",
    "    metadata = claims.get(\"private_metadata\") or {}\n",
    "    override = metadata.get(\"dailyLimitOverride\")\n",
    "    try:\n",
    "        return int(override) if override is not None else None\n",
    "    except (TypeError, ValueError):\n",
    "        return None\n",
    "\n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: ria/utils/helpers.py =====\n",
    "CONFIDENCE: 0.95\n",
    "REASONING: Modernizing type annotation from Optional[dict] to dict | None as recommended by UP045\n",
    "\n",
    "```FIXED_CODE\n",
    "\n",
    "\n",
    "def generate_search_id() -> str:\n",
    "    \"\"\"Generate a unique search ID for tracking related activities.\"\"\"\n",
    "    return f\"search_{int(time.time() * 1000)}_{uuid.uuid4().hex[:9]}\"\n",
    "\n",
    "\n",
    "def extract_search_context(request) -> dict | None:\n",
    "    # Django uses request.META for headers (prefixed with HTTP_)\n",
    "    # FastAPI uses request.headers\n",
    "    search_context_header = None\n",
    "    \n",
    "    # Try Django-style header access\n",
    "    if hasattr(request, 'META'):\n",
    "        search_context_header = request.META.get('HTTP_X_SEARCH_CONTEXT')\n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: ria/services/company_service.py =====\n",
    "CONFIDENCE: 0.90\n",
    "REASONING: Adding 'from e' to raise statements to properly chain exceptions as required by B904\n",
    "\n",
    "```FIXED_CODE\n",
    "    try:\n",
    "        # Download trend data from S3\n",
    "        response = s3_client.get_object(Bucket=bucket, Key=s3_path)\n",
    "        content = response['Body'].read().decode('utf-8')\n",
    "        return json.loads(content)\n",
    "    except ClientError as e:\n",
    "        if e.response['Error']['Code'] == 'NoSuchKey':\n",
    "            raise ValueError(f\"Trend data not found for CRD {crd}\") from e\n",
    "        else:\n",
    "            raise RuntimeError(f\"Failed to load trend data: {str(e)}\") from e\n",
    "    except json.JSONDecodeError as e:\n",
    "        raise ValueError(f\"Invalid trend data format: {str(e)}\") from e\n",
    "\n",
    "\n",
    "def pdf_records_for_crd(crd: int) -> List[Dict[str, Any]]:\n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX ====="
  ]
}