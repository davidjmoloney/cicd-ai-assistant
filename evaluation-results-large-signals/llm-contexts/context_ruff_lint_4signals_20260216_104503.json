{
  "_debug_metadata": {
    "timestamp": "20260216_104503",
    "tool_id": "ruff",
    "signal_type": "lint",
    "num_signals": 4,
    "signal_files": [
      "ria/views.py",
      "ria/services/query_service.py"
    ],
    "system_prompt_length": 8600,
    "user_prompt_length": 25591
  },
  "context": {
    "group": {
      "tool_id": "ruff",
      "signal_type": "lint",
      "group_size": 4
    },
    "signals": [
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "medium",
          "rule_code": "UP045",
          "message": "Use `X | None` for type annotations",
          "docs_url": "https://docs.astral.sh/ruff/rules/non-pep604-annotation-optional",
          "file_path": "ria/services/query_service.py",
          "span": {
            "start": {
              "row": 88,
              "column": 18
            },
            "end": {
              "row": 88,
              "column": 36
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/services/query_service.py",
            "start_row": 58,
            "end_row": 118,
            "text": "                activity_type=activity_type,\n                search_id=search_id,\n                search_params=search_params,\n                search_timestamp=search_timestamp,\n                company_crd=company_crd,\n                company_name=company_name,\n                company_action=company_action,\n                ip_address=ip_address,\n            )\n            \n            logger.info(\n                f\"Stored RIA activity: {activity_type} for user {user_id}, activity_id: {activity.id}\",\n                extra={\"activity_id\": activity.id, \"user_id\": user_id, \"activity_type\": activity_type}\n            )\n            return activity.id\n            \n        except Exception as e:\n            logger.error(\n                f\"Failed to store RIA activity: {str(e)}\",\n                extra={\"user_id\": user_id, \"activity_type\": activity_type},\n                exc_info=True\n            )\n            raise\n\n    @staticmethod\n    async def get_ria_activity(\n        user_id: Optional[str] = None,\n        search_id: Optional[str] = None,\n        activity_type: Optional[str] = None,\n        from_date: Optional[datetime] = None,\n        to_date: Optional[datetime] = None,\n        limit: int = 50,\n        offset: int = 0\n    ) -> Dict[str, Any]:\n        try:\n            # Build query filters\n            filters = {}\n            \n            if user_id:\n                filters['user_id'] = user_id\n            if search_id:\n                filters['search_id'] = search_id\n            if activity_type:\n                filters['activity_type'] = activity_type\n            if from_date:\n                filters['created_at__gte'] = from_date\n            if to_date:\n                filters['created_at__lte'] = to_date\n            \n            # Get total count\n            total_count = await RIAUserActivity.objects.filter(**filters).acount()\n            \n            # Get paginated results\n            queryset = RIAUserActivity.objects.filter(**filters).order_by('search_id', 'created_at')\n            records = []\n            \n            async for activity in queryset[offset:offset + limit]:\n                records.append({\n                    \"id\": activity.id,\n                    \"user_id\": activity.user_id,\n                    \"session_id\": activity.session_id,\n"
          },
          "imports": {
            "file_path": "ria/services/query_service.py",
            "start_row": 1,
            "end_row": 16,
            "text": "\"\"\"\nQuery Service\n\nThis service handles all database operations for RIA using Django ORM.\nReplaces asyncpg database calls with Django ORM queries.\n\"\"\"\n\nfrom typing import Optional, Dict, Any, List\nfrom datetime import datetime\n\nfrom django.db import transaction\nfrom django.utils import timezone\n\nfrom ria.models import RIAUserActivity\nfrom common.utils.logging_config import get_logger\n\n"
          },
          "enclosing_function": {
            "file_path": "ria/services/query_service.py",
            "start_row": 81,
            "end_row": 148,
            "text": "\n    @staticmethod\n    async def get_ria_activity(\n        user_id: Optional[str] = None,\n        search_id: Optional[str] = None,\n        activity_type: Optional[str] = None,\n        from_date: Optional[datetime] = None,\n        to_date: Optional[datetime] = None,\n        limit: int = 50,\n        offset: int = 0\n    ) -> Dict[str, Any]:\n        try:\n            # Build query filters\n            filters = {}\n            \n            if user_id:\n                filters['user_id'] = user_id\n            if search_id:\n                filters['search_id'] = search_id\n            if activity_type:\n                filters['activity_type'] = activity_type\n            if from_date:\n                filters['created_at__gte'] = from_date\n            if to_date:\n                filters['created_at__lte'] = to_date\n            \n            # Get total count\n            total_count = await RIAUserActivity.objects.filter(**filters).acount()\n            \n            # Get paginated results\n            queryset = RIAUserActivity.objects.filter(**filters).order_by('search_id', 'created_at')\n            records = []\n            \n            async for activity in queryset[offset:offset + limit]:\n                records.append({\n                    \"id\": activity.id,\n                    \"user_id\": activity.user_id,\n                    \"session_id\": activity.session_id,\n                    \"activity_type\": activity.activity_type,\n                    \"search_id\": activity.search_id,\n                    \"search_params\": activity.search_params,\n                    \"search_timestamp\": activity.search_timestamp.isoformat() if activity.search_timestamp else None,\n                    \"company_crd\": activity.company_crd,\n                    \"company_name\": activity.company_name,\n                    \"company_action\": activity.company_action,\n                    \"ip_address\": activity.ip_address,\n                    \"created_at\": activity.created_at.isoformat() if activity.created_at else None,\n                })\n            \n            return {\n                \"records\": records,\n                \"total_count\": total_count,\n                \"limit\": limit,\n                \"offset\": offset\n            }\n            \n        except Exception as e:\n            logger.error(\n                f\"Failed to get RIA activity: {str(e)}\",\n                extra={\n                    \"user_id\": user_id,\n                    \"search_id\": search_id,\n                    \"activity_type\": activity_type\n                },\n                exc_info=True\n            )\n            raise\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/services/query_service.py",
          "start_row": 81,
          "end_row": 95,
          "text": "\n@staticmethod\nasync def get_ria_activity(\n    user_id: Optional[str] = None,\n    search_id: Optional[str] = None,\n    activity_type: Optional[str] = None,\n    from_date: Optional[datetime] = None,\n    to_date: Optional[datetime] = None,\n    limit: int = 50,\n    offset: int = 0\n) -> Dict[str, Any]:\n    try:\n        # Build query filters\n        filters = {}\n            \n",
          "original_text": "\n    @staticmethod\n    async def get_ria_activity(\n        user_id: Optional[str] = None,\n        search_id: Optional[str] = None,\n        activity_type: Optional[str] = None,\n        from_date: Optional[datetime] = None,\n        to_date: Optional[datetime] = None,\n        limit: int = 50,\n        offset: int = 0\n    ) -> Dict[str, Any]:\n        try:\n            # Build query filters\n            filters = {}\n            \n",
          "error_line": 88,
          "error_line_in_snippet": 8,
          "snippet_length": 15,
          "base_indent": "    "
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": true,
          "applicability": "safe",
          "tool_message": "Convert to `X | None`",
          "edits": [
            {
              "span": {
                "start": {
                  "row": 88,
                  "column": 18
                },
                "end": {
                  "row": 88,
                  "column": 36
                }
              },
              "content": "datetime | None"
            }
          ]
        }
      },
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "medium",
          "rule_code": "UP045",
          "message": "Use `X | None` for type annotations",
          "docs_url": "https://docs.astral.sh/ruff/rules/non-pep604-annotation-optional",
          "file_path": "ria/views.py",
          "span": {
            "start": {
              "row": 82,
              "column": 16
            },
            "end": {
              "row": 82,
              "column": 29
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/views.py",
            "start_row": 52,
            "end_row": 112,
            "text": ")\nfrom ria.utils.helpers import (\n    generate_search_id,\n    extract_search_context,\n    get_session_id_from_request,\n    format_search_params_for_storage,\n)\nfrom common.utils.config import get_s3_bucket, get_s3_prefix\nfrom common.utils.logging_config import get_logger\n\nlogger = get_logger(__name__)\n\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\ndef get_client_ip(request: Request) -> str:\n    \"\"\"Extract client IP address from request.\"\"\"\n    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')\n    if x_forwarded_for:\n        ip = x_forwarded_for.split(',')[0]\n    else:\n        ip = request.META.get('REMOTE_ADDR', 'unknown')\n    return ip\n\n\nasync def track_ria_activity(\n    request: Request,\n    activity_type: str,\n    search_id: Optional[str] = None,\n    search_params: Optional[Dict[str, Any]] = None,\n    search_timestamp: Optional[datetime] = None,\n    company_crd: Optional[str] = None,\n    company_name: Optional[str] = None,\n    company_action: Optional[str] = None,\n) -> None:\n    \"\"\"Track RIA activity in the database.\"\"\"\n    try:\n        user_id = str(request.user.user_id) if hasattr(request.user, 'user_id') else None\n        if not user_id:\n            logger.warning(\"No user_id available for activity tracking\")\n            return\n        \n        # Extract search context from headers if not provided\n        if not search_id or not search_params:\n            search_context = extract_search_context(request)\n            if search_context:\n                search_id = search_id or search_context.get(\"searchId\")\n                if not search_params:\n                    search_params = search_context.get(\"searchParams\")\n                if not search_timestamp:\n                    ts = search_context.get(\"timestamp\")\n                    if ts:\n                        if isinstance(ts, str):\n                            try:\n                                if ts.endswith('Z'):\n                                    ts = ts[:-1]\n                                search_timestamp = datetime.fromisoformat(ts)\n                            except ValueError:\n                                pass\n"
          },
          "imports": {
            "file_path": "ria/views.py",
            "start_row": 1,
            "end_row": 26,
            "text": "\"\"\"\nDjango REST Framework views for RIA API.\n\nConverted from FastAPI routes in prospecting_api.py.\nAll views use class-based approach with Django async support.\n\"\"\"\n\nimport json\nimport io\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nimport boto3\nimport polars as pl\nfrom botocore.exceptions import ClientError\nfrom django.http import StreamingHttpResponse, FileResponse\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom authentication.permissions import IsAdmin\nfrom rest_framework.exceptions import NotFound, PermissionDenied, ValidationError, APIException\nfrom rest_framework.request import Request\nfrom common.views import AsyncAPIView\n\nfrom ria.serializers import (\n"
          },
          "enclosing_function": {
            "file_path": "ria/views.py",
            "start_row": 77,
            "end_row": 144,
            "text": "\n\nasync def track_ria_activity(\n    request: Request,\n    activity_type: str,\n    search_id: Optional[str] = None,\n    search_params: Optional[Dict[str, Any]] = None,\n    search_timestamp: Optional[datetime] = None,\n    company_crd: Optional[str] = None,\n    company_name: Optional[str] = None,\n    company_action: Optional[str] = None,\n) -> None:\n    \"\"\"Track RIA activity in the database.\"\"\"\n    try:\n        user_id = str(request.user.user_id) if hasattr(request.user, 'user_id') else None\n        if not user_id:\n            logger.warning(\"No user_id available for activity tracking\")\n            return\n        \n        # Extract search context from headers if not provided\n        if not search_id or not search_params:\n            search_context = extract_search_context(request)\n            if search_context:\n                search_id = search_id or search_context.get(\"searchId\")\n                if not search_params:\n                    search_params = search_context.get(\"searchParams\")\n                if not search_timestamp:\n                    ts = search_context.get(\"timestamp\")\n                    if ts:\n                        if isinstance(ts, str):\n                            try:\n                                if ts.endswith('Z'):\n                                    ts = ts[:-1]\n                                search_timestamp = datetime.fromisoformat(ts)\n                            except ValueError:\n                                pass\n                        elif isinstance(ts, datetime):\n                            search_timestamp = ts.replace(tzinfo=None) if ts.tzinfo else ts\n        \n        session_id = get_session_id_from_request(request)\n        ip_address = get_client_ip(request)\n        \n        await QueryService.store_ria_activity(\n            user_id=user_id,\n            session_id=session_id,\n            activity_type=activity_type,\n            search_id=search_id,\n            search_params=search_params,\n            search_timestamp=search_timestamp,\n            company_crd=company_crd,\n            company_name=company_name,\n            company_action=company_action,\n            ip_address=ip_address,\n        )\n        \n        logger.info(\n            f\"Tracked RIA activity: {activity_type}\",\n            extra={\"user_id\": user_id, \"activity_type\": activity_type, \"company_crd\": company_crd}\n        )\n    except Exception as e:\n        logger.error(f\"Failed to track RIA activity: {str(e)}\", exc_info=True)\n        # Don't fail the request if tracking fails\n\n\n# ============================================================================\n# Authenticated RIA Endpoints (JWT Required)\n# ============================================================================\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/views.py",
          "start_row": 75,
          "end_row": 89,
          "text": "        ip = request.META.get('REMOTE_ADDR', 'unknown')\n    return ip\n\n\nasync def track_ria_activity(\n    request: Request,\n    activity_type: str,\n    search_id: Optional[str] = None,\n    search_params: Optional[Dict[str, Any]] = None,\n    search_timestamp: Optional[datetime] = None,\n    company_crd: Optional[str] = None,\n    company_name: Optional[str] = None,\n    company_action: Optional[str] = None,\n) -> None:\n    \"\"\"Track RIA activity in the database.\"\"\"\n",
          "original_text": "        ip = request.META.get('REMOTE_ADDR', 'unknown')\n    return ip\n\n\nasync def track_ria_activity(\n    request: Request,\n    activity_type: str,\n    search_id: Optional[str] = None,\n    search_params: Optional[Dict[str, Any]] = None,\n    search_timestamp: Optional[datetime] = None,\n    company_crd: Optional[str] = None,\n    company_name: Optional[str] = None,\n    company_action: Optional[str] = None,\n) -> None:\n    \"\"\"Track RIA activity in the database.\"\"\"\n",
          "error_line": 82,
          "error_line_in_snippet": 8,
          "snippet_length": 15,
          "base_indent": ""
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": true,
          "applicability": "safe",
          "tool_message": "Convert to `X | None`",
          "edits": [
            {
              "span": {
                "start": {
                  "row": 82,
                  "column": 16
                },
                "end": {
                  "row": 82,
                  "column": 29
                }
              },
              "content": "str | None"
            }
          ]
        }
      },
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "medium",
          "rule_code": "B904",
          "message": "Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling",
          "docs_url": "https://docs.astral.sh/ruff/rules/raise-without-from-inside-except",
          "file_path": "ria/views.py",
          "span": {
            "start": {
              "row": 167,
              "column": 13
            },
            "end": {
              "row": 167,
              "column": 78
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/views.py",
            "start_row": 137,
            "end_row": 197,
            "text": "        logger.error(f\"Failed to track RIA activity: {str(e)}\", exc_info=True)\n        # Don't fail the request if tracking fails\n\n\n# ============================================================================\n# Authenticated RIA Endpoints (JWT Required)\n# ============================================================================\n\nclass RIAIndexView(AsyncAPIView):\n    \"\"\"GET /ria/index - Return up to 100 advisors from cached index with optional filters.\"\"\"\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for RIA index.\"\"\"\n        serializer = RIAIndexSearchSerializer(data=request.query_params)\n        serializer.is_valid(raise_exception=True)\n        \n        state = serializer.validated_data.get('state')\n        name = serializer.validated_data.get('name')\n        min_5f_2c = serializer.validated_data.get('min_5f_2c')\n        limit = serializer.validated_data.get('limit', 100)\n        \n        logger.info(f\"RIA index request: state={state}, name={name}, min_5f_2c={min_5f_2c}, limit={limit}\")\n        \n        try:\n            index_cache = get_index_cache()\n            df = index_cache.load()\n            logger.info(f\"Loaded index data: {df.height} rows, {len(df.columns)} columns\")\n        except Exception as e:\n            logger.error(f\"Failed to load index data: {str(e)}\", exc_info=True)\n            raise APIException(detail=f\"Failed to load index data: {str(e)}\")\n        \n        ensure_columns(df, [CRD_COLUMN, NAME_COLUMN, STATE_COLUMN, DOMAIN_COLUMN])\n        filtered = df\n        \n        if state:\n            filtered = filtered.filter(pl.col(STATE_COLUMN).str.to_uppercase() == state.upper())\n        if name:\n            filtered = filtered.filter(pl.col(NAME_COLUMN).str.to_lowercase() == name.lower())\n        if min_5f_2c is not None:\n            if AUM_COLUMN not in df.columns:\n                raise APIException(detail=\"RIA index missing 5F(2)(c) column\")\n            filtered = filtered.filter(\n                pl.col(AUM_COLUMN)\n                .cast(pl.Float64, strict=False)\n                .fill_null(-1.0)\n                >= float(min_5f_2c)\n            )\n        \n        filtered = filtered.sort(NAME_COLUMN)\n        total_matches = filtered.height\n        rows = to_serializable_records(filtered, limit)\n        \n        # Track activity\n        await track_ria_activity(\n            request=request,\n            activity_type='search',\n            search_params=format_search_params_for_storage(serializer.validated_data),\n        )\n        \n        response_data = {\n"
          },
          "imports": {
            "file_path": "ria/views.py",
            "start_row": 1,
            "end_row": 26,
            "text": "\"\"\"\nDjango REST Framework views for RIA API.\n\nConverted from FastAPI routes in prospecting_api.py.\nAll views use class-based approach with Django async support.\n\"\"\"\n\nimport json\nimport io\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nimport boto3\nimport polars as pl\nfrom botocore.exceptions import ClientError\nfrom django.http import StreamingHttpResponse, FileResponse\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom authentication.permissions import IsAdmin\nfrom rest_framework.exceptions import NotFound, PermissionDenied, ValidationError, APIException\nfrom rest_framework.request import Request\nfrom common.views import AsyncAPIView\n\nfrom ria.serializers import (\n"
          },
          "enclosing_function": {
            "file_path": "ria/views.py",
            "start_row": 148,
            "end_row": 206,
            "text": "    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for RIA index.\"\"\"\n        serializer = RIAIndexSearchSerializer(data=request.query_params)\n        serializer.is_valid(raise_exception=True)\n        \n        state = serializer.validated_data.get('state')\n        name = serializer.validated_data.get('name')\n        min_5f_2c = serializer.validated_data.get('min_5f_2c')\n        limit = serializer.validated_data.get('limit', 100)\n        \n        logger.info(f\"RIA index request: state={state}, name={name}, min_5f_2c={min_5f_2c}, limit={limit}\")\n        \n        try:\n            index_cache = get_index_cache()\n            df = index_cache.load()\n            logger.info(f\"Loaded index data: {df.height} rows, {len(df.columns)} columns\")\n        except Exception as e:\n            logger.error(f\"Failed to load index data: {str(e)}\", exc_info=True)\n            raise APIException(detail=f\"Failed to load index data: {str(e)}\")\n        \n        ensure_columns(df, [CRD_COLUMN, NAME_COLUMN, STATE_COLUMN, DOMAIN_COLUMN])\n        filtered = df\n        \n        if state:\n            filtered = filtered.filter(pl.col(STATE_COLUMN).str.to_uppercase() == state.upper())\n        if name:\n            filtered = filtered.filter(pl.col(NAME_COLUMN).str.to_lowercase() == name.lower())\n        if min_5f_2c is not None:\n            if AUM_COLUMN not in df.columns:\n                raise APIException(detail=\"RIA index missing 5F(2)(c) column\")\n            filtered = filtered.filter(\n                pl.col(AUM_COLUMN)\n                .cast(pl.Float64, strict=False)\n                .fill_null(-1.0)\n                >= float(min_5f_2c)\n            )\n        \n        filtered = filtered.sort(NAME_COLUMN)\n        total_matches = filtered.height\n        rows = to_serializable_records(filtered, limit)\n        \n        # Track activity\n        await track_ria_activity(\n            request=request,\n            activity_type='search',\n            search_params=format_search_params_for_storage(serializer.validated_data),\n        )\n        \n        response_data = {\n            \"total_matches\": total_matches,\n            \"rows\": rows\n        }\n        response_serializer = RIAIndexResponseSerializer(data=response_data)\n        response_serializer.is_valid()\n        \n        return Response(response_serializer.data, status=status.HTTP_200_OK)\n\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/views.py",
          "start_row": 160,
          "end_row": 174,
          "text": "        \ntry:\n    index_cache = get_index_cache()\n    df = index_cache.load()\n    logger.info(f\"Loaded index data: {df.height} rows, {len(df.columns)} columns\")\nexcept Exception as e:\n    logger.error(f\"Failed to load index data: {str(e)}\", exc_info=True)\n    raise APIException(detail=f\"Failed to load index data: {str(e)}\")\n        \nensure_columns(df, [CRD_COLUMN, NAME_COLUMN, STATE_COLUMN, DOMAIN_COLUMN])\nfiltered = df\n        \nif state:\n    filtered = filtered.filter(pl.col(STATE_COLUMN).str.to_uppercase() == state.upper())\nif name:\n",
          "original_text": "        \n        try:\n            index_cache = get_index_cache()\n            df = index_cache.load()\n            logger.info(f\"Loaded index data: {df.height} rows, {len(df.columns)} columns\")\n        except Exception as e:\n            logger.error(f\"Failed to load index data: {str(e)}\", exc_info=True)\n            raise APIException(detail=f\"Failed to load index data: {str(e)}\")\n        \n        ensure_columns(df, [CRD_COLUMN, NAME_COLUMN, STATE_COLUMN, DOMAIN_COLUMN])\n        filtered = df\n        \n        if state:\n            filtered = filtered.filter(pl.col(STATE_COLUMN).str.to_uppercase() == state.upper())\n        if name:\n",
          "error_line": 167,
          "error_line_in_snippet": 8,
          "snippet_length": 15,
          "base_indent": "        "
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": false
        }
      },
      {
        "signal": {
          "tool_id": "ruff",
          "signal_type": "lint",
          "severity": "medium",
          "rule_code": "B904",
          "message": "Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling",
          "docs_url": "https://docs.astral.sh/ruff/rules/raise-without-from-inside-except",
          "file_path": "ria/views.py",
          "span": {
            "start": {
              "row": 472,
              "column": 13
            },
            "end": {
              "row": 472,
              "column": 63
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/views.py",
            "start_row": 442,
            "end_row": 502,
            "text": "        \"\"\"Handle GET request for countries.\"\"\"\n        logger.info(\"RIA countries metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['countries'])} distinct countries\")\n            \n            return Response({\"countries\": location_data[\"countries\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get countries: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load countries\")\n\n\nclass RIACitiesView(AsyncAPIView):\n    \"\"\"GET /ria/metadata/cities - Get all distinct cities for dropdown.\"\"\"\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for cities.\"\"\"\n        logger.info(\"RIA cities metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['cities'])} distinct cities\")\n            \n            return Response({\"cities\": location_data[\"cities\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get cities: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load cities\")\n\n\nclass RIALocationMetadataView(AsyncAPIView):\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for location metadata.\"\"\"\n        logger.info(\"RIA location metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['countries'])} countries and {len(location_data['cities'])} cities\")\n            \n            serializer = RIALocationMetadataSerializer(data=location_data)\n            serializer.is_valid()\n            \n            return Response(serializer.data, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get location metadata: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load location metadata\")\n\n\n# ============================================================================\n# Debug Endpoint\n# ============================================================================\n\nclass RIADebugS3View(AsyncAPIView):\n    \"\"\"GET /ria/debug/s3 - Debug endpoint to test S3 access and configuration.\"\"\"\n    permission_classes = [IsAuthenticated]  # TODO: Add admin check\n"
          },
          "imports": {
            "file_path": "ria/views.py",
            "start_row": 1,
            "end_row": 26,
            "text": "\"\"\"\nDjango REST Framework views for RIA API.\n\nConverted from FastAPI routes in prospecting_api.py.\nAll views use class-based approach with Django async support.\n\"\"\"\n\nimport json\nimport io\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nimport boto3\nimport polars as pl\nfrom botocore.exceptions import ClientError\nfrom django.http import StreamingHttpResponse, FileResponse\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom authentication.permissions import IsAdmin\nfrom rest_framework.exceptions import NotFound, PermissionDenied, ValidationError, APIException\nfrom rest_framework.request import Request\nfrom common.views import AsyncAPIView\n\nfrom ria.serializers import (\n"
          },
          "enclosing_function": {
            "file_path": "ria/views.py",
            "start_row": 459,
            "end_row": 474,
            "text": "    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for cities.\"\"\"\n        logger.info(\"RIA cities metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['cities'])} distinct cities\")\n            \n            return Response({\"cities\": location_data[\"cities\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get cities: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load cities\")\n\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/views.py",
          "start_row": 465,
          "end_row": 479,
          "text": "            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['cities'])} distinct cities\")\n            \n            return Response({\"cities\": location_data[\"cities\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get cities: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load cities\")\n\n\nclass RIALocationMetadataView(AsyncAPIView):\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for location metadata.\"\"\"\n",
          "original_text": "            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['cities'])} distinct cities\")\n            \n            return Response({\"cities\": location_data[\"cities\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get cities: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load cities\")\n\n\nclass RIALocationMetadataView(AsyncAPIView):\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for location metadata.\"\"\"\n",
          "error_line": 472,
          "error_line_in_snippet": 8,
          "snippet_length": 15,
          "base_indent": ""
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": false
        }
      }
    ],
    "merged_snippet_groups": [],
    "standalone_signal_indices": [
      0,
      1,
      2,
      3
    ]
  },
  "prompts": {
    "system_prompt": "You are an expert code repair agent. Your task is to make MINIMAL, SURGICAL fixes to code errors.\n\n## CRITICAL PRINCIPLE: MINIMAL CHANGES ONLY\n\nYour job is to fix ONLY the specific error mentioned. You are NOT improving, refactoring, or cleaning up code.\n\n**THE GOLDEN RULE**: Every line in your output that is NOT directly part of the fix MUST be IDENTICAL to the input - same content, same whitespace, same everything.\n\n## How This Works\n\nFor each error signal, you will receive:\n\n1. **Error Information**: Type, message, severity, and rule code\n2. **Edit Snippet**: A small code snippet (~13 lines) containing the error\n   - This is what you need to FIX and RETURN\n   - The error location within the snippet is indicated (e.g., \"Error on line 4 of 13\")\n3. **Context Window**: A larger code window (~30 lines) around the error for understanding\n   - Use this to understand the surrounding code, but DON'T return it\n\n4. **Tailored Context** (varies by signal type - optimized to reduce token usage):\n   - **Imports**: The file's import block (for type definitions, dependencies)\n     - Included for: type errors, undefined names, most issues\n     - Excluded for: import-only errors, bare except blocks\n   - **Enclosing Function**: The function containing the error (for understanding scope/logic)\n     - Included for: type errors, docstring errors, function-level issues\n     - Excluded for: import errors (global scope), bare except (sent separately)\n   - **Try/Except Block**: The try/except block containing the error\n     - Included for: bare except errors (E722)\n     - Excluded for: most other errors\n\nNote: Context is carefully selected to provide what you need while minimizing token usage.\nNot all context is present for every error - you'll only receive relevant context.\n\n## Response Format\n\nFor EACH signal/snippet you receive, respond with this EXACT format:\n\n```\n===== FIX FOR: <file_path> =====\nCONFIDENCE: <0.0-1.0>\nREASONING: <brief explanation of the fix>\n\n```FIXED_CODE\n<complete fixed snippet - ALL lines from edit_snippet, with ONLY the fix applied>\n```\n\nWARNINGS: <any caveats, or \"None\">\n===== END FIX =====\n```\n\n## CRITICAL Rules - READ CAREFULLY\n\n1. **MINIMAL CHANGES ONLY** - Change ONLY what is necessary to fix the specific error. Nothing more.\n\n2. **PRESERVE EVERYTHING ELSE EXACTLY** - Every line that is NOT part of the fix must be returned EXACTLY as it appeared in the input, character-for-character, including:\n   - Comments and documentation\n   - Blank lines (including leading and trailing blank lines)\n   - All whitespace (including trailing newlines at the end of the snippet)\n   - Other variable declarations\n   - Function definitions\n   - String content (including multi-line strings)\n\n   **CRITICAL**: If the input snippet ends with blank lines or newlines, your output MUST end with the exact same number of blank lines/newlines. Do NOT trim trailing whitespace.\n\n3. **DO NOT under any circumstances**:\n   - Delete lines that aren't related to the fix\n   - Add code that isn't required for the fix\n   - \"Clean up\" or \"improve\" surrounding code\n   - Modify comments or documentation\n   - Change formatting on unrelated lines\n   - Remove blank lines\n   - Add blank lines (unless the fix specifically requires it)\n   - Modify string literals or docstrings\n   - Delete function definitions\n   - Remove dictionary entries or list items unrelated to the fix\n\n4. **Maintain RELATIVE indentation** - The snippet has had its base indentation removed. Preserve relative indentation exactly. If a line has 4 spaces in the input, it must have 4 spaces in your output.\n\n5. **One fix block per signal** - If multiple signals, provide multiple fix blocks\n\n6. **Use context for understanding only** - The context window, imports, and enclosing function help you understand the code, but you only return the fixed edit_snippet\n\n## Example - Correct Minimal Fix\n\nInput:\n- Error: \"Need type annotation for 'cache'\" on line 173\n- Edit Snippet (error on line 4 of 7, lines 170-176):\n```\n}\n\nDEPRIORITIZE_QUERIES = {}\ncache = {}\n\n# Model configuration\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n(Note: The snippet ends with a newline after the last line - this MUST be preserved)\n\nCORRECT Response (only `cache = {}` changed to `cache: dict = {}`):\n```\n===== FIX FOR: app/config/tier_queries.py =====\nCONFIDENCE: 0.95\nREASONING: Added dict type annotation to cache variable to satisfy mypy\n\n```FIXED_CODE\n}\n\nDEPRIORITIZE_QUERIES = {}\ncache: dict = {}\n\n# Model configuration\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n\nWARNINGS: None\n===== END FIX =====\n```\n(Note: The output preserves the exact same trailing newline as the input)\n\n## Example - Preserving Trailing Whitespace\n\nInput snippet ending with blank lines (note the TWO newlines after the return statement):\n```\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n\n\n```\n\nCORRECT - Preserves both trailing newlines:\n```FIXED_CODE\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n\n\n```\n(Output MUST have the same TWO trailing newlines)\n\nWRONG - Trimming trailing newlines:\n```FIXED_CODE\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n```\n^ This is WRONG because it removed trailing newlines. The snippet MUST end with the same whitespace as the input.\n\n## Example - WRONG (Deleting Unrelated Content)\n\nIf the input snippet contains documentation or other code, you MUST preserve it:\n\nWRONG - Deleting unrelated lines:\n```FIXED_CODE\ncache: dict = {}\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n^ This is WRONG because it deleted the closing brace, blank lines, DEPRIORITIZE_QUERIES, and the comment.\n\n## Confidence Guidelines\n- High (>0.8): Simple fixes like type annotations, obvious corrections\n- Medium (0.5-0.8): Logic changes, type guards, refactoring\n- Low (<0.5): Complex changes, unclear intent - add detailed warnings\n\n\n\n## Ruff Lint Error Fixing - Specialized Guidance\n\nYou are fixing LINTING errors from Ruff. These are code quality, style, and\nbest practice issues - NOT security or type correctness.\n\nRisk Level: LOW to MEDIUM\nThese fixes should improve code quality without changing behavior.\n\nCommon Ruff Rule Categories:\n\nF (Pyflakes):\n- Unused imports/variables\n- Undefined names\n- Duplicate arguments\n- Invalid format strings\n\nE/W (pycodestyle):\n- Line length (E501)\n- Whitespace issues (E203, W291)\n- Indentation (E111, E114)\n- Blank lines (E302, E303)\n\nC (McCabe):\n- Complexity warnings (C901)\n- Too many branches/statements\n\nN (pep8-naming):\n- Naming conventions (N801-N818)\n- Lowercase function names\n- CamelCase class names\n\nI (isort):\n- Import sorting/organization\n\nUP (pyupgrade):\n- Outdated syntax\n- Type hint modernization\n\nFixing Strategies:\n\n1. **Remove Unused Code** - But verify it's truly unused\n   \u2705 Remove unused imports\n   \u2705 Remove unused variables\n   \u26a0\ufe0f Check for side effects first!\n\n2. **Simplify Logic** - Follow Python idioms\n   \u2705 `if x == True:` \u2192 `if x:`\n   \u2705 `if len(list) > 0:` \u2192 `if list:`\n   \u2705 Use comprehensions instead of loops\n\n3. **Fix Naming** - Follow PEP 8\n   \u2705 `MyFunction` \u2192 `my_function`\n   \u2705 `my_class` \u2192 `MyClass`\n\n4. **Modernize Syntax** - Use newer Python features\n   \u2705 `Union[str, int]` \u2192 `str | int` (Python 3.10+)\n   \u2705 `Optional[str]` \u2192 `str | None` (Python 3.10+)\n\n5. **Organize Imports** - Sort and group properly\n   \u2705 Standard library first\n   \u2705 Third-party second\n   \u2705 Local imports last\n\nNEVER do these:\n\u274c Remove code that has side effects (initializers, registrations)\n\u274c Change behavior to fix style\n\u274c Break working code to satisfy complexity metrics\n\u274c Remove \"unused\" variables that are part of unpacking\n\nSpecial Cases:\n\nComplexity Warnings (C901):\n- Don't just suppress with # noqa\n- Consider refactoring if genuinely complex\n- But set confidence < 0.7 for refactoring suggestions\n\nUnused Variables:\n- `x, y, z = tuple` - y might be \"unused\" but needed for unpacking\n- Consider renaming to `_` if truly unused: `x, _, z = tuple`\n\nLine Length (E501):\n- Can often be fixed by breaking long lines\n- But some URLs or strings are legitimately long\n- Use # noqa: E501 with comment explaining why\n\nConfidence Guidelines:\n- High (>0.8): Remove unused imports, fix obvious naming\n- Medium (0.5-0.8): Simplify logic, organize imports\n- Low (<0.5): Refactoring suggestions, complex changes\n\nRemember: Preserve behavior. These are style improvements, not bug fixes.\n",
    "user_prompt": "Tool: ruff\nSignal Type: lint\nNumber of Signals: 4\n\n============================================================\nSIGNAL 1\n============================================================\n\n## Error Information\n- File: ria/services/query_service.py\n- Message: Use `X | None` for type annotations\n- Rule Code: UP045\n- Severity: medium\n- Location: Line 88, Column 18\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 81-95 (error on line 8 of 15)\n```python\n\n@staticmethod\nasync def get_ria_activity(\n    user_id: Optional[str] = None,\n    search_id: Optional[str] = None,\n    activity_type: Optional[str] = None,\n    from_date: Optional[datetime] = None,\n    to_date: Optional[datetime] = None,\n    limit: int = 50,\n    offset: int = 0\n) -> Dict[str, Any]:\n    try:\n        # Build query filters\n        filters = {}\n            \n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 58-118\n```python\n                activity_type=activity_type,\n                search_id=search_id,\n                search_params=search_params,\n                search_timestamp=search_timestamp,\n                company_crd=company_crd,\n                company_name=company_name,\n                company_action=company_action,\n                ip_address=ip_address,\n            )\n            \n            logger.info(\n                f\"Stored RIA activity: {activity_type} for user {user_id}, activity_id: {activity.id}\",\n                extra={\"activity_id\": activity.id, \"user_id\": user_id, \"activity_type\": activity_type}\n            )\n            return activity.id\n            \n        except Exception as e:\n            logger.error(\n                f\"Failed to store RIA activity: {str(e)}\",\n                extra={\"user_id\": user_id, \"activity_type\": activity_type},\n                exc_info=True\n            )\n            raise\n\n    @staticmethod\n    async def get_ria_activity(\n        user_id: Optional[str] = None,\n        search_id: Optional[str] = None,\n        activity_type: Optional[str] = None,\n        from_date: Optional[datetime] = None,\n        to_date: Optional[datetime] = None,\n        limit: int = 50,\n        offset: int = 0\n    ) -> Dict[str, Any]:\n        try:\n            # Build query filters\n            filters = {}\n            \n            if user_id:\n                filters['user_id'] = user_id\n            if search_id:\n                filters['search_id'] = search_id\n            if activity_type:\n                filters['activity_type'] = activity_type\n            if from_date:\n                filters['created_at__gte'] = from_date\n            if to_date:\n                filters['created_at__lte'] = to_date\n            \n            # Get total count\n            total_count = await RIAUserActivity.objects.filter(**filters).acount()\n            \n            # Get paginated results\n            queryset = RIAUserActivity.objects.filter(**filters).order_by('search_id', 'created_at')\n            records = []\n            \n            async for activity in queryset[offset:offset + limit]:\n                records.append({\n                    \"id\": activity.id,\n                    \"user_id\": activity.user_id,\n                    \"session_id\": activity.session_id,\n\n```\n\n## Imports\n```python\n\"\"\"\nQuery Service\n\nThis service handles all database operations for RIA using Django ORM.\nReplaces asyncpg database calls with Django ORM queries.\n\"\"\"\n\nfrom typing import Optional, Dict, Any, List\nfrom datetime import datetime\n\nfrom django.db import transaction\nfrom django.utils import timezone\n\nfrom ria.models import RIAUserActivity\nfrom common.utils.logging_config import get_logger\n\n\n```\n\n## Enclosing Function\nLines 81-148\n```python\n\n    @staticmethod\n    async def get_ria_activity(\n        user_id: Optional[str] = None,\n        search_id: Optional[str] = None,\n        activity_type: Optional[str] = None,\n        from_date: Optional[datetime] = None,\n        to_date: Optional[datetime] = None,\n        limit: int = 50,\n        offset: int = 0\n    ) -> Dict[str, Any]:\n        try:\n            # Build query filters\n            filters = {}\n            \n            if user_id:\n                filters['user_id'] = user_id\n            if search_id:\n                filters['search_id'] = search_id\n            if activity_type:\n                filters['activity_type'] = activity_type\n            if from_date:\n                filters['created_at__gte'] = from_date\n            if to_date:\n                filters['created_at__lte'] = to_date\n            \n            # Get total count\n            total_count = await RIAUserActivity.objects.filter(**filters).acount()\n            \n            # Get paginated results\n            queryset = RIAUserActivity.objects.filter(**filters).order_by('search_id', 'created_at')\n            records = []\n            \n            async for activity in queryset[offset:offset + limit]:\n                records.append({\n                    \"id\": activity.id,\n                    \"user_id\": activity.user_id,\n                    \"session_id\": activity.session_id,\n                    \"activity_type\": activity.activity_type,\n                    \"search_id\": activity.search_id,\n                    \"search_params\": activity.search_params,\n                    \"search_timestamp\": activity.search_timestamp.isoformat() if activity.search_timestamp else None,\n                    \"company_crd\": activity.company_crd,\n                    \"company_name\": activity.company_name,\n                    \"company_action\": activity.company_action,\n                    \"ip_address\": activity.ip_address,\n                    \"created_at\": activity.created_at.isoformat() if activity.created_at else None,\n                })\n            \n            return {\n                \"records\": records,\n                \"total_count\": total_count,\n                \"limit\": limit,\n                \"offset\": offset\n            }\n            \n        except Exception as e:\n            logger.error(\n                f\"Failed to get RIA activity: {str(e)}\",\n                extra={\n                    \"user_id\": user_id,\n                    \"search_id\": search_id,\n                    \"activity_type\": activity_type\n                },\n                exc_info=True\n            )\n            raise\n\n\n```\n\n\n============================================================\nSIGNAL 2\n============================================================\n\n## Error Information\n- File: ria/views.py\n- Message: Use `X | None` for type annotations\n- Rule Code: UP045\n- Severity: medium\n- Location: Line 82, Column 16\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 75-89 (error on line 8 of 15)\n```python\n        ip = request.META.get('REMOTE_ADDR', 'unknown')\n    return ip\n\n\nasync def track_ria_activity(\n    request: Request,\n    activity_type: str,\n    search_id: Optional[str] = None,\n    search_params: Optional[Dict[str, Any]] = None,\n    search_timestamp: Optional[datetime] = None,\n    company_crd: Optional[str] = None,\n    company_name: Optional[str] = None,\n    company_action: Optional[str] = None,\n) -> None:\n    \"\"\"Track RIA activity in the database.\"\"\"\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 52-112\n```python\n)\nfrom ria.utils.helpers import (\n    generate_search_id,\n    extract_search_context,\n    get_session_id_from_request,\n    format_search_params_for_storage,\n)\nfrom common.utils.config import get_s3_bucket, get_s3_prefix\nfrom common.utils.logging_config import get_logger\n\nlogger = get_logger(__name__)\n\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\ndef get_client_ip(request: Request) -> str:\n    \"\"\"Extract client IP address from request.\"\"\"\n    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')\n    if x_forwarded_for:\n        ip = x_forwarded_for.split(',')[0]\n    else:\n        ip = request.META.get('REMOTE_ADDR', 'unknown')\n    return ip\n\n\nasync def track_ria_activity(\n    request: Request,\n    activity_type: str,\n    search_id: Optional[str] = None,\n    search_params: Optional[Dict[str, Any]] = None,\n    search_timestamp: Optional[datetime] = None,\n    company_crd: Optional[str] = None,\n    company_name: Optional[str] = None,\n    company_action: Optional[str] = None,\n) -> None:\n    \"\"\"Track RIA activity in the database.\"\"\"\n    try:\n        user_id = str(request.user.user_id) if hasattr(request.user, 'user_id') else None\n        if not user_id:\n            logger.warning(\"No user_id available for activity tracking\")\n            return\n        \n        # Extract search context from headers if not provided\n        if not search_id or not search_params:\n            search_context = extract_search_context(request)\n            if search_context:\n                search_id = search_id or search_context.get(\"searchId\")\n                if not search_params:\n                    search_params = search_context.get(\"searchParams\")\n                if not search_timestamp:\n                    ts = search_context.get(\"timestamp\")\n                    if ts:\n                        if isinstance(ts, str):\n                            try:\n                                if ts.endswith('Z'):\n                                    ts = ts[:-1]\n                                search_timestamp = datetime.fromisoformat(ts)\n                            except ValueError:\n                                pass\n\n```\n\n## Imports\n```python\n\"\"\"\nDjango REST Framework views for RIA API.\n\nConverted from FastAPI routes in prospecting_api.py.\nAll views use class-based approach with Django async support.\n\"\"\"\n\nimport json\nimport io\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nimport boto3\nimport polars as pl\nfrom botocore.exceptions import ClientError\nfrom django.http import StreamingHttpResponse, FileResponse\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom authentication.permissions import IsAdmin\nfrom rest_framework.exceptions import NotFound, PermissionDenied, ValidationError, APIException\nfrom rest_framework.request import Request\nfrom common.views import AsyncAPIView\n\nfrom ria.serializers import (\n\n```\n\n## Enclosing Function\nLines 77-144\n```python\n\n\nasync def track_ria_activity(\n    request: Request,\n    activity_type: str,\n    search_id: Optional[str] = None,\n    search_params: Optional[Dict[str, Any]] = None,\n    search_timestamp: Optional[datetime] = None,\n    company_crd: Optional[str] = None,\n    company_name: Optional[str] = None,\n    company_action: Optional[str] = None,\n) -> None:\n    \"\"\"Track RIA activity in the database.\"\"\"\n    try:\n        user_id = str(request.user.user_id) if hasattr(request.user, 'user_id') else None\n        if not user_id:\n            logger.warning(\"No user_id available for activity tracking\")\n            return\n        \n        # Extract search context from headers if not provided\n        if not search_id or not search_params:\n            search_context = extract_search_context(request)\n            if search_context:\n                search_id = search_id or search_context.get(\"searchId\")\n                if not search_params:\n                    search_params = search_context.get(\"searchParams\")\n                if not search_timestamp:\n                    ts = search_context.get(\"timestamp\")\n                    if ts:\n                        if isinstance(ts, str):\n                            try:\n                                if ts.endswith('Z'):\n                                    ts = ts[:-1]\n                                search_timestamp = datetime.fromisoformat(ts)\n                            except ValueError:\n                                pass\n                        elif isinstance(ts, datetime):\n                            search_timestamp = ts.replace(tzinfo=None) if ts.tzinfo else ts\n        \n        session_id = get_session_id_from_request(request)\n        ip_address = get_client_ip(request)\n        \n        await QueryService.store_ria_activity(\n            user_id=user_id,\n            session_id=session_id,\n            activity_type=activity_type,\n            search_id=search_id,\n            search_params=search_params,\n            search_timestamp=search_timestamp,\n            company_crd=company_crd,\n            company_name=company_name,\n            company_action=company_action,\n            ip_address=ip_address,\n        )\n        \n        logger.info(\n            f\"Tracked RIA activity: {activity_type}\",\n            extra={\"user_id\": user_id, \"activity_type\": activity_type, \"company_crd\": company_crd}\n        )\n    except Exception as e:\n        logger.error(f\"Failed to track RIA activity: {str(e)}\", exc_info=True)\n        # Don't fail the request if tracking fails\n\n\n# ============================================================================\n# Authenticated RIA Endpoints (JWT Required)\n# ============================================================================\n\n\n```\n\n\n============================================================\nSIGNAL 3\n============================================================\n\n## Error Information\n- File: ria/views.py\n- Message: Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling\n- Rule Code: B904\n- Severity: medium\n- Location: Line 167, Column 13\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 160-174 (error on line 8 of 15)\n```python\n        \ntry:\n    index_cache = get_index_cache()\n    df = index_cache.load()\n    logger.info(f\"Loaded index data: {df.height} rows, {len(df.columns)} columns\")\nexcept Exception as e:\n    logger.error(f\"Failed to load index data: {str(e)}\", exc_info=True)\n    raise APIException(detail=f\"Failed to load index data: {str(e)}\")\n        \nensure_columns(df, [CRD_COLUMN, NAME_COLUMN, STATE_COLUMN, DOMAIN_COLUMN])\nfiltered = df\n        \nif state:\n    filtered = filtered.filter(pl.col(STATE_COLUMN).str.to_uppercase() == state.upper())\nif name:\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 137-197\n```python\n        logger.error(f\"Failed to track RIA activity: {str(e)}\", exc_info=True)\n        # Don't fail the request if tracking fails\n\n\n# ============================================================================\n# Authenticated RIA Endpoints (JWT Required)\n# ============================================================================\n\nclass RIAIndexView(AsyncAPIView):\n    \"\"\"GET /ria/index - Return up to 100 advisors from cached index with optional filters.\"\"\"\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for RIA index.\"\"\"\n        serializer = RIAIndexSearchSerializer(data=request.query_params)\n        serializer.is_valid(raise_exception=True)\n        \n        state = serializer.validated_data.get('state')\n        name = serializer.validated_data.get('name')\n        min_5f_2c = serializer.validated_data.get('min_5f_2c')\n        limit = serializer.validated_data.get('limit', 100)\n        \n        logger.info(f\"RIA index request: state={state}, name={name}, min_5f_2c={min_5f_2c}, limit={limit}\")\n        \n        try:\n            index_cache = get_index_cache()\n            df = index_cache.load()\n            logger.info(f\"Loaded index data: {df.height} rows, {len(df.columns)} columns\")\n        except Exception as e:\n            logger.error(f\"Failed to load index data: {str(e)}\", exc_info=True)\n            raise APIException(detail=f\"Failed to load index data: {str(e)}\")\n        \n        ensure_columns(df, [CRD_COLUMN, NAME_COLUMN, STATE_COLUMN, DOMAIN_COLUMN])\n        filtered = df\n        \n        if state:\n            filtered = filtered.filter(pl.col(STATE_COLUMN).str.to_uppercase() == state.upper())\n        if name:\n            filtered = filtered.filter(pl.col(NAME_COLUMN).str.to_lowercase() == name.lower())\n        if min_5f_2c is not None:\n            if AUM_COLUMN not in df.columns:\n                raise APIException(detail=\"RIA index missing 5F(2)(c) column\")\n            filtered = filtered.filter(\n                pl.col(AUM_COLUMN)\n                .cast(pl.Float64, strict=False)\n                .fill_null(-1.0)\n                >= float(min_5f_2c)\n            )\n        \n        filtered = filtered.sort(NAME_COLUMN)\n        total_matches = filtered.height\n        rows = to_serializable_records(filtered, limit)\n        \n        # Track activity\n        await track_ria_activity(\n            request=request,\n            activity_type='search',\n            search_params=format_search_params_for_storage(serializer.validated_data),\n        )\n        \n        response_data = {\n\n```\n\n## Imports\n```python\n\"\"\"\nDjango REST Framework views for RIA API.\n\nConverted from FastAPI routes in prospecting_api.py.\nAll views use class-based approach with Django async support.\n\"\"\"\n\nimport json\nimport io\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nimport boto3\nimport polars as pl\nfrom botocore.exceptions import ClientError\nfrom django.http import StreamingHttpResponse, FileResponse\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom authentication.permissions import IsAdmin\nfrom rest_framework.exceptions import NotFound, PermissionDenied, ValidationError, APIException\nfrom rest_framework.request import Request\nfrom common.views import AsyncAPIView\n\nfrom ria.serializers import (\n\n```\n\n## Enclosing Function\nLines 148-206\n```python\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for RIA index.\"\"\"\n        serializer = RIAIndexSearchSerializer(data=request.query_params)\n        serializer.is_valid(raise_exception=True)\n        \n        state = serializer.validated_data.get('state')\n        name = serializer.validated_data.get('name')\n        min_5f_2c = serializer.validated_data.get('min_5f_2c')\n        limit = serializer.validated_data.get('limit', 100)\n        \n        logger.info(f\"RIA index request: state={state}, name={name}, min_5f_2c={min_5f_2c}, limit={limit}\")\n        \n        try:\n            index_cache = get_index_cache()\n            df = index_cache.load()\n            logger.info(f\"Loaded index data: {df.height} rows, {len(df.columns)} columns\")\n        except Exception as e:\n            logger.error(f\"Failed to load index data: {str(e)}\", exc_info=True)\n            raise APIException(detail=f\"Failed to load index data: {str(e)}\")\n        \n        ensure_columns(df, [CRD_COLUMN, NAME_COLUMN, STATE_COLUMN, DOMAIN_COLUMN])\n        filtered = df\n        \n        if state:\n            filtered = filtered.filter(pl.col(STATE_COLUMN).str.to_uppercase() == state.upper())\n        if name:\n            filtered = filtered.filter(pl.col(NAME_COLUMN).str.to_lowercase() == name.lower())\n        if min_5f_2c is not None:\n            if AUM_COLUMN not in df.columns:\n                raise APIException(detail=\"RIA index missing 5F(2)(c) column\")\n            filtered = filtered.filter(\n                pl.col(AUM_COLUMN)\n                .cast(pl.Float64, strict=False)\n                .fill_null(-1.0)\n                >= float(min_5f_2c)\n            )\n        \n        filtered = filtered.sort(NAME_COLUMN)\n        total_matches = filtered.height\n        rows = to_serializable_records(filtered, limit)\n        \n        # Track activity\n        await track_ria_activity(\n            request=request,\n            activity_type='search',\n            search_params=format_search_params_for_storage(serializer.validated_data),\n        )\n        \n        response_data = {\n            \"total_matches\": total_matches,\n            \"rows\": rows\n        }\n        response_serializer = RIAIndexResponseSerializer(data=response_data)\n        response_serializer.is_valid()\n        \n        return Response(response_serializer.data, status=status.HTTP_200_OK)\n\n\n\n```\n\n\n============================================================\nSIGNAL 4\n============================================================\n\n## Error Information\n- File: ria/views.py\n- Message: Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling\n- Rule Code: B904\n- Severity: medium\n- Location: Line 472, Column 13\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 465-479 (error on line 8 of 15)\n```python\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['cities'])} distinct cities\")\n            \n            return Response({\"cities\": location_data[\"cities\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get cities: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load cities\")\n\n\nclass RIALocationMetadataView(AsyncAPIView):\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for location metadata.\"\"\"\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 442-502\n```python\n        \"\"\"Handle GET request for countries.\"\"\"\n        logger.info(\"RIA countries metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['countries'])} distinct countries\")\n            \n            return Response({\"countries\": location_data[\"countries\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get countries: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load countries\")\n\n\nclass RIACitiesView(AsyncAPIView):\n    \"\"\"GET /ria/metadata/cities - Get all distinct cities for dropdown.\"\"\"\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for cities.\"\"\"\n        logger.info(\"RIA cities metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['cities'])} distinct cities\")\n            \n            return Response({\"cities\": location_data[\"cities\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get cities: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load cities\")\n\n\nclass RIALocationMetadataView(AsyncAPIView):\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for location metadata.\"\"\"\n        logger.info(\"RIA location metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['countries'])} countries and {len(location_data['cities'])} cities\")\n            \n            serializer = RIALocationMetadataSerializer(data=location_data)\n            serializer.is_valid()\n            \n            return Response(serializer.data, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get location metadata: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load location metadata\")\n\n\n# ============================================================================\n# Debug Endpoint\n# ============================================================================\n\nclass RIADebugS3View(AsyncAPIView):\n    \"\"\"GET /ria/debug/s3 - Debug endpoint to test S3 access and configuration.\"\"\"\n    permission_classes = [IsAuthenticated]  # TODO: Add admin check\n\n```\n\n## Imports\n```python\n\"\"\"\nDjango REST Framework views for RIA API.\n\nConverted from FastAPI routes in prospecting_api.py.\nAll views use class-based approach with Django async support.\n\"\"\"\n\nimport json\nimport io\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nimport boto3\nimport polars as pl\nfrom botocore.exceptions import ClientError\nfrom django.http import StreamingHttpResponse, FileResponse\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom authentication.permissions import IsAdmin\nfrom rest_framework.exceptions import NotFound, PermissionDenied, ValidationError, APIException\nfrom rest_framework.request import Request\nfrom common.views import AsyncAPIView\n\nfrom ria.serializers import (\n\n```\n\n## Enclosing Function\nLines 459-474\n```python\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for cities.\"\"\"\n        logger.info(\"RIA cities metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['cities'])} distinct cities\")\n            \n            return Response({\"cities\": location_data[\"cities\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get cities: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load cities\")\n\n\n\n```\n\n\nPlease provide fixes for the above signals using the specified response format."
  },
  "llm_response": [
    "===== FIX FOR: ria/services/query_service.py =====\n",
    "CONFIDENCE: 0.95\n",
    "REASONING: Converting Optional[type] to type | None syntax for modern Python type annotations\n",
    "\n",
    "```FIXED_CODE\n",
    "\n",
    "@staticmethod\n",
    "async def get_ria_activity(\n",
    "    user_id: str | None = None,\n",
    "    search_id: str | None = None,\n",
    "    activity_type: str | None = None,\n",
    "    from_date: datetime | None = None,\n",
    "    to_date: datetime | None = None,\n",
    "    limit: int = 50,\n",
    "    offset: int = 0\n",
    ") -> Dict[str, Any]:\n",
    "    try:\n",
    "        # Build query filters\n",
    "        filters = {}\n",
    "            \n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: ria/views.py =====\n",
    "CONFIDENCE: 0.95\n",
    "REASONING: Converting Optional[type] to type | None syntax for modern Python type annotations\n",
    "\n",
    "```FIXED_CODE\n",
    "        ip = request.META.get('REMOTE_ADDR', 'unknown')\n",
    "    return ip\n",
    "\n",
    "\n",
    "async def track_ria_activity(\n",
    "    request: Request,\n",
    "    activity_type: str,\n",
    "    search_id: str | None = None,\n",
    "    search_params: Dict[str, Any] | None = None,\n",
    "    search_timestamp: datetime | None = None,\n",
    "    company_crd: str | None = None,\n",
    "    company_name: str | None = None,\n",
    "    company_action: str | None = None,\n",
    ") -> None:\n",
    "    \"\"\"Track RIA activity in the database.\"\"\"\n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: ria/views.py =====\n",
    "CONFIDENCE: 0.90\n",
    "REASONING: Adding 'from e' to the raise statement to properly chain the exception and distinguish it from errors in exception handling\n",
    "\n",
    "```FIXED_CODE\n",
    "        \n",
    "try:\n",
    "    index_cache = get_index_cache()\n",
    "    df = index_cache.load()\n",
    "    logger.info(f\"Loaded index data: {df.height} rows, {len(df.columns)} columns\")\n",
    "except Exception as e:\n",
    "    logger.error(f\"Failed to load index data: {str(e)}\", exc_info=True)\n",
    "    raise APIException(detail=f\"Failed to load index data: {str(e)}\") from e\n",
    "        \n",
    "ensure_columns(df, [CRD_COLUMN, NAME_COLUMN, STATE_COLUMN, DOMAIN_COLUMN])\n",
    "filtered = df\n",
    "        \n",
    "if state:\n",
    "    filtered = filtered.filter(pl.col(STATE_COLUMN).str.to_uppercase() == state.upper())\n",
    "if name:\n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: ria/views.py =====\n",
    "CONFIDENCE: 0.90\n",
    "REASONING: Adding 'from e' to the raise statement to properly chain the exception and distinguish it from errors in exception handling\n",
    "\n",
    "```FIXED_CODE\n",
    "            location_cache = get_location_cache()\n",
    "            location_data = location_cache.get_location_data()\n",
    "            logger.info(f\"Returning {len(location_data['cities'])} distinct cities\")\n",
    "            \n",
    "            return Response({\"cities\": location_data[\"cities\"]}, status=status.HTTP_200_OK)\n",
    "        except Exception as e:\n",
    "            logger.error(f\"Failed to get cities: {str(e)}\", exc_info=True)\n",
    "            raise APIException(detail=\"Failed to load cities\") from e\n",
    "\n",
    "\n",
    "class RIALocationMetadataView(AsyncAPIView):\n",
    "    permission_classes = [IsAuthenticated]\n",
    "    \n",
    "    async def get(self, request: Request):\n",
    "        \"\"\"Handle GET request for location metadata.\"\"\"\n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX ====="
  ]
}