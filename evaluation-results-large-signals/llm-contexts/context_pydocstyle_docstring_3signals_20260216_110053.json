{
  "_debug_metadata": {
    "timestamp": "20260216_110053",
    "tool_id": "pydocstyle",
    "signal_type": "docstring",
    "num_signals": 3,
    "signal_files": [
      "ria/views.py",
      "ria/services/search_service.py"
    ],
    "system_prompt_length": 10610,
    "user_prompt_length": 37415
  },
  "context": {
    "group": {
      "tool_id": "pydocstyle",
      "signal_type": "docstring",
      "group_size": 3
    },
    "signals": [
      {
        "signal": {
          "tool_id": "pydocstyle",
          "signal_type": "docstring",
          "severity": "low",
          "rule_code": "D101",
          "message": "Missing docstring in public class",
          "docs_url": "http://www.pydocstyle.org/en/stable/error_codes.html#D101",
          "file_path": "ria/views.py",
          "span": {
            "start": {
              "row": 475,
              "column": 0
            },
            "end": {
              "row": 475,
              "column": 0
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/views.py",
            "start_row": 445,
            "end_row": 505,
            "text": "        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['countries'])} distinct countries\")\n            \n            return Response({\"countries\": location_data[\"countries\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get countries: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load countries\")\n\n\nclass RIACitiesView(AsyncAPIView):\n    \"\"\"GET /ria/metadata/cities - Get all distinct cities for dropdown.\"\"\"\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for cities.\"\"\"\n        logger.info(\"RIA cities metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['cities'])} distinct cities\")\n            \n            return Response({\"cities\": location_data[\"cities\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get cities: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load cities\")\n\n\nclass RIALocationMetadataView(AsyncAPIView):\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for location metadata.\"\"\"\n        logger.info(\"RIA location metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['countries'])} countries and {len(location_data['cities'])} cities\")\n            \n            serializer = RIALocationMetadataSerializer(data=location_data)\n            serializer.is_valid()\n            \n            return Response(serializer.data, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get location metadata: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load location metadata\")\n\n\n# ============================================================================\n# Debug Endpoint\n# ============================================================================\n\nclass RIADebugS3View(AsyncAPIView):\n    \"\"\"GET /ria/debug/s3 - Debug endpoint to test S3 access and configuration.\"\"\"\n    permission_classes = [IsAuthenticated]  # TODO: Add admin check\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for S3 debug info.\"\"\"\n"
          },
          "imports": {
            "file_path": "ria/views.py",
            "start_row": 1,
            "end_row": 26,
            "text": "\"\"\"\nDjango REST Framework views for RIA API.\n\nConverted from FastAPI routes in prospecting_api.py.\nAll views use class-based approach with Django async support.\n\"\"\"\n\nimport json\nimport io\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nimport boto3\nimport polars as pl\nfrom botocore.exceptions import ClientError\nfrom django.http import StreamingHttpResponse, FileResponse\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom authentication.permissions import IsAdmin\nfrom rest_framework.exceptions import NotFound, PermissionDenied, ValidationError, APIException\nfrom rest_framework.request import Request\nfrom common.views import AsyncAPIView\n\nfrom ria.serializers import (\n"
          },
          "enclosing_function": null,
          "try_except_block": null,
          "class_definition": {
            "file_path": "ria/views.py",
            "start_row": 473,
            "end_row": 475,
            "text": "\n\nclass RIALocationMetadataView(AsyncAPIView):\n"
          },
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/views.py",
          "start_row": 473,
          "end_row": 478,
          "text": "\n\nclass RIALocationMetadataView(AsyncAPIView):\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n",
          "original_text": "\n\nclass RIALocationMetadataView(AsyncAPIView):\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n",
          "error_line": 475,
          "error_line_in_snippet": 3,
          "snippet_length": 6,
          "base_indent": ""
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": false
        }
      },
      {
        "signal": {
          "tool_id": "pydocstyle",
          "signal_type": "docstring",
          "severity": "low",
          "rule_code": "D102",
          "message": "Missing docstring in public method",
          "docs_url": "http://www.pydocstyle.org/en/stable/error_codes.html#D102",
          "file_path": "ria/services/search_service.py",
          "span": {
            "start": {
              "row": 274,
              "column": 0
            },
            "end": {
              "row": 274,
              "column": 0
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/services/search_service.py",
            "start_row": 244,
            "end_row": 304,
            "text": "        if ensemble_score >= 0.6:\n            company['match_score'] = round(ensemble_score, 3)\n            company['match_details'] = {\n                'ratio': round(scores['ratio'], 3),\n                'partial_ratio': round(scores['partial_ratio'], 3),\n                'token_sort_ratio': round(scores['token_sort_ratio'], 3),\n                'token_set_ratio': round(scores['token_set_ratio'], 3)\n            }\n            scored_matches.append(company)\n    \n    # Sort by ensemble score (highest first)\n    scored_matches.sort(key=lambda x: x['match_score'], reverse=True)\n    \n    # Quality over quantity: return only strong matches\n    # If we have 2 strong matches (0.9+) and 8 weak ones (0.6-0.7), return only the 2 strong ones\n    strong_matches = [m for m in scored_matches if m['match_score'] >= 0.8]\n    if len(strong_matches) >= 2:\n        logger.info(f\"Found {len(strong_matches)} strong matches (\u22650.8), returning only strong matches\")\n        return strong_matches[:max_results]\n    \n    # Otherwise, return top matches up to the limit\n    result_count = min(len(scored_matches), max_results)\n    logger.info(f\"Found {len(scored_matches)} total matches, returning top {result_count} (scores: {[m['match_score'] for m in scored_matches[:result_count]]})\")\n    \n    return scored_matches[:result_count]\n\n\nclass SearchService:\n    \n    @staticmethod\n    def search_companies(\n        name: Optional[str] = None,\n        domain: Optional[str] = None,\n        state: Optional[str] = None,\n        city: Optional[str] = None,\n        country: Optional[str] = None,\n        min_aum: Optional[float] = None,\n        max_aum: Optional[float] = None,\n        min_discretionary_aum: Optional[float] = None,\n        max_discretionary_aum: Optional[float] = None,\n        min_non_discretionary_aum: Optional[float] = None,\n        max_non_discretionary_aum: Optional[float] = None,\n        min_total_employees: Optional[int] = None,\n        max_total_employees: Optional[int] = None,\n        min_total_offices: Optional[int] = None,\n        max_total_offices: Optional[int] = None,\n        # Client type filters (Y/N)\n        individual_clients: Optional[str] = None,\n        high_net_worth_clients: Optional[str] = None,\n        banking_clients: Optional[str] = None,\n        investment_companies_clients: Optional[str] = None,\n        pension_clients: Optional[str] = None,\n        charity_clients: Optional[str] = None,\n        state_municipal_clients: Optional[str] = None,\n        investment_advisor_clients: Optional[str] = None,\n        insurance_clients: Optional[str] = None,\n        sovereign_wealth_clients: Optional[str] = None,\n        corporate_clients: Optional[str] = None,\n        # Private funds filter\n        private_funds: Optional[str] = None,\n        # Asset class filters (Y/N)\n"
          },
          "imports": {
            "file_path": "ria/services/search_service.py",
            "start_row": 1,
            "end_row": 14,
            "text": "\"\"\"\nSearch Service\n\nThis service handles all search and filtering operations for RIA data.\nIncludes intelligent fuzzy matching and comprehensive filtering logic.\n\"\"\"\n\nfrom typing import Dict, Any, List, Optional\nfrom urllib.parse import urlparse\n\nimport polars as pl\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.utils.constants import (\n"
          },
          "enclosing_function": {
            "file_path": "ria/services/search_service.py",
            "start_row": 272,
            "end_row": 442,
            "text": "    \n    @staticmethod\n    def search_companies(\n        name: Optional[str] = None,\n        domain: Optional[str] = None,\n        state: Optional[str] = None,\n        city: Optional[str] = None,\n        country: Optional[str] = None,\n        min_aum: Optional[float] = None,\n        max_aum: Optional[float] = None,\n        min_discretionary_aum: Optional[float] = None,\n        max_discretionary_aum: Optional[float] = None,\n        min_non_discretionary_aum: Optional[float] = None,\n        max_non_discretionary_aum: Optional[float] = None,\n        min_total_employees: Optional[int] = None,\n        max_total_employees: Optional[int] = None,\n        min_total_offices: Optional[int] = None,\n        max_total_offices: Optional[int] = None,\n        # Client type filters (Y/N)\n        individual_clients: Optional[str] = None,\n        high_net_worth_clients: Optional[str] = None,\n        banking_clients: Optional[str] = None,\n        investment_companies_clients: Optional[str] = None,\n        pension_clients: Optional[str] = None,\n        charity_clients: Optional[str] = None,\n        state_municipal_clients: Optional[str] = None,\n        investment_advisor_clients: Optional[str] = None,\n        insurance_clients: Optional[str] = None,\n        sovereign_wealth_clients: Optional[str] = None,\n        corporate_clients: Optional[str] = None,\n        # Private funds filter\n        private_funds: Optional[str] = None,\n        # Asset class filters (Y/N)\n        has_hedge_funds: Optional[str] = None,\n        has_liquidity_funds: Optional[str] = None,\n        has_pe_funds: Optional[str] = None,\n        has_real_estate_funds: Optional[str] = None,\n        has_securitized_funds: Optional[str] = None,\n        has_vc_funds: Optional[str] = None,\n        has_other_funds: Optional[str] = None,\n        limit: int = 10,\n        offset: int = 0,\n    ) -> Dict[str, Any]:\n        # Load index data\n        index_cache = get_index_cache()\n        df = index_cache.load()\n        \n        # Ensure required columns exist\n        required_columns = [\n            CRD_COLUMN, NAME_COLUMN, STATE_COLUMN, CITY_COLUMN, COUNTRY_COLUMN, DOMAIN_COLUMN,\n            AUM_COLUMN, DISCRETIONARY_AUM_COLUMN, NON_DISCRETIONARY_AUM_COLUMN,\n            EMPLOYEES_COLUMN, OFFICES_COLUMN\n        ] + list(CLIENT_TYPE_COLUMNS.values()) + list(FUND_COLUMNS.values())\n        \n        ensure_columns(df, required_columns)\n        \n        # Attach domain column\n        df_domain = attach_domain_column(df, DOMAIN_COLUMN)\n        \n        # Apply filters (name is not used in filtering - it's used for search after filtering)\n        filtered_df = filter_companies(\n            df_domain,\n            domain=domain,\n            state=state,\n            city=city,\n            country=country,\n            min_aum=min_aum,\n            max_aum=max_aum,\n            min_discretionary_aum=min_discretionary_aum,\n            max_discretionary_aum=max_discretionary_aum,\n            min_non_discretionary_aum=min_non_discretionary_aum,\n            max_non_discretionary_aum=max_non_discretionary_aum,\n            min_total_employees=min_total_employees,\n            max_total_employees=max_total_employees,\n            min_total_offices=min_total_offices,\n            max_total_offices=max_total_offices,\n            individual_clients=individual_clients,\n            high_net_worth_clients=high_net_worth_clients,\n            banking_clients=banking_clients,\n            investment_companies_clients=investment_companies_clients,\n            pension_clients=pension_clients,\n            charity_clients=charity_clients,\n            state_municipal_clients=state_municipal_clients,\n            investment_advisor_clients=investment_advisor_clients,\n            insurance_clients=insurance_clients,\n            sovereign_wealth_clients=sovereign_wealth_clients,\n            corporate_clients=corporate_clients,\n            private_funds=private_funds,\n            has_hedge_funds=has_hedge_funds,\n            has_liquidity_funds=has_liquidity_funds,\n            has_pe_funds=has_pe_funds,\n            has_real_estate_funds=has_real_estate_funds,\n            has_securitized_funds=has_securitized_funds,\n            has_vc_funds=has_vc_funds,\n            has_other_funds=has_other_funds,\n        )\n        \n        # Check if any rows remain after filtering\n        if filtered_df.is_empty():\n            return {\n                \"total_matches\": 0,\n                \"matches\": [],\n                \"pagination\": {\n                    \"offset\": offset,\n                    \"limit\": limit,\n                    \"has_more\": False,\n                    \"next_offset\": None,\n                    \"showing\": \"0 of 0\"\n                },\n                \"filter_status\": {\n                    \"applied_filters\": {},\n                    \"ignored_filters\": {},\n                    \"available_filters\": []\n                }\n            }\n        \n        # Handle name search with intelligent fuzzy matching (on filtered data)\n        if name:\n            logger.info(f\"Starting name search for: '{name}' on {filtered_df.height} filtered rows\")\n            # Get ALL matches first (no limit), then apply pagination\n            raw_matches = intelligent_name_search(filtered_df, name, 10000)  # Large number to get all matches\n            logger.info(f\"Name search '{name}' returned {len(raw_matches)} total matches\")\n            # Name search results are already sorted by similarity score (highest first)\n        else:\n            logger.info(f\"No name search, getting all results sorted by AUM from {filtered_df.height} filtered rows\")\n            # No name search, return filtered results sorted by AUM (descending)\n            filtered_df = filtered_df.sort(AUM_COLUMN, descending=True)\n            raw_matches = to_serializable_records(filtered_df, 10000)  # Large number to get all matches\n            logger.info(f\"Retrieved {len(raw_matches)} total matches from filtered data, sorted by AUM (descending)\")\n        \n        # Transform all matches to include display names and top 3 calculations\n        all_transformed_matches = []\n        for match in raw_matches:\n            transformed_match = transform_company_record_for_preview(match)\n            # Preserve match_score if present (for name searches)\n            if \"match_score\" in match:\n                transformed_match[\"match_score\"] = match[\"match_score\"]\n            if \"match_details\" in match:\n                transformed_match[\"match_details\"] = match[\"match_details\"]\n            all_transformed_matches.append(transformed_match)\n        \n        # Apply pagination to transformed results\n        total_matches = len(all_transformed_matches)\n        start_idx = offset\n        end_idx = offset + limit\n        matches = all_transformed_matches[start_idx:end_idx]\n        \n        # Calculate pagination metadata\n        has_more = end_idx < total_matches\n        next_offset = end_idx if has_more else None\n        \n        logger.info(f\"Pagination: showing {len(matches)} of {total_matches} total matches (offset={offset}, limit={limit})\")\n        \n        return {\n            \"total_matches\": total_matches,\n            \"matches\": matches,\n            \"pagination\": {\n                \"offset\": offset,\n                \"limit\": limit,\n                \"has_more\": has_more,\n                \"next_offset\": next_offset,\n                \"showing\": f\"{len(matches)} of {total_matches}\"\n            },\n            \"filter_status\": {\n                \"applied_filters\": {},\n                \"ignored_filters\": {},\n                \"available_filters\": []\n            }\n        }\n\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/services/search_service.py",
          "start_row": 272,
          "end_row": 317,
          "text": "    \n@staticmethod\ndef search_companies(\n    name: Optional[str] = None,\n    domain: Optional[str] = None,\n    state: Optional[str] = None,\n    city: Optional[str] = None,\n    country: Optional[str] = None,\n    min_aum: Optional[float] = None,\n    max_aum: Optional[float] = None,\n    min_discretionary_aum: Optional[float] = None,\n    max_discretionary_aum: Optional[float] = None,\n    min_non_discretionary_aum: Optional[float] = None,\n    max_non_discretionary_aum: Optional[float] = None,\n    min_total_employees: Optional[int] = None,\n    max_total_employees: Optional[int] = None,\n    min_total_offices: Optional[int] = None,\n    max_total_offices: Optional[int] = None,\n    # Client type filters (Y/N)\n    individual_clients: Optional[str] = None,\n    high_net_worth_clients: Optional[str] = None,\n    banking_clients: Optional[str] = None,\n    investment_companies_clients: Optional[str] = None,\n    pension_clients: Optional[str] = None,\n    charity_clients: Optional[str] = None,\n    state_municipal_clients: Optional[str] = None,\n    investment_advisor_clients: Optional[str] = None,\n    insurance_clients: Optional[str] = None,\n    sovereign_wealth_clients: Optional[str] = None,\n    corporate_clients: Optional[str] = None,\n    # Private funds filter\n    private_funds: Optional[str] = None,\n    # Asset class filters (Y/N)\n    has_hedge_funds: Optional[str] = None,\n    has_liquidity_funds: Optional[str] = None,\n    has_pe_funds: Optional[str] = None,\n    has_real_estate_funds: Optional[str] = None,\n    has_securitized_funds: Optional[str] = None,\n    has_vc_funds: Optional[str] = None,\n    has_other_funds: Optional[str] = None,\n    limit: int = 10,\n    offset: int = 0,\n) -> Dict[str, Any]:\n    # Load index data\n    index_cache = get_index_cache()\n    df = index_cache.load()\n",
          "original_text": "    \n    @staticmethod\n    def search_companies(\n        name: Optional[str] = None,\n        domain: Optional[str] = None,\n        state: Optional[str] = None,\n        city: Optional[str] = None,\n        country: Optional[str] = None,\n        min_aum: Optional[float] = None,\n        max_aum: Optional[float] = None,\n        min_discretionary_aum: Optional[float] = None,\n        max_discretionary_aum: Optional[float] = None,\n        min_non_discretionary_aum: Optional[float] = None,\n        max_non_discretionary_aum: Optional[float] = None,\n        min_total_employees: Optional[int] = None,\n        max_total_employees: Optional[int] = None,\n        min_total_offices: Optional[int] = None,\n        max_total_offices: Optional[int] = None,\n        # Client type filters (Y/N)\n        individual_clients: Optional[str] = None,\n        high_net_worth_clients: Optional[str] = None,\n        banking_clients: Optional[str] = None,\n        investment_companies_clients: Optional[str] = None,\n        pension_clients: Optional[str] = None,\n        charity_clients: Optional[str] = None,\n        state_municipal_clients: Optional[str] = None,\n        investment_advisor_clients: Optional[str] = None,\n        insurance_clients: Optional[str] = None,\n        sovereign_wealth_clients: Optional[str] = None,\n        corporate_clients: Optional[str] = None,\n        # Private funds filter\n        private_funds: Optional[str] = None,\n        # Asset class filters (Y/N)\n        has_hedge_funds: Optional[str] = None,\n        has_liquidity_funds: Optional[str] = None,\n        has_pe_funds: Optional[str] = None,\n        has_real_estate_funds: Optional[str] = None,\n        has_securitized_funds: Optional[str] = None,\n        has_vc_funds: Optional[str] = None,\n        has_other_funds: Optional[str] = None,\n        limit: int = 10,\n        offset: int = 0,\n    ) -> Dict[str, Any]:\n        # Load index data\n        index_cache = get_index_cache()\n        df = index_cache.load()\n",
          "error_line": 274,
          "error_line_in_snippet": 3,
          "snippet_length": 46,
          "base_indent": "    "
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": false
        }
      },
      {
        "signal": {
          "tool_id": "pydocstyle",
          "signal_type": "docstring",
          "severity": "low",
          "rule_code": "D103",
          "message": "Missing docstring in public function",
          "docs_url": "http://www.pydocstyle.org/en/stable/error_codes.html#D103",
          "file_path": "ria/services/search_service.py",
          "span": {
            "start": {
              "row": 443,
              "column": 0
            },
            "end": {
              "row": 443,
              "column": 0
            }
          }
        },
        "file_read_error": null,
        "code_context": {
          "window": {
            "file_path": "ria/services/search_service.py",
            "start_row": 413,
            "end_row": 473,
            "text": "        # Apply pagination to transformed results\n        total_matches = len(all_transformed_matches)\n        start_idx = offset\n        end_idx = offset + limit\n        matches = all_transformed_matches[start_idx:end_idx]\n        \n        # Calculate pagination metadata\n        has_more = end_idx < total_matches\n        next_offset = end_idx if has_more else None\n        \n        logger.info(f\"Pagination: showing {len(matches)} of {total_matches} total matches (offset={offset}, limit={limit})\")\n        \n        return {\n            \"total_matches\": total_matches,\n            \"matches\": matches,\n            \"pagination\": {\n                \"offset\": offset,\n                \"limit\": limit,\n                \"has_more\": has_more,\n                \"next_offset\": next_offset,\n                \"showing\": f\"{len(matches)} of {total_matches}\"\n            },\n            \"filter_status\": {\n                \"applied_filters\": {},\n                \"ignored_filters\": {},\n                \"available_filters\": []\n            }\n        }\n\n\ndef filter_companies(\n    df: pl.DataFrame,\n    domain: Optional[str] = None,\n    state: Optional[str] = None,\n    city: Optional[str] = None,\n    country: Optional[str] = None,\n    min_aum: Optional[float] = None,\n    max_aum: Optional[float] = None,\n    min_discretionary_aum: Optional[float] = None,\n    max_discretionary_aum: Optional[float] = None,\n    min_non_discretionary_aum: Optional[float] = None,\n    max_non_discretionary_aum: Optional[float] = None,\n    min_total_employees: Optional[int] = None,\n    max_total_employees: Optional[int] = None,\n    min_total_offices: Optional[int] = None,\n    max_total_offices: Optional[int] = None,\n    individual_clients: Optional[str] = None,\n    high_net_worth_clients: Optional[str] = None,\n    banking_clients: Optional[str] = None,\n    investment_companies_clients: Optional[str] = None,\n    pension_clients: Optional[str] = None,\n    charity_clients: Optional[str] = None,\n    state_municipal_clients: Optional[str] = None,\n    investment_advisor_clients: Optional[str] = None,\n    insurance_clients: Optional[str] = None,\n    sovereign_wealth_clients: Optional[str] = None,\n    corporate_clients: Optional[str] = None,\n    private_funds: Optional[str] = None,\n    has_hedge_funds: Optional[str] = None,\n    has_liquidity_funds: Optional[str] = None,\n    has_pe_funds: Optional[str] = None,\n"
          },
          "imports": {
            "file_path": "ria/services/search_service.py",
            "start_row": 1,
            "end_row": 14,
            "text": "\"\"\"\nSearch Service\n\nThis service handles all search and filtering operations for RIA data.\nIncludes intelligent fuzzy matching and comprehensive filtering logic.\n\"\"\"\n\nfrom typing import Dict, Any, List, Optional\nfrom urllib.parse import urlparse\n\nimport polars as pl\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.utils.constants import (\n"
          },
          "enclosing_function": {
            "file_path": "ria/services/search_service.py",
            "start_row": 441,
            "end_row": 715,
            "text": "\n\ndef filter_companies(\n    df: pl.DataFrame,\n    domain: Optional[str] = None,\n    state: Optional[str] = None,\n    city: Optional[str] = None,\n    country: Optional[str] = None,\n    min_aum: Optional[float] = None,\n    max_aum: Optional[float] = None,\n    min_discretionary_aum: Optional[float] = None,\n    max_discretionary_aum: Optional[float] = None,\n    min_non_discretionary_aum: Optional[float] = None,\n    max_non_discretionary_aum: Optional[float] = None,\n    min_total_employees: Optional[int] = None,\n    max_total_employees: Optional[int] = None,\n    min_total_offices: Optional[int] = None,\n    max_total_offices: Optional[int] = None,\n    individual_clients: Optional[str] = None,\n    high_net_worth_clients: Optional[str] = None,\n    banking_clients: Optional[str] = None,\n    investment_companies_clients: Optional[str] = None,\n    pension_clients: Optional[str] = None,\n    charity_clients: Optional[str] = None,\n    state_municipal_clients: Optional[str] = None,\n    investment_advisor_clients: Optional[str] = None,\n    insurance_clients: Optional[str] = None,\n    sovereign_wealth_clients: Optional[str] = None,\n    corporate_clients: Optional[str] = None,\n    private_funds: Optional[str] = None,\n    has_hedge_funds: Optional[str] = None,\n    has_liquidity_funds: Optional[str] = None,\n    has_pe_funds: Optional[str] = None,\n    has_real_estate_funds: Optional[str] = None,\n    has_securitized_funds: Optional[str] = None,\n    has_vc_funds: Optional[str] = None,\n    has_other_funds: Optional[str] = None,\n) -> pl.DataFrame:\n    filtered_df = df\n    \n    # Location filters (exact match)\n    if state and STATE_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(pl.col(STATE_COLUMN) == state)\n    \n    if city and CITY_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(pl.col(CITY_COLUMN).str.strip_chars() == city.strip())\n    \n    if country and COUNTRY_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(pl.col(COUNTRY_COLUMN).str.strip_chars() == country.strip())\n    \n    # AUM filters\n    if min_aum is not None and AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) >= min_aum\n        )\n    \n    if max_aum is not None and AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) <= max_aum\n        )\n    \n    if min_discretionary_aum is not None and DISCRETIONARY_AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(DISCRETIONARY_AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) >= min_discretionary_aum\n        )\n    \n    if max_discretionary_aum is not None and DISCRETIONARY_AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(DISCRETIONARY_AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) <= max_discretionary_aum\n        )\n    \n    if min_non_discretionary_aum is not None and NON_DISCRETIONARY_AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(NON_DISCRETIONARY_AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) >= min_non_discretionary_aum\n        )\n    \n    if max_non_discretionary_aum is not None and NON_DISCRETIONARY_AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(NON_DISCRETIONARY_AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) <= max_non_discretionary_aum\n        )\n    \n    # Size filters\n    if min_total_employees is not None and EMPLOYEES_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(EMPLOYEES_COLUMN).cast(pl.Int64, strict=False).fill_null(-1) >= min_total_employees\n        )\n    \n    if max_total_employees is not None and EMPLOYEES_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(EMPLOYEES_COLUMN).cast(pl.Int64, strict=False).fill_null(-1) <= max_total_employees\n        )\n    \n    if min_total_offices is not None and OFFICES_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(OFFICES_COLUMN).cast(pl.Int64, strict=False).fill_null(-1) >= min_total_offices\n        )\n    \n    if max_total_offices is not None and OFFICES_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(OFFICES_COLUMN).cast(pl.Int64, strict=False).fill_null(-1) <= max_total_offices\n        )\n    \n    # Client type filters (Y/N) - check for non-null, non-zero numeric values\n    # Handle both string and numeric column types\n    client_type_filters = {\n        \"individual_clients\": individual_clients,\n        \"high_net_worth_clients\": high_net_worth_clients,\n        \"banking_clients\": banking_clients,\n        \"investment_companies_clients\": investment_companies_clients,\n        \"pension_clients\": pension_clients,\n        \"charity_clients\": charity_clients,\n        \"state_municipal_clients\": state_municipal_clients,\n        \"investment_advisor_clients\": investment_advisor_clients,\n        \"insurance_clients\": insurance_clients,\n        \"sovereign_wealth_clients\": sovereign_wealth_clients,\n        \"corporate_clients\": corporate_clients,\n    }\n    \n    for filter_name, filter_value in client_type_filters.items():\n        if filter_value is not None:\n            yn_value = filter_value.strip().upper()\n            if yn_value in ['Y', 'N']:\n                column_name = CLIENT_TYPE_COLUMNS[filter_name]\n                if column_name in filtered_df.columns:\n                    try:\n                        # Check column type - handle both string and numeric\n                        column_dtype = filtered_df.schema[column_name]\n                        is_string_type = column_dtype == pl.Utf8\n                        \n                        if yn_value == \"Y\":\n                            # Check for non-null, non-zero value\n                            if is_string_type:\n                                # Convert string to numeric for comparison, handling invalid values\n                                filtered_df = filtered_df.filter(\n                                    pl.col(column_name).is_not_null() & \n                                    (pl.col(column_name).cast(pl.Int64, strict=False) > 0)\n                                )\n                            else:\n                                # Already numeric, use direct comparison\n                                filtered_df = filtered_df.filter(\n                                    pl.col(column_name).is_not_null() & (pl.col(column_name) > 0)\n                                )\n                        elif yn_value == \"N\":\n                            # Check for null or zero value\n                            if is_string_type:\n                                # Convert string to numeric for comparison, handling invalid values\n                                filtered_df = filtered_df.filter(\n                                    pl.col(column_name).is_null() | \n                                    (pl.col(column_name).cast(pl.Int64, strict=False) == 0) |\n                                    (pl.col(column_name).cast(pl.Int64, strict=False).is_null())\n                                )\n                            else:\n                                # Already numeric, use direct comparison\n                                filtered_df = filtered_df.filter(\n                                    pl.col(column_name).is_null() | (pl.col(column_name) == 0)\n                                )\n                    except Exception as e:\n                        # Log error but continue with other filters\n                        logger.warning(\n                            f\"Error filtering by {filter_name} (column {column_name}): {str(e)}. \"\n                            f\"Skipping this filter.\"\n                        )\n                        continue\n    \n    # Private funds and asset class filters (Y/N)\n    fund_filters = {\n        \"private_funds\": private_funds,\n        \"has_hedge_funds\": has_hedge_funds,\n        \"has_liquidity_funds\": has_liquidity_funds,\n        \"has_pe_funds\": has_pe_funds,\n        \"has_real_estate_funds\": has_real_estate_funds,\n        \"has_securitized_funds\": has_securitized_funds,\n        \"has_vc_funds\": has_vc_funds,\n        \"has_other_funds\": has_other_funds,\n    }\n    \n    for filter_name, filter_value in fund_filters.items():\n        if filter_value is not None:\n            yn_value = filter_value.strip().upper()\n            if yn_value in ['Y', 'N']:\n                if filter_name == \"private_funds\":\n                    # Special handling for private funds - check both 7B(1) and 7B(2) columns\n                    column_7b1 = \"Count of Private Funds - 7B(1)\"\n                    column_7b2 = \"Count of Private Funds - 7B(2)\"\n                    if column_7b1 in filtered_df.columns and column_7b2 in filtered_df.columns:\n                        try:\n                            # Check column types - handle both string and numeric\n                            dtype_7b1 = filtered_df.schema[column_7b1]\n                            dtype_7b2 = filtered_df.schema[column_7b2]\n                            is_string_7b1 = dtype_7b1 == pl.Utf8\n                            is_string_7b2 = dtype_7b2 == pl.Utf8\n                            \n                            if yn_value == \"Y\":\n                                # Check if either column has a non-null, non-zero value\n                                if is_string_7b1 and is_string_7b2:\n                                    # Both are strings, convert to numeric\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_not_null() & (pl.col(column_7b1).cast(pl.Int64, strict=False) > 0)) |\n                                        (pl.col(column_7b2).is_not_null() & (pl.col(column_7b2).cast(pl.Int64, strict=False) > 0))\n                                    )\n                                elif is_string_7b1:\n                                    # Only 7b1 is string\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_not_null() & (pl.col(column_7b1).cast(pl.Int64, strict=False) > 0)) |\n                                        (pl.col(column_7b2).is_not_null() & (pl.col(column_7b2) > 0))\n                                    )\n                                elif is_string_7b2:\n                                    # Only 7b2 is string\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_not_null() & (pl.col(column_7b1) > 0)) |\n                                        (pl.col(column_7b2).is_not_null() & (pl.col(column_7b2).cast(pl.Int64, strict=False) > 0))\n                                    )\n                                else:\n                                    # Both are numeric\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_not_null() & (pl.col(column_7b1) > 0)) |\n                                        (pl.col(column_7b2).is_not_null() & (pl.col(column_7b2) > 0))\n                                    )\n                            elif yn_value == \"N\":\n                                # Check if both columns are null or zero\n                                if is_string_7b1 and is_string_7b2:\n                                    # Both are strings, convert to numeric\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_null() | (pl.col(column_7b1).cast(pl.Int64, strict=False) == 0) | (pl.col(column_7b1).cast(pl.Int64, strict=False).is_null())) &\n                                        (pl.col(column_7b2).is_null() | (pl.col(column_7b2).cast(pl.Int64, strict=False) == 0) | (pl.col(column_7b2).cast(pl.Int64, strict=False).is_null()))\n                                    )\n                                elif is_string_7b1:\n                                    # Only 7b1 is string\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_null() | (pl.col(column_7b1).cast(pl.Int64, strict=False) == 0) | (pl.col(column_7b1).cast(pl.Int64, strict=False).is_null())) &\n                                        (pl.col(column_7b2).is_null() | (pl.col(column_7b2) == 0))\n                                    )\n                                elif is_string_7b2:\n                                    # Only 7b2 is string\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_null() | (pl.col(column_7b1) == 0)) &\n                                        (pl.col(column_7b2).is_null() | (pl.col(column_7b2).cast(pl.Int64, strict=False) == 0) | (pl.col(column_7b2).cast(pl.Int64, strict=False).is_null()))\n                                    )\n                                else:\n                                    # Both are numeric\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_null() | (pl.col(column_7b1) == 0)) &\n                                        (pl.col(column_7b2).is_null() | (pl.col(column_7b2) == 0))\n                                    )\n                        except Exception as e:\n                            # Log error but continue with other filters\n                            logger.warning(\n                                f\"Error filtering by private_funds (columns {column_7b1}, {column_7b2}): {str(e)}. \"\n                                f\"Skipping this filter.\"\n                            )\n                            continue\n                else:\n                    # Standard fund filter logic for asset class filters (Y/N strings)\n                    column_name = FUND_COLUMNS[filter_name]\n                    if column_name in filtered_df.columns:\n                        try:\n                            filtered_df = filtered_df.filter(\n                                pl.col(column_name).str.strip_chars().str.to_uppercase() == yn_value\n                            )\n                        except Exception as e:\n                            # Log error but continue with other filters\n                            logger.warning(\n                                f\"Error filtering by {filter_name} (column {column_name}): {str(e)}. \"\n                                f\"Skipping this filter.\"\n                            )\n                            continue\n    \n    # Domain filter (exact match on canonicalized domain)\n    if domain:\n        domain_norm = canonicalize_domain(domain)\n        if domain_norm and \"__domain\" in filtered_df.columns:\n            filtered_df = filtered_df.filter(pl.col(\"__domain\") == domain_norm)\n    \n    return filtered_df\n\n"
          },
          "try_except_block": null,
          "class_definition": null,
          "type_aliases": null,
          "related_function": null,
          "module_constants": null
        },
        "edit_snippet": {
          "file_path": "ria/services/search_service.py",
          "start_row": 441,
          "end_row": 481,
          "text": "\n\ndef filter_companies(\n    df: pl.DataFrame,\n    domain: Optional[str] = None,\n    state: Optional[str] = None,\n    city: Optional[str] = None,\n    country: Optional[str] = None,\n    min_aum: Optional[float] = None,\n    max_aum: Optional[float] = None,\n    min_discretionary_aum: Optional[float] = None,\n    max_discretionary_aum: Optional[float] = None,\n    min_non_discretionary_aum: Optional[float] = None,\n    max_non_discretionary_aum: Optional[float] = None,\n    min_total_employees: Optional[int] = None,\n    max_total_employees: Optional[int] = None,\n    min_total_offices: Optional[int] = None,\n    max_total_offices: Optional[int] = None,\n    individual_clients: Optional[str] = None,\n    high_net_worth_clients: Optional[str] = None,\n    banking_clients: Optional[str] = None,\n    investment_companies_clients: Optional[str] = None,\n    pension_clients: Optional[str] = None,\n    charity_clients: Optional[str] = None,\n    state_municipal_clients: Optional[str] = None,\n    investment_advisor_clients: Optional[str] = None,\n    insurance_clients: Optional[str] = None,\n    sovereign_wealth_clients: Optional[str] = None,\n    corporate_clients: Optional[str] = None,\n    private_funds: Optional[str] = None,\n    has_hedge_funds: Optional[str] = None,\n    has_liquidity_funds: Optional[str] = None,\n    has_pe_funds: Optional[str] = None,\n    has_real_estate_funds: Optional[str] = None,\n    has_securitized_funds: Optional[str] = None,\n    has_vc_funds: Optional[str] = None,\n    has_other_funds: Optional[str] = None,\n) -> pl.DataFrame:\n    filtered_df = df\n    \n    # Location filters (exact match)\n",
          "original_text": "\n\ndef filter_companies(\n    df: pl.DataFrame,\n    domain: Optional[str] = None,\n    state: Optional[str] = None,\n    city: Optional[str] = None,\n    country: Optional[str] = None,\n    min_aum: Optional[float] = None,\n    max_aum: Optional[float] = None,\n    min_discretionary_aum: Optional[float] = None,\n    max_discretionary_aum: Optional[float] = None,\n    min_non_discretionary_aum: Optional[float] = None,\n    max_non_discretionary_aum: Optional[float] = None,\n    min_total_employees: Optional[int] = None,\n    max_total_employees: Optional[int] = None,\n    min_total_offices: Optional[int] = None,\n    max_total_offices: Optional[int] = None,\n    individual_clients: Optional[str] = None,\n    high_net_worth_clients: Optional[str] = None,\n    banking_clients: Optional[str] = None,\n    investment_companies_clients: Optional[str] = None,\n    pension_clients: Optional[str] = None,\n    charity_clients: Optional[str] = None,\n    state_municipal_clients: Optional[str] = None,\n    investment_advisor_clients: Optional[str] = None,\n    insurance_clients: Optional[str] = None,\n    sovereign_wealth_clients: Optional[str] = None,\n    corporate_clients: Optional[str] = None,\n    private_funds: Optional[str] = None,\n    has_hedge_funds: Optional[str] = None,\n    has_liquidity_funds: Optional[str] = None,\n    has_pe_funds: Optional[str] = None,\n    has_real_estate_funds: Optional[str] = None,\n    has_securitized_funds: Optional[str] = None,\n    has_vc_funds: Optional[str] = None,\n    has_other_funds: Optional[str] = None,\n) -> pl.DataFrame:\n    filtered_df = df\n    \n    # Location filters (exact match)\n",
          "error_line": 443,
          "error_line_in_snippet": 3,
          "snippet_length": 41,
          "base_indent": ""
        },
        "edit_window_type": "lines",
        "fix_context": {
          "exists": false
        }
      }
    ],
    "merged_snippet_groups": [],
    "standalone_signal_indices": [
      0,
      1,
      2
    ]
  },
  "prompts": {
    "system_prompt": "You are an expert code repair agent. Your task is to make MINIMAL, SURGICAL fixes to code errors.\n\n## CRITICAL PRINCIPLE: MINIMAL CHANGES ONLY\n\nYour job is to fix ONLY the specific error mentioned. You are NOT improving, refactoring, or cleaning up code.\n\n**THE GOLDEN RULE**: Every line in your output that is NOT directly part of the fix MUST be IDENTICAL to the input - same content, same whitespace, same everything.\n\n## How This Works\n\nFor each error signal, you will receive:\n\n1. **Error Information**: Type, message, severity, and rule code\n2. **Edit Snippet**: A small code snippet (~13 lines) containing the error\n   - This is what you need to FIX and RETURN\n   - The error location within the snippet is indicated (e.g., \"Error on line 4 of 13\")\n3. **Context Window**: A larger code window (~30 lines) around the error for understanding\n   - Use this to understand the surrounding code, but DON'T return it\n\n4. **Tailored Context** (varies by signal type - optimized to reduce token usage):\n   - **Imports**: The file's import block (for type definitions, dependencies)\n     - Included for: type errors, undefined names, most issues\n     - Excluded for: import-only errors, bare except blocks\n   - **Enclosing Function**: The function containing the error (for understanding scope/logic)\n     - Included for: type errors, docstring errors, function-level issues\n     - Excluded for: import errors (global scope), bare except (sent separately)\n   - **Try/Except Block**: The try/except block containing the error\n     - Included for: bare except errors (E722)\n     - Excluded for: most other errors\n\nNote: Context is carefully selected to provide what you need while minimizing token usage.\nNot all context is present for every error - you'll only receive relevant context.\n\n## Response Format\n\nFor EACH signal/snippet you receive, respond with this EXACT format:\n\n```\n===== FIX FOR: <file_path> =====\nCONFIDENCE: <0.0-1.0>\nREASONING: <brief explanation of the fix>\n\n```FIXED_CODE\n<complete fixed snippet - ALL lines from edit_snippet, with ONLY the fix applied>\n```\n\nWARNINGS: <any caveats, or \"None\">\n===== END FIX =====\n```\n\n## CRITICAL Rules - READ CAREFULLY\n\n1. **MINIMAL CHANGES ONLY** - Change ONLY what is necessary to fix the specific error. Nothing more.\n\n2. **PRESERVE EVERYTHING ELSE EXACTLY** - Every line that is NOT part of the fix must be returned EXACTLY as it appeared in the input, character-for-character, including:\n   - Comments and documentation\n   - Blank lines (including leading and trailing blank lines)\n   - All whitespace (including trailing newlines at the end of the snippet)\n   - Other variable declarations\n   - Function definitions\n   - String content (including multi-line strings)\n\n   **CRITICAL**: If the input snippet ends with blank lines or newlines, your output MUST end with the exact same number of blank lines/newlines. Do NOT trim trailing whitespace.\n\n3. **DO NOT under any circumstances**:\n   - Delete lines that aren't related to the fix\n   - Add code that isn't required for the fix\n   - \"Clean up\" or \"improve\" surrounding code\n   - Modify comments or documentation\n   - Change formatting on unrelated lines\n   - Remove blank lines\n   - Add blank lines (unless the fix specifically requires it)\n   - Modify string literals or docstrings\n   - Delete function definitions\n   - Remove dictionary entries or list items unrelated to the fix\n\n4. **Maintain RELATIVE indentation** - The snippet has had its base indentation removed. Preserve relative indentation exactly. If a line has 4 spaces in the input, it must have 4 spaces in your output.\n\n5. **One fix block per signal** - If multiple signals, provide multiple fix blocks\n\n6. **Use context for understanding only** - The context window, imports, and enclosing function help you understand the code, but you only return the fixed edit_snippet\n\n## Example - Correct Minimal Fix\n\nInput:\n- Error: \"Need type annotation for 'cache'\" on line 173\n- Edit Snippet (error on line 4 of 7, lines 170-176):\n```\n}\n\nDEPRIORITIZE_QUERIES = {}\ncache = {}\n\n# Model configuration\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n(Note: The snippet ends with a newline after the last line - this MUST be preserved)\n\nCORRECT Response (only `cache = {}` changed to `cache: dict = {}`):\n```\n===== FIX FOR: app/config/tier_queries.py =====\nCONFIDENCE: 0.95\nREASONING: Added dict type annotation to cache variable to satisfy mypy\n\n```FIXED_CODE\n}\n\nDEPRIORITIZE_QUERIES = {}\ncache: dict = {}\n\n# Model configuration\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n\nWARNINGS: None\n===== END FIX =====\n```\n(Note: The output preserves the exact same trailing newline as the input)\n\n## Example - Preserving Trailing Whitespace\n\nInput snippet ending with blank lines (note the TWO newlines after the return statement):\n```\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n\n\n```\n\nCORRECT - Preserves both trailing newlines:\n```FIXED_CODE\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n\n\n```\n(Output MUST have the same TWO trailing newlines)\n\nWRONG - Trimming trailing newlines:\n```FIXED_CODE\ndef get_clerk_settings() -> ClerkSettings:\n    # Load Clerk token validation settings from config helpers\n    return ClerkSettings.from_config()\n```\n^ This is WRONG because it removed trailing newlines. The snippet MUST end with the same whitespace as the input.\n\n## Example - WRONG (Deleting Unrelated Content)\n\nIf the input snippet contains documentation or other code, you MUST preserve it:\n\nWRONG - Deleting unrelated lines:\n```FIXED_CODE\ncache: dict = {}\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n```\n^ This is WRONG because it deleted the closing brace, blank lines, DEPRIORITIZE_QUERIES, and the comment.\n\n## Confidence Guidelines\n- High (>0.8): Simple fixes like type annotations, obvious corrections\n- Medium (0.5-0.8): Logic changes, type guards, refactoring\n- Low (<0.5): Complex changes, unclear intent - add detailed warnings\n\n\n\n## Pydocstyle Docstring Error Fixing - Specialized Guidance\n\nYou are fixing MISSING DOCSTRINGS detected by pydocstyle.\n\nRisk Level: LOW\nAdding docstrings improves code maintainability without changing behavior.\n\nSupported Error Codes:\n- D101: Missing docstring in public class\n- D102: Missing docstring in public method\n- D103: Missing docstring in public function\n\nContext Structure:\nYou will receive:\n1. **Edit Snippet**: Opening lines of the class/function (signature + ~6 lines)\n   - This is where you ADD the docstring\n   - Return the edit snippet with docstring inserted after signature\n2. **Enclosing Function/Class Context**: Full implementation (read-only)\n   - Use this to understand what to document\n   - See parameters, return values, logic, side effects\n3. **Imports**: For understanding type hints and dependencies\n\nDocstring Style - Google Format:\nWe use Google-style docstrings. Follow this format:\n\n**For Classes (D101):**\n```python\nclass ClassName:\n    \"\"\"Brief one-line summary of the class purpose.\n\n    Longer description if needed to explain the class behavior,\n    state management, or important usage notes.\n\n    Attributes:\n        attr1: Description of attribute1\n        attr2: Description of attribute2\n    \"\"\"\n```\n\n**For Functions/Methods (D102/D103):**\n```python\ndef function_name(param1: str, param2: int) -> bool:\n    \"\"\"Brief one-line summary of what the function does.\n\n    Longer description if needed to explain the algorithm,\n    side effects, or important usage notes.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ExceptionType: When this exception is raised\n    \"\"\"\n```\n\nDocstring Writing Guidelines:\n\n1. **First Line (Summary)**:\n   - One concise sentence describing the purpose\n   - Start with a verb (imperative mood): \"Calculate...\", \"Create...\", \"Process...\"\n   - End with a period\n   - Should be ~50-80 characters\n\n2. **Args Section** (if function has parameters):\n   - List each parameter with its purpose\n   - Use type hints from signature (don't repeat them)\n   - Explain what the parameter represents, not just its type\n\n3. **Returns Section** (if function returns a value):\n   - Describe what is returned\n   - Explain meaning, not just the type\n\n4. **Raises Section** (only if function raises exceptions):\n   - Document exceptions explicitly raised in the code\n   - Don't document every possible exception\n\n5. **Keep It Concise**:\n   - Avoid redundant information\n   - Don't just restate the function name\n   - Focus on WHY and WHAT, not HOW (code shows how)\n\nSpecial Cases:\n\n**Properties**: Often just need one line\n```python\n@property\ndef is_active(self) -> bool:\n    \"\"\"Check if user account is currently active.\"\"\"\n```\n\n**Simple setters/getters**: Can be very brief\n```python\ndef set_name(self, name: str) -> None:\n    \"\"\"Set user's display name.\"\"\"\n```\n\n**Private methods (_method)**: Still document if non-trivial\n```python\ndef _validate_email(self, email: str) -> bool:\n    \"\"\"Validate email format using regex pattern.\"\"\"\n```\n\nFixing Strategy:\n\n1. **Analyze the Code Context**:\n   - Look at the full function/class implementation\n   - Understand parameters, return values, logic\n   - Identify any exceptions raised\n   - Note any decorators (@property, @dataclass, etc.)\n\n2. **Write Concise Documentation**:\n   - Start with clear one-line summary\n   - Add Args/Returns sections if needed\n   - Keep it brief but informative\n\n3. **Insert Docstring Correctly**:\n   - Place immediately after class/function signature\n   - Use triple quotes (\"\"\")\n   - Maintain proper indentation\n   - Add blank line after docstring (if more code follows)\n\n4. **Preserve Everything Else**:\n   - Don't modify decorators\n   - Don't change function signature\n   - Don't alter implementation\n   - Only ADD the docstring\n\nConfidence Guidelines:\n- High (>0.8): Simple functions with clear purpose from signature\n- Medium (0.5-0.8): Complex functions, multiple parameters\n- Low (<0.5): Unclear purpose, needs domain knowledge\n\nNEVER do these:\n\u274c Change function signature or implementation\n\u274c Remove or modify decorators\n\u274c Add type hints (they should already be there)\n\u274c Reformat unrelated code\n\u274c Write vague docstrings like \"This function does stuff\"\n\u274c Copy the function name into the docstring without adding value\n\nRemember: You're only adding documentation. The code behavior must not change.\nYour edit snippet should be IDENTICAL except for the added docstring.\n",
    "user_prompt": "Tool: pydocstyle\nSignal Type: docstring\nNumber of Signals: 3\n\n============================================================\nSIGNAL 1\n============================================================\n\n## Error Information\n- File: ria/views.py\n- Message: Missing docstring in public class\n- Rule Code: D101\n- Severity: low\n- Location: Line 475, Column 0\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 473-478 (error on line 3 of 6)\n```python\n\n\nclass RIALocationMetadataView(AsyncAPIView):\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 445-505\n```python\n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['countries'])} distinct countries\")\n            \n            return Response({\"countries\": location_data[\"countries\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get countries: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load countries\")\n\n\nclass RIACitiesView(AsyncAPIView):\n    \"\"\"GET /ria/metadata/cities - Get all distinct cities for dropdown.\"\"\"\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for cities.\"\"\"\n        logger.info(\"RIA cities metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['cities'])} distinct cities\")\n            \n            return Response({\"cities\": location_data[\"cities\"]}, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get cities: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load cities\")\n\n\nclass RIALocationMetadataView(AsyncAPIView):\n    permission_classes = [IsAuthenticated]\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for location metadata.\"\"\"\n        logger.info(\"RIA location metadata request\")\n        \n        try:\n            location_cache = get_location_cache()\n            location_data = location_cache.get_location_data()\n            logger.info(f\"Returning {len(location_data['countries'])} countries and {len(location_data['cities'])} cities\")\n            \n            serializer = RIALocationMetadataSerializer(data=location_data)\n            serializer.is_valid()\n            \n            return Response(serializer.data, status=status.HTTP_200_OK)\n        except Exception as e:\n            logger.error(f\"Failed to get location metadata: {str(e)}\", exc_info=True)\n            raise APIException(detail=\"Failed to load location metadata\")\n\n\n# ============================================================================\n# Debug Endpoint\n# ============================================================================\n\nclass RIADebugS3View(AsyncAPIView):\n    \"\"\"GET /ria/debug/s3 - Debug endpoint to test S3 access and configuration.\"\"\"\n    permission_classes = [IsAuthenticated]  # TODO: Add admin check\n    \n    async def get(self, request: Request):\n        \"\"\"Handle GET request for S3 debug info.\"\"\"\n\n```\n\n## Imports\n```python\n\"\"\"\nDjango REST Framework views for RIA API.\n\nConverted from FastAPI routes in prospecting_api.py.\nAll views use class-based approach with Django async support.\n\"\"\"\n\nimport json\nimport io\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nimport boto3\nimport polars as pl\nfrom botocore.exceptions import ClientError\nfrom django.http import StreamingHttpResponse, FileResponse\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom authentication.permissions import IsAdmin\nfrom rest_framework.exceptions import NotFound, PermissionDenied, ValidationError, APIException\nfrom rest_framework.request import Request\nfrom common.views import AsyncAPIView\n\nfrom ria.serializers import (\n\n```\n\n## Class Definition\nLines 473-475\n```python\n\n\nclass RIALocationMetadataView(AsyncAPIView):\n\n```\n\n\n============================================================\nSIGNAL 2\n============================================================\n\n## Error Information\n- File: ria/services/search_service.py\n- Message: Missing docstring in public method\n- Rule Code: D102\n- Severity: low\n- Location: Line 274, Column 0\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 272-317 (error on line 3 of 46)\n```python\n    \n@staticmethod\ndef search_companies(\n    name: Optional[str] = None,\n    domain: Optional[str] = None,\n    state: Optional[str] = None,\n    city: Optional[str] = None,\n    country: Optional[str] = None,\n    min_aum: Optional[float] = None,\n    max_aum: Optional[float] = None,\n    min_discretionary_aum: Optional[float] = None,\n    max_discretionary_aum: Optional[float] = None,\n    min_non_discretionary_aum: Optional[float] = None,\n    max_non_discretionary_aum: Optional[float] = None,\n    min_total_employees: Optional[int] = None,\n    max_total_employees: Optional[int] = None,\n    min_total_offices: Optional[int] = None,\n    max_total_offices: Optional[int] = None,\n    # Client type filters (Y/N)\n    individual_clients: Optional[str] = None,\n    high_net_worth_clients: Optional[str] = None,\n    banking_clients: Optional[str] = None,\n    investment_companies_clients: Optional[str] = None,\n    pension_clients: Optional[str] = None,\n    charity_clients: Optional[str] = None,\n    state_municipal_clients: Optional[str] = None,\n    investment_advisor_clients: Optional[str] = None,\n    insurance_clients: Optional[str] = None,\n    sovereign_wealth_clients: Optional[str] = None,\n    corporate_clients: Optional[str] = None,\n    # Private funds filter\n    private_funds: Optional[str] = None,\n    # Asset class filters (Y/N)\n    has_hedge_funds: Optional[str] = None,\n    has_liquidity_funds: Optional[str] = None,\n    has_pe_funds: Optional[str] = None,\n    has_real_estate_funds: Optional[str] = None,\n    has_securitized_funds: Optional[str] = None,\n    has_vc_funds: Optional[str] = None,\n    has_other_funds: Optional[str] = None,\n    limit: int = 10,\n    offset: int = 0,\n) -> Dict[str, Any]:\n    # Load index data\n    index_cache = get_index_cache()\n    df = index_cache.load()\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 244-304\n```python\n        if ensemble_score >= 0.6:\n            company['match_score'] = round(ensemble_score, 3)\n            company['match_details'] = {\n                'ratio': round(scores['ratio'], 3),\n                'partial_ratio': round(scores['partial_ratio'], 3),\n                'token_sort_ratio': round(scores['token_sort_ratio'], 3),\n                'token_set_ratio': round(scores['token_set_ratio'], 3)\n            }\n            scored_matches.append(company)\n    \n    # Sort by ensemble score (highest first)\n    scored_matches.sort(key=lambda x: x['match_score'], reverse=True)\n    \n    # Quality over quantity: return only strong matches\n    # If we have 2 strong matches (0.9+) and 8 weak ones (0.6-0.7), return only the 2 strong ones\n    strong_matches = [m for m in scored_matches if m['match_score'] >= 0.8]\n    if len(strong_matches) >= 2:\n        logger.info(f\"Found {len(strong_matches)} strong matches (\u22650.8), returning only strong matches\")\n        return strong_matches[:max_results]\n    \n    # Otherwise, return top matches up to the limit\n    result_count = min(len(scored_matches), max_results)\n    logger.info(f\"Found {len(scored_matches)} total matches, returning top {result_count} (scores: {[m['match_score'] for m in scored_matches[:result_count]]})\")\n    \n    return scored_matches[:result_count]\n\n\nclass SearchService:\n    \n    @staticmethod\n    def search_companies(\n        name: Optional[str] = None,\n        domain: Optional[str] = None,\n        state: Optional[str] = None,\n        city: Optional[str] = None,\n        country: Optional[str] = None,\n        min_aum: Optional[float] = None,\n        max_aum: Optional[float] = None,\n        min_discretionary_aum: Optional[float] = None,\n        max_discretionary_aum: Optional[float] = None,\n        min_non_discretionary_aum: Optional[float] = None,\n        max_non_discretionary_aum: Optional[float] = None,\n        min_total_employees: Optional[int] = None,\n        max_total_employees: Optional[int] = None,\n        min_total_offices: Optional[int] = None,\n        max_total_offices: Optional[int] = None,\n        # Client type filters (Y/N)\n        individual_clients: Optional[str] = None,\n        high_net_worth_clients: Optional[str] = None,\n        banking_clients: Optional[str] = None,\n        investment_companies_clients: Optional[str] = None,\n        pension_clients: Optional[str] = None,\n        charity_clients: Optional[str] = None,\n        state_municipal_clients: Optional[str] = None,\n        investment_advisor_clients: Optional[str] = None,\n        insurance_clients: Optional[str] = None,\n        sovereign_wealth_clients: Optional[str] = None,\n        corporate_clients: Optional[str] = None,\n        # Private funds filter\n        private_funds: Optional[str] = None,\n        # Asset class filters (Y/N)\n\n```\n\n## Imports\n```python\n\"\"\"\nSearch Service\n\nThis service handles all search and filtering operations for RIA data.\nIncludes intelligent fuzzy matching and comprehensive filtering logic.\n\"\"\"\n\nfrom typing import Dict, Any, List, Optional\nfrom urllib.parse import urlparse\n\nimport polars as pl\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.utils.constants import (\n\n```\n\n## Enclosing Function\nLines 272-442\n```python\n    \n    @staticmethod\n    def search_companies(\n        name: Optional[str] = None,\n        domain: Optional[str] = None,\n        state: Optional[str] = None,\n        city: Optional[str] = None,\n        country: Optional[str] = None,\n        min_aum: Optional[float] = None,\n        max_aum: Optional[float] = None,\n        min_discretionary_aum: Optional[float] = None,\n        max_discretionary_aum: Optional[float] = None,\n        min_non_discretionary_aum: Optional[float] = None,\n        max_non_discretionary_aum: Optional[float] = None,\n        min_total_employees: Optional[int] = None,\n        max_total_employees: Optional[int] = None,\n        min_total_offices: Optional[int] = None,\n        max_total_offices: Optional[int] = None,\n        # Client type filters (Y/N)\n        individual_clients: Optional[str] = None,\n        high_net_worth_clients: Optional[str] = None,\n        banking_clients: Optional[str] = None,\n        investment_companies_clients: Optional[str] = None,\n        pension_clients: Optional[str] = None,\n        charity_clients: Optional[str] = None,\n        state_municipal_clients: Optional[str] = None,\n        investment_advisor_clients: Optional[str] = None,\n        insurance_clients: Optional[str] = None,\n        sovereign_wealth_clients: Optional[str] = None,\n        corporate_clients: Optional[str] = None,\n        # Private funds filter\n        private_funds: Optional[str] = None,\n        # Asset class filters (Y/N)\n        has_hedge_funds: Optional[str] = None,\n        has_liquidity_funds: Optional[str] = None,\n        has_pe_funds: Optional[str] = None,\n        has_real_estate_funds: Optional[str] = None,\n        has_securitized_funds: Optional[str] = None,\n        has_vc_funds: Optional[str] = None,\n        has_other_funds: Optional[str] = None,\n        limit: int = 10,\n        offset: int = 0,\n    ) -> Dict[str, Any]:\n        # Load index data\n        index_cache = get_index_cache()\n        df = index_cache.load()\n        \n        # Ensure required columns exist\n        required_columns = [\n            CRD_COLUMN, NAME_COLUMN, STATE_COLUMN, CITY_COLUMN, COUNTRY_COLUMN, DOMAIN_COLUMN,\n            AUM_COLUMN, DISCRETIONARY_AUM_COLUMN, NON_DISCRETIONARY_AUM_COLUMN,\n            EMPLOYEES_COLUMN, OFFICES_COLUMN\n        ] + list(CLIENT_TYPE_COLUMNS.values()) + list(FUND_COLUMNS.values())\n        \n        ensure_columns(df, required_columns)\n        \n        # Attach domain column\n        df_domain = attach_domain_column(df, DOMAIN_COLUMN)\n        \n        # Apply filters (name is not used in filtering - it's used for search after filtering)\n        filtered_df = filter_companies(\n            df_domain,\n            domain=domain,\n            state=state,\n            city=city,\n            country=country,\n            min_aum=min_aum,\n            max_aum=max_aum,\n            min_discretionary_aum=min_discretionary_aum,\n            max_discretionary_aum=max_discretionary_aum,\n            min_non_discretionary_aum=min_non_discretionary_aum,\n            max_non_discretionary_aum=max_non_discretionary_aum,\n            min_total_employees=min_total_employees,\n            max_total_employees=max_total_employees,\n            min_total_offices=min_total_offices,\n            max_total_offices=max_total_offices,\n            individual_clients=individual_clients,\n            high_net_worth_clients=high_net_worth_clients,\n            banking_clients=banking_clients,\n            investment_companies_clients=investment_companies_clients,\n            pension_clients=pension_clients,\n            charity_clients=charity_clients,\n            state_municipal_clients=state_municipal_clients,\n            investment_advisor_clients=investment_advisor_clients,\n            insurance_clients=insurance_clients,\n            sovereign_wealth_clients=sovereign_wealth_clients,\n            corporate_clients=corporate_clients,\n            private_funds=private_funds,\n            has_hedge_funds=has_hedge_funds,\n            has_liquidity_funds=has_liquidity_funds,\n            has_pe_funds=has_pe_funds,\n            has_real_estate_funds=has_real_estate_funds,\n            has_securitized_funds=has_securitized_funds,\n            has_vc_funds=has_vc_funds,\n            has_other_funds=has_other_funds,\n        )\n        \n        # Check if any rows remain after filtering\n        if filtered_df.is_empty():\n            return {\n                \"total_matches\": 0,\n                \"matches\": [],\n                \"pagination\": {\n                    \"offset\": offset,\n                    \"limit\": limit,\n                    \"has_more\": False,\n                    \"next_offset\": None,\n                    \"showing\": \"0 of 0\"\n                },\n                \"filter_status\": {\n                    \"applied_filters\": {},\n                    \"ignored_filters\": {},\n                    \"available_filters\": []\n                }\n            }\n        \n        # Handle name search with intelligent fuzzy matching (on filtered data)\n        if name:\n            logger.info(f\"Starting name search for: '{name}' on {filtered_df.height} filtered rows\")\n            # Get ALL matches first (no limit), then apply pagination\n            raw_matches = intelligent_name_search(filtered_df, name, 10000)  # Large number to get all matches\n            logger.info(f\"Name search '{name}' returned {len(raw_matches)} total matches\")\n            # Name search results are already sorted by similarity score (highest first)\n        else:\n            logger.info(f\"No name search, getting all results sorted by AUM from {filtered_df.height} filtered rows\")\n            # No name search, return filtered results sorted by AUM (descending)\n            filtered_df = filtered_df.sort(AUM_COLUMN, descending=True)\n            raw_matches = to_serializable_records(filtered_df, 10000)  # Large number to get all matches\n            logger.info(f\"Retrieved {len(raw_matches)} total matches from filtered data, sorted by AUM (descending)\")\n        \n        # Transform all matches to include display names and top 3 calculations\n        all_transformed_matches = []\n        for match in raw_matches:\n            transformed_match = transform_company_record_for_preview(match)\n            # Preserve match_score if present (for name searches)\n            if \"match_score\" in match:\n                transformed_match[\"match_score\"] = match[\"match_score\"]\n            if \"match_details\" in match:\n                transformed_match[\"match_details\"] = match[\"match_details\"]\n            all_transformed_matches.append(transformed_match)\n        \n        # Apply pagination to transformed results\n        total_matches = len(all_transformed_matches)\n        start_idx = offset\n        end_idx = offset + limit\n        matches = all_transformed_matches[start_idx:end_idx]\n        \n        # Calculate pagination metadata\n        has_more = end_idx < total_matches\n        next_offset = end_idx if has_more else None\n        \n        logger.info(f\"Pagination: showing {len(matches)} of {total_matches} total matches (offset={offset}, limit={limit})\")\n        \n        return {\n            \"total_matches\": total_matches,\n            \"matches\": matches,\n            \"pagination\": {\n                \"offset\": offset,\n                \"limit\": limit,\n                \"has_more\": has_more,\n                \"next_offset\": next_offset,\n                \"showing\": f\"{len(matches)} of {total_matches}\"\n            },\n            \"filter_status\": {\n                \"applied_filters\": {},\n                \"ignored_filters\": {},\n                \"available_filters\": []\n            }\n        }\n\n\n\n```\n\n\n============================================================\nSIGNAL 3\n============================================================\n\n## Error Information\n- File: ria/services/search_service.py\n- Message: Missing docstring in public function\n- Rule Code: D103\n- Severity: low\n- Location: Line 443, Column 0\n\n## Edit Snippet (FIX AND RETURN THIS)\nLines 441-481 (error on line 3 of 41)\n```python\n\n\ndef filter_companies(\n    df: pl.DataFrame,\n    domain: Optional[str] = None,\n    state: Optional[str] = None,\n    city: Optional[str] = None,\n    country: Optional[str] = None,\n    min_aum: Optional[float] = None,\n    max_aum: Optional[float] = None,\n    min_discretionary_aum: Optional[float] = None,\n    max_discretionary_aum: Optional[float] = None,\n    min_non_discretionary_aum: Optional[float] = None,\n    max_non_discretionary_aum: Optional[float] = None,\n    min_total_employees: Optional[int] = None,\n    max_total_employees: Optional[int] = None,\n    min_total_offices: Optional[int] = None,\n    max_total_offices: Optional[int] = None,\n    individual_clients: Optional[str] = None,\n    high_net_worth_clients: Optional[str] = None,\n    banking_clients: Optional[str] = None,\n    investment_companies_clients: Optional[str] = None,\n    pension_clients: Optional[str] = None,\n    charity_clients: Optional[str] = None,\n    state_municipal_clients: Optional[str] = None,\n    investment_advisor_clients: Optional[str] = None,\n    insurance_clients: Optional[str] = None,\n    sovereign_wealth_clients: Optional[str] = None,\n    corporate_clients: Optional[str] = None,\n    private_funds: Optional[str] = None,\n    has_hedge_funds: Optional[str] = None,\n    has_liquidity_funds: Optional[str] = None,\n    has_pe_funds: Optional[str] = None,\n    has_real_estate_funds: Optional[str] = None,\n    has_securitized_funds: Optional[str] = None,\n    has_vc_funds: Optional[str] = None,\n    has_other_funds: Optional[str] = None,\n) -> pl.DataFrame:\n    filtered_df = df\n    \n    # Location filters (exact match)\n\n```\n\n## Context Window (for understanding, DO NOT return)\nLines 413-473\n```python\n        # Apply pagination to transformed results\n        total_matches = len(all_transformed_matches)\n        start_idx = offset\n        end_idx = offset + limit\n        matches = all_transformed_matches[start_idx:end_idx]\n        \n        # Calculate pagination metadata\n        has_more = end_idx < total_matches\n        next_offset = end_idx if has_more else None\n        \n        logger.info(f\"Pagination: showing {len(matches)} of {total_matches} total matches (offset={offset}, limit={limit})\")\n        \n        return {\n            \"total_matches\": total_matches,\n            \"matches\": matches,\n            \"pagination\": {\n                \"offset\": offset,\n                \"limit\": limit,\n                \"has_more\": has_more,\n                \"next_offset\": next_offset,\n                \"showing\": f\"{len(matches)} of {total_matches}\"\n            },\n            \"filter_status\": {\n                \"applied_filters\": {},\n                \"ignored_filters\": {},\n                \"available_filters\": []\n            }\n        }\n\n\ndef filter_companies(\n    df: pl.DataFrame,\n    domain: Optional[str] = None,\n    state: Optional[str] = None,\n    city: Optional[str] = None,\n    country: Optional[str] = None,\n    min_aum: Optional[float] = None,\n    max_aum: Optional[float] = None,\n    min_discretionary_aum: Optional[float] = None,\n    max_discretionary_aum: Optional[float] = None,\n    min_non_discretionary_aum: Optional[float] = None,\n    max_non_discretionary_aum: Optional[float] = None,\n    min_total_employees: Optional[int] = None,\n    max_total_employees: Optional[int] = None,\n    min_total_offices: Optional[int] = None,\n    max_total_offices: Optional[int] = None,\n    individual_clients: Optional[str] = None,\n    high_net_worth_clients: Optional[str] = None,\n    banking_clients: Optional[str] = None,\n    investment_companies_clients: Optional[str] = None,\n    pension_clients: Optional[str] = None,\n    charity_clients: Optional[str] = None,\n    state_municipal_clients: Optional[str] = None,\n    investment_advisor_clients: Optional[str] = None,\n    insurance_clients: Optional[str] = None,\n    sovereign_wealth_clients: Optional[str] = None,\n    corporate_clients: Optional[str] = None,\n    private_funds: Optional[str] = None,\n    has_hedge_funds: Optional[str] = None,\n    has_liquidity_funds: Optional[str] = None,\n    has_pe_funds: Optional[str] = None,\n\n```\n\n## Imports\n```python\n\"\"\"\nSearch Service\n\nThis service handles all search and filtering operations for RIA data.\nIncludes intelligent fuzzy matching and comprehensive filtering logic.\n\"\"\"\n\nfrom typing import Dict, Any, List, Optional\nfrom urllib.parse import urlparse\n\nimport polars as pl\n\nfrom ria.services.index_cache_service import get_index_cache\nfrom ria.utils.constants import (\n\n```\n\n## Enclosing Function\nLines 441-715\n```python\n\n\ndef filter_companies(\n    df: pl.DataFrame,\n    domain: Optional[str] = None,\n    state: Optional[str] = None,\n    city: Optional[str] = None,\n    country: Optional[str] = None,\n    min_aum: Optional[float] = None,\n    max_aum: Optional[float] = None,\n    min_discretionary_aum: Optional[float] = None,\n    max_discretionary_aum: Optional[float] = None,\n    min_non_discretionary_aum: Optional[float] = None,\n    max_non_discretionary_aum: Optional[float] = None,\n    min_total_employees: Optional[int] = None,\n    max_total_employees: Optional[int] = None,\n    min_total_offices: Optional[int] = None,\n    max_total_offices: Optional[int] = None,\n    individual_clients: Optional[str] = None,\n    high_net_worth_clients: Optional[str] = None,\n    banking_clients: Optional[str] = None,\n    investment_companies_clients: Optional[str] = None,\n    pension_clients: Optional[str] = None,\n    charity_clients: Optional[str] = None,\n    state_municipal_clients: Optional[str] = None,\n    investment_advisor_clients: Optional[str] = None,\n    insurance_clients: Optional[str] = None,\n    sovereign_wealth_clients: Optional[str] = None,\n    corporate_clients: Optional[str] = None,\n    private_funds: Optional[str] = None,\n    has_hedge_funds: Optional[str] = None,\n    has_liquidity_funds: Optional[str] = None,\n    has_pe_funds: Optional[str] = None,\n    has_real_estate_funds: Optional[str] = None,\n    has_securitized_funds: Optional[str] = None,\n    has_vc_funds: Optional[str] = None,\n    has_other_funds: Optional[str] = None,\n) -> pl.DataFrame:\n    filtered_df = df\n    \n    # Location filters (exact match)\n    if state and STATE_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(pl.col(STATE_COLUMN) == state)\n    \n    if city and CITY_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(pl.col(CITY_COLUMN).str.strip_chars() == city.strip())\n    \n    if country and COUNTRY_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(pl.col(COUNTRY_COLUMN).str.strip_chars() == country.strip())\n    \n    # AUM filters\n    if min_aum is not None and AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) >= min_aum\n        )\n    \n    if max_aum is not None and AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) <= max_aum\n        )\n    \n    if min_discretionary_aum is not None and DISCRETIONARY_AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(DISCRETIONARY_AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) >= min_discretionary_aum\n        )\n    \n    if max_discretionary_aum is not None and DISCRETIONARY_AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(DISCRETIONARY_AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) <= max_discretionary_aum\n        )\n    \n    if min_non_discretionary_aum is not None and NON_DISCRETIONARY_AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(NON_DISCRETIONARY_AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) >= min_non_discretionary_aum\n        )\n    \n    if max_non_discretionary_aum is not None and NON_DISCRETIONARY_AUM_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(NON_DISCRETIONARY_AUM_COLUMN).cast(pl.Float64, strict=False).fill_null(-1.0) <= max_non_discretionary_aum\n        )\n    \n    # Size filters\n    if min_total_employees is not None and EMPLOYEES_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(EMPLOYEES_COLUMN).cast(pl.Int64, strict=False).fill_null(-1) >= min_total_employees\n        )\n    \n    if max_total_employees is not None and EMPLOYEES_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(EMPLOYEES_COLUMN).cast(pl.Int64, strict=False).fill_null(-1) <= max_total_employees\n        )\n    \n    if min_total_offices is not None and OFFICES_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(OFFICES_COLUMN).cast(pl.Int64, strict=False).fill_null(-1) >= min_total_offices\n        )\n    \n    if max_total_offices is not None and OFFICES_COLUMN in df.columns:\n        filtered_df = filtered_df.filter(\n            pl.col(OFFICES_COLUMN).cast(pl.Int64, strict=False).fill_null(-1) <= max_total_offices\n        )\n    \n    # Client type filters (Y/N) - check for non-null, non-zero numeric values\n    # Handle both string and numeric column types\n    client_type_filters = {\n        \"individual_clients\": individual_clients,\n        \"high_net_worth_clients\": high_net_worth_clients,\n        \"banking_clients\": banking_clients,\n        \"investment_companies_clients\": investment_companies_clients,\n        \"pension_clients\": pension_clients,\n        \"charity_clients\": charity_clients,\n        \"state_municipal_clients\": state_municipal_clients,\n        \"investment_advisor_clients\": investment_advisor_clients,\n        \"insurance_clients\": insurance_clients,\n        \"sovereign_wealth_clients\": sovereign_wealth_clients,\n        \"corporate_clients\": corporate_clients,\n    }\n    \n    for filter_name, filter_value in client_type_filters.items():\n        if filter_value is not None:\n            yn_value = filter_value.strip().upper()\n            if yn_value in ['Y', 'N']:\n                column_name = CLIENT_TYPE_COLUMNS[filter_name]\n                if column_name in filtered_df.columns:\n                    try:\n                        # Check column type - handle both string and numeric\n                        column_dtype = filtered_df.schema[column_name]\n                        is_string_type = column_dtype == pl.Utf8\n                        \n                        if yn_value == \"Y\":\n                            # Check for non-null, non-zero value\n                            if is_string_type:\n                                # Convert string to numeric for comparison, handling invalid values\n                                filtered_df = filtered_df.filter(\n                                    pl.col(column_name).is_not_null() & \n                                    (pl.col(column_name).cast(pl.Int64, strict=False) > 0)\n                                )\n                            else:\n                                # Already numeric, use direct comparison\n                                filtered_df = filtered_df.filter(\n                                    pl.col(column_name).is_not_null() & (pl.col(column_name) > 0)\n                                )\n                        elif yn_value == \"N\":\n                            # Check for null or zero value\n                            if is_string_type:\n                                # Convert string to numeric for comparison, handling invalid values\n                                filtered_df = filtered_df.filter(\n                                    pl.col(column_name).is_null() | \n                                    (pl.col(column_name).cast(pl.Int64, strict=False) == 0) |\n                                    (pl.col(column_name).cast(pl.Int64, strict=False).is_null())\n                                )\n                            else:\n                                # Already numeric, use direct comparison\n                                filtered_df = filtered_df.filter(\n                                    pl.col(column_name).is_null() | (pl.col(column_name) == 0)\n                                )\n                    except Exception as e:\n                        # Log error but continue with other filters\n                        logger.warning(\n                            f\"Error filtering by {filter_name} (column {column_name}): {str(e)}. \"\n                            f\"Skipping this filter.\"\n                        )\n                        continue\n    \n    # Private funds and asset class filters (Y/N)\n    fund_filters = {\n        \"private_funds\": private_funds,\n        \"has_hedge_funds\": has_hedge_funds,\n        \"has_liquidity_funds\": has_liquidity_funds,\n        \"has_pe_funds\": has_pe_funds,\n        \"has_real_estate_funds\": has_real_estate_funds,\n        \"has_securitized_funds\": has_securitized_funds,\n        \"has_vc_funds\": has_vc_funds,\n        \"has_other_funds\": has_other_funds,\n    }\n    \n    for filter_name, filter_value in fund_filters.items():\n        if filter_value is not None:\n            yn_value = filter_value.strip().upper()\n            if yn_value in ['Y', 'N']:\n                if filter_name == \"private_funds\":\n                    # Special handling for private funds - check both 7B(1) and 7B(2) columns\n                    column_7b1 = \"Count of Private Funds - 7B(1)\"\n                    column_7b2 = \"Count of Private Funds - 7B(2)\"\n                    if column_7b1 in filtered_df.columns and column_7b2 in filtered_df.columns:\n                        try:\n                            # Check column types - handle both string and numeric\n                            dtype_7b1 = filtered_df.schema[column_7b1]\n                            dtype_7b2 = filtered_df.schema[column_7b2]\n                            is_string_7b1 = dtype_7b1 == pl.Utf8\n                            is_string_7b2 = dtype_7b2 == pl.Utf8\n                            \n                            if yn_value == \"Y\":\n                                # Check if either column has a non-null, non-zero value\n                                if is_string_7b1 and is_string_7b2:\n                                    # Both are strings, convert to numeric\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_not_null() & (pl.col(column_7b1).cast(pl.Int64, strict=False) > 0)) |\n                                        (pl.col(column_7b2).is_not_null() & (pl.col(column_7b2).cast(pl.Int64, strict=False) > 0))\n                                    )\n                                elif is_string_7b1:\n                                    # Only 7b1 is string\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_not_null() & (pl.col(column_7b1).cast(pl.Int64, strict=False) > 0)) |\n                                        (pl.col(column_7b2).is_not_null() & (pl.col(column_7b2) > 0))\n                                    )\n                                elif is_string_7b2:\n                                    # Only 7b2 is string\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_not_null() & (pl.col(column_7b1) > 0)) |\n                                        (pl.col(column_7b2).is_not_null() & (pl.col(column_7b2).cast(pl.Int64, strict=False) > 0))\n                                    )\n                                else:\n                                    # Both are numeric\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_not_null() & (pl.col(column_7b1) > 0)) |\n                                        (pl.col(column_7b2).is_not_null() & (pl.col(column_7b2) > 0))\n                                    )\n                            elif yn_value == \"N\":\n                                # Check if both columns are null or zero\n                                if is_string_7b1 and is_string_7b2:\n                                    # Both are strings, convert to numeric\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_null() | (pl.col(column_7b1).cast(pl.Int64, strict=False) == 0) | (pl.col(column_7b1).cast(pl.Int64, strict=False).is_null())) &\n                                        (pl.col(column_7b2).is_null() | (pl.col(column_7b2).cast(pl.Int64, strict=False) == 0) | (pl.col(column_7b2).cast(pl.Int64, strict=False).is_null()))\n                                    )\n                                elif is_string_7b1:\n                                    # Only 7b1 is string\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_null() | (pl.col(column_7b1).cast(pl.Int64, strict=False) == 0) | (pl.col(column_7b1).cast(pl.Int64, strict=False).is_null())) &\n                                        (pl.col(column_7b2).is_null() | (pl.col(column_7b2) == 0))\n                                    )\n                                elif is_string_7b2:\n                                    # Only 7b2 is string\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_null() | (pl.col(column_7b1) == 0)) &\n                                        (pl.col(column_7b2).is_null() | (pl.col(column_7b2).cast(pl.Int64, strict=False) == 0) | (pl.col(column_7b2).cast(pl.Int64, strict=False).is_null()))\n                                    )\n                                else:\n                                    # Both are numeric\n                                    filtered_df = filtered_df.filter(\n                                        (pl.col(column_7b1).is_null() | (pl.col(column_7b1) == 0)) &\n                                        (pl.col(column_7b2).is_null() | (pl.col(column_7b2) == 0))\n                                    )\n                        except Exception as e:\n                            # Log error but continue with other filters\n                            logger.warning(\n                                f\"Error filtering by private_funds (columns {column_7b1}, {column_7b2}): {str(e)}. \"\n                                f\"Skipping this filter.\"\n                            )\n                            continue\n                else:\n                    # Standard fund filter logic for asset class filters (Y/N strings)\n                    column_name = FUND_COLUMNS[filter_name]\n                    if column_name in filtered_df.columns:\n                        try:\n                            filtered_df = filtered_df.filter(\n                                pl.col(column_name).str.strip_chars().str.to_uppercase() == yn_value\n                            )\n                        except Exception as e:\n                            # Log error but continue with other filters\n                            logger.warning(\n                                f\"Error filtering by {filter_name} (column {column_name}): {str(e)}. \"\n                                f\"Skipping this filter.\"\n                            )\n                            continue\n    \n    # Domain filter (exact match on canonicalized domain)\n    if domain:\n        domain_norm = canonicalize_domain(domain)\n        if domain_norm and \"__domain\" in filtered_df.columns:\n            filtered_df = filtered_df.filter(pl.col(\"__domain\") == domain_norm)\n    \n    return filtered_df\n\n\n```\n\n\nPlease provide fixes for the above signals using the specified response format."
  },
  "llm_response": [
    "===== FIX FOR: ria/views.py =====\n",
    "CONFIDENCE: 0.9\n",
    "REASONING: Added docstring for RIALocationMetadataView class describing its purpose as a REST API endpoint for location metadata\n",
    "\n",
    "```FIXED_CODE\n",
    "\n",
    "\n",
    "class RIALocationMetadataView(AsyncAPIView):\n",
    "    \"\"\"GET /ria/metadata/location - Get combined location metadata (countries and cities).\"\"\"\n",
    "    permission_classes = [IsAuthenticated]\n",
    "    \n",
    "    async def get(self, request: Request):\n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: ria/services/search_service.py =====\n",
    "CONFIDENCE: 0.85\n",
    "REASONING: Added comprehensive docstring for search_companies method describing its purpose, parameters, and return value\n",
    "\n",
    "```FIXED_CODE\n",
    "    \n",
    "@staticmethod\n",
    "def search_companies(\n",
    "    name: Optional[str] = None,\n",
    "    domain: Optional[str] = None,\n",
    "    state: Optional[str] = None,\n",
    "    city: Optional[str] = None,\n",
    "    country: Optional[str] = None,\n",
    "    min_aum: Optional[float] = None,\n",
    "    max_aum: Optional[float] = None,\n",
    "    min_discretionary_aum: Optional[float] = None,\n",
    "    max_discretionary_aum: Optional[float] = None,\n",
    "    min_non_discretionary_aum: Optional[float] = None,\n",
    "    max_non_discretionary_aum: Optional[float] = None,\n",
    "    min_total_employees: Optional[int] = None,\n",
    "    max_total_employees: Optional[int] = None,\n",
    "    min_total_offices: Optional[int] = None,\n",
    "    max_total_offices: Optional[int] = None,\n",
    "    # Client type filters (Y/N)\n",
    "    individual_clients: Optional[str] = None,\n",
    "    high_net_worth_clients: Optional[str] = None,\n",
    "    banking_clients: Optional[str] = None,\n",
    "    investment_companies_clients: Optional[str] = None,\n",
    "    pension_clients: Optional[str] = None,\n",
    "    charity_clients: Optional[str] = None,\n",
    "    state_municipal_clients: Optional[str] = None,\n",
    "    investment_advisor_clients: Optional[str] = None,\n",
    "    insurance_clients: Optional[str] = None,\n",
    "    sovereign_wealth_clients: Optional[str] = None,\n",
    "    corporate_clients: Optional[str] = None,\n",
    "    # Private funds filter\n",
    "    private_funds: Optional[str] = None,\n",
    "    # Asset class filters (Y/N)\n",
    "    has_hedge_funds: Optional[str] = None,\n",
    "    has_liquidity_funds: Optional[str] = None,\n",
    "    has_pe_funds: Optional[str] = None,\n",
    "    has_real_estate_funds: Optional[str] = None,\n",
    "    has_securitized_funds: Optional[str] = None,\n",
    "    has_vc_funds: Optional[str] = None,\n",
    "    has_other_funds: Optional[str] = None,\n",
    "    limit: int = 10,\n",
    "    offset: int = 0,\n",
    ") -> Dict[str, Any]:\n",
    "    \"\"\"Search and filter RIA companies with intelligent fuzzy name matching.\n",
    "\n",
    "    Applies comprehensive filtering on company data including location, AUM ranges,\n",
    "    employee counts, client types, and fund types. Supports intelligent fuzzy\n",
    "    name matching with similarity scoring when name parameter is provided.\n",
    "\n",
    "    Args:\n",
    "        name: Company name for fuzzy search matching\n",
    "        domain: Exact domain match filter\n",
    "        state: Exact state match filter\n",
    "        city: Exact city match filter\n",
    "        country: Exact country match filter\n",
    "        min_aum: Minimum assets under management\n",
    "        max_aum: Maximum assets under management\n",
    "        min_discretionary_aum: Minimum discretionary AUM\n",
    "        max_discretionary_aum: Maximum discretionary AUM\n",
    "        min_non_discretionary_aum: Minimum non-discretionary AUM\n",
    "        max_non_discretionary_aum: Maximum non-discretionary AUM\n",
    "        min_total_employees: Minimum employee count\n",
    "        max_total_employees: Maximum employee count\n",
    "        min_total_offices: Minimum office count\n",
    "        max_total_offices: Maximum office count\n",
    "        individual_clients: Filter by individual clients (Y/N)\n",
    "        high_net_worth_clients: Filter by high net worth clients (Y/N)\n",
    "        banking_clients: Filter by banking clients (Y/N)\n",
    "        investment_companies_clients: Filter by investment company clients (Y/N)\n",
    "        pension_clients: Filter by pension clients (Y/N)\n",
    "        charity_clients: Filter by charity clients (Y/N)\n",
    "        state_municipal_clients: Filter by state/municipal clients (Y/N)\n",
    "        investment_advisor_clients: Filter by investment advisor clients (Y/N)\n",
    "        insurance_clients: Filter by insurance clients (Y/N)\n",
    "        sovereign_wealth_clients: Filter by sovereign wealth clients (Y/N)\n",
    "        corporate_clients: Filter by corporate clients (Y/N)\n",
    "        private_funds: Filter by private funds presence (Y/N)\n",
    "        has_hedge_funds: Filter by hedge funds presence (Y/N)\n",
    "        has_liquidity_funds: Filter by liquidity funds presence (Y/N)\n",
    "        has_pe_funds: Filter by private equity funds presence (Y/N)\n",
    "        has_real_estate_funds: Filter by real estate funds presence (Y/N)\n",
    "        has_securitized_funds: Filter by securitized funds presence (Y/N)\n",
    "        has_vc_funds: Filter by venture capital funds presence (Y/N)\n",
    "        has_other_funds: Filter by other funds presence (Y/N)\n",
    "        limit: Maximum number of results to return\n",
    "        offset: Number of results to skip for pagination\n",
    "\n",
    "    Returns:\n",
    "        Dictionary containing total matches, paginated results, pagination metadata,\n",
    "        and filter status information. Results include match scores for name searches.\n",
    "    \"\"\"\n",
    "    # Load index data\n",
    "    index_cache = get_index_cache()\n",
    "    df = index_cache.load()\n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX =====\n",
    "\n",
    "===== FIX FOR: ria/services/search_service.py =====\n",
    "CONFIDENCE: 0.9\n",
    "REASONING: Added comprehensive docstring for filter_companies function describing its filtering capabilities and parameters\n",
    "\n",
    "```FIXED_CODE\n",
    "\n",
    "\n",
    "def filter_companies(\n",
    "    df: pl.DataFrame,\n",
    "    domain: Optional[str] = None,\n",
    "    state: Optional[str] = None,\n",
    "    city: Optional[str] = None,\n",
    "    country: Optional[str] = None,\n",
    "    min_aum: Optional[float] = None,\n",
    "    max_aum: Optional[float] = None,\n",
    "    min_discretionary_aum: Optional[float] = None,\n",
    "    max_discretionary_aum: Optional[float] = None,\n",
    "    min_non_discretionary_aum: Optional[float] = None,\n",
    "    max_non_discretionary_aum: Optional[float] = None,\n",
    "    min_total_employees: Optional[int] = None,\n",
    "    max_total_employees: Optional[int] = None,\n",
    "    min_total_offices: Optional[int] = None,\n",
    "    max_total_offices: Optional[int] = None,\n",
    "    individual_clients: Optional[str] = None,\n",
    "    high_net_worth_clients: Optional[str] = None,\n",
    "    banking_clients: Optional[str] = None,\n",
    "    investment_companies_clients: Optional[str] = None,\n",
    "    pension_clients: Optional[str] = None,\n",
    "    charity_clients: Optional[str] = None,\n",
    "    state_municipal_clients: Optional[str] = None,\n",
    "    investment_advisor_clients: Optional[str] = None,\n",
    "    insurance_clients: Optional[str] = None,\n",
    "    sovereign_wealth_clients: Optional[str] = None,\n",
    "    corporate_clients: Optional[str] = None,\n",
    "    private_funds: Optional[str] = None,\n",
    "    has_hedge_funds: Optional[str] = None,\n",
    "    has_liquidity_funds: Optional[str] = None,\n",
    "    has_pe_funds: Optional[str] = None,\n",
    "    has_real_estate_funds: Optional[str] = None,\n",
    "    has_securitized_funds: Optional[str] = None,\n",
    "    has_vc_funds: Optional[str] = None,\n",
    "    has_other_funds: Optional[str] = None,\n",
    ") -> pl.DataFrame:\n",
    "    \"\"\"Filter RIA companies DataFrame based on multiple criteria.\n",
    "\n",
    "    Applies comprehensive filtering including location, financial metrics,\n",
    "    client types, and fund types. Handles both string and numeric column\n",
    "    types with proper type conversion and null value handling.\n",
    "\n",
    "    Args:\n",
    "        df: Input DataFrame containing RIA company data\n",
    "        domain: Filter by exact domain match\n",
    "        state: Filter by exact state match\n",
    "        city: Filter by exact city match\n",
    "        country: Filter by exact country match\n",
    "        min_aum: Minimum assets under management threshold\n",
    "        max_aum: Maximum assets under management threshold\n",
    "        min_discretionary_aum: Minimum discretionary AUM threshold\n",
    "        max_discretionary_aum: Maximum discretionary AUM threshold\n",
    "        min_non_discretionary_aum: Minimum non-discretionary AUM threshold\n",
    "        max_non_discretionary_aum: Maximum non-discretionary AUM threshold\n",
    "        min_total_employees: Minimum employee count threshold\n",
    "        max_total_employees: Maximum employee count threshold\n",
    "        min_total_offices: Minimum office count threshold\n",
    "        max_total_offices: Maximum office count threshold\n",
    "        individual_clients: Filter by individual clients presence (Y/N)\n",
    "        high_net_worth_clients: Filter by high net worth clients presence (Y/N)\n",
    "        banking_clients: Filter by banking clients presence (Y/N)\n",
    "        investment_companies_clients: Filter by investment company clients presence (Y/N)\n",
    "        pension_clients: Filter by pension clients presence (Y/N)\n",
    "        charity_clients: Filter by charity clients presence (Y/N)\n",
    "        state_municipal_clients: Filter by state/municipal clients presence (Y/N)\n",
    "        investment_advisor_clients: Filter by investment advisor clients presence (Y/N)\n",
    "        insurance_clients: Filter by insurance clients presence (Y/N)\n",
    "        sovereign_wealth_clients: Filter by sovereign wealth clients presence (Y/N)\n",
    "        corporate_clients: Filter by corporate clients presence (Y/N)\n",
    "        private_funds: Filter by private funds presence (Y/N)\n",
    "        has_hedge_funds: Filter by hedge funds presence (Y/N)\n",
    "        has_liquidity_funds: Filter by liquidity funds presence (Y/N)\n",
    "        has_pe_funds: Filter by private equity funds presence (Y/N)\n",
    "        has_real_estate_funds: Filter by real estate funds presence (Y/N)\n",
    "        has_securitized_funds: Filter by securitized funds presence (Y/N)\n",
    "        has_vc_funds: Filter by venture capital funds presence (Y/N)\n",
    "        has_other_funds: Filter by other funds presence (Y/N)\n",
    "\n",
    "    Returns:\n",
    "        Filtered DataFrame containing only companies matching all specified criteria.\n",
    "    \"\"\"\n",
    "    filtered_df = df\n",
    "    \n",
    "    # Location filters (exact match)\n",
    "\n",
    "```\n",
    "\n",
    "WARNINGS: None\n",
    "===== END FIX ====="
  ]
}