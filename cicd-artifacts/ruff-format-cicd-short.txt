--- app/agents/prospecting_orchestrator.py
+++ app/agents/prospecting_orchestrator.py
@@ -38,10 +38,11 @@
 
 logger = get_logger(__name__)
 
+
 # Session context data structure
 class SessionContext:
     """Session context for managing user interactions within a session."""
-    
+
     def __init__(self, session_id: str, user_id: str):
         self.session_id = session_id
         self.user_id = user_id
@@ -50,49 +51,50 @@
         self.status = "active"
         self.last_activity = datetime.now()
         self.ria_detection_result: Optional[Dict[str, Any]] = None
-    
+
     def increment_interaction(self) -> str:
         """Increment interaction counter and return run_id for this interaction."""
         self.interaction_count += 1
         self.last_activity = datetime.now()
         return f"{self.session_id}_{self.interaction_count:03d}"
-    
+
     def to_dict(self) -> Dict[str, Any]:
         """Convert session context to dictionary for storage."""
         return {
-            'session_id': self.session_id,
-            'user_id': self.user_id,
-            'start_time': self.start_time.isoformat(),
-            'interaction_count': self.interaction_count,
-            'status': self.status,
-            'last_activity': self.last_activity.isoformat()
+            "session_id": self.session_id,
+            "user_id": self.user_id,
+            "start_time": self.start_time.isoformat(),
+            "interaction_count": self.interaction_count,
+            "status": self.status,
+            "last_activity": self.last_activity.isoformat(),
         }
-    
+
     @classmethod
-    def from_dict(cls, data: Dict[str, Any]) -> 'SessionContext':
+    def from_dict(cls, data: Dict[str, Any]) -> "SessionContext":
         """Create session context from dictionary."""
-        session = cls(data['session_id'], data['user_id'])
-        session.start_time = datetime.fromisoformat(data['start_time'])
-        session.interaction_count = data['interaction_count']
-        session.status = data['status']
-        session.last_activity = datetime.fromisoformat(data['last_activity'])
+        session = cls(data["session_id"], data["user_id"])
+        session.start_time = datetime.fromisoformat(data["start_time"])
+        session.interaction_count = data["interaction_count"]
+        session.status = data["status"]
+        session.last_activity = datetime.fromisoformat(data["last_activity"])
         return session
 
+
 class PromptAnalyzer:
     """
     Analyzes user prompts to determine if they contain specific company names or general search requests.
     """
-    
+
     def __init__(self):
         self.llm = ChatOpenAI(model="gpt-4o-mini", temperature=0, api_key=get_openai_api_key())
-        
+
     async def analyze_prompt(self, prompt: str) -> Dict[str, Any]:
         """
         Analyze a user prompt to determine the type of request using LLM.
-        
-        Args:  
+
+        Args:
             prompt: User's input prompt
-            
+
         Returns:
             Dictionary with analysis results:
             - prompt_type: "specific_company", "general_search", or "off_topic"
@@ -104,67 +106,62 @@
             result = await self._llm_based_classification(prompt)
             logger.info("Prompt analysis completed", extra={"prompt_type": result.get("prompt_type"), "confidence": result.get("confidence", 0.0)})
             return result
-            
+
         except Exception as e:
             logger.exception("Prompt analysis failed")
             print(f"‚ö†Ô∏è Prompt analysis failed: {e}")
             # Fallback to off_topic classification
-            return {
-                'prompt_type': 'off_topic',
-                'confidence': 0.0,
-                'extracted_data': {}
-            }
-    
+            return {"prompt_type": "off_topic", "confidence": 0.0, "extracted_data": {}}
+
     async def _llm_based_classification(self, prompt: str) -> Dict[str, Any]:
         """
         Use LLM to classify the prompt into one of four categories.
         """
         system_prompt = get_prompt_analysis_system_prompt()
         user_prompt = f"Analyze this prompt: {prompt}"
-        
+
         try:
-            with trace_operation("prompt_analysis", {
-                "prompt_length": len(prompt),
-                "model": "gpt-4o-mini"
-            }):
+            with trace_operation("prompt_analysis", {"prompt_length": len(prompt), "model": "gpt-4o-mini"}):
                 messages = [SystemMessage(content=system_prompt), HumanMessage(content=user_prompt)]
                 response = await self.llm.ainvoke(messages)
-            
+
             # Parse JSON response
             response_text = response.content.strip()
-            if '```json' in response_text:
-                json_start = response_text.find('```json') + 7
-                json_end = response_text.find('```', json_start)
+            if "```json" in response_text:
+                json_start = response_text.find("```json") + 7
+                json_end = response_text.find("```", json_start)
                 response_text = response_text[json_start:json_end].strip()
-            
+
             result = json.loads(response_text)
-            
+
             # Add off_topic message if needed
-            if result['prompt_type'] == 'off_topic':
-                result['extracted_data']['message'] = "I can help you with company research in two ways:\n\n1. **Specific Company Research**: Provide a company name and I'll research and enrich that specific company (e.g., 'Research Sequoia Capital' or 'Tell me about BlackRock')\n\n2. **General Company Search**: Search for companies matching specific criteria (e.g., 'Find VC firms in London focusing on fintech' or 'Show me private equity firms in healthcare')\n\nPlease provide either a specific company name to research or search criteria for finding companies."
-            
+            if result["prompt_type"] == "off_topic":
+                result["extracted_data"]["message"] = (
+                    "I can help you with company research in two ways:\n\n1. **Specific Company Research**: Provide a company name and I'll research and enrich that specific company (e.g., 'Research Sequoia Capital' or 'Tell me about BlackRock')\n\n2. **General Company Search**: Search for companies matching specific criteria (e.g., 'Find VC firms in London focusing on fintech' or 'Show me private equity firms in healthcare')\n\nPlease provide either a specific company name to research or search criteria for finding companies."
+                )
+
             return result
-            
+
         except Exception as e:
             print(f"‚ö†Ô∏è LLM classification failed: {e}")
             return {
-                'prompt_type': 'off_topic',
-                'confidence': 0.0,
-                'extracted_data': {
-                    'message': "I can help you with company research in two ways:\n\n1. **Specific Company Research**: Provide a company name and I'll research and enrich that specific company (e.g., 'Research Sequoia Capital' or 'Tell me about BlackRock')\n\n2. **General Company Search**: Search for companies matching specific criteria (e.g., 'Find VC firms in London focusing on fintech' or 'Show me private equity firms in healthcare')\n\nPlease provide either a specific company name to research or search criteria for finding companies."
-                }
+                "prompt_type": "off_topic",
+                "confidence": 0.0,
+                "extracted_data": {
+                    "message": "I can help you with company research in two ways:\n\n1. **Specific Company Research**: Provide a company name and I'll research and enrich that specific company (e.g., 'Research Sequoia Capital' or 'Tell me about BlackRock')\n\n2. **General Company Search**: Search for companies matching specific criteria (e.g., 'Find VC firms in London focusing on fintech' or 'Show me private equity firms in healthcare')\n\nPlease provide either a specific company name to research or search criteria for finding companies."
+                },
             }
 
 
 class ProspectingOrchestrator:
     """
     Enhanced prospecting orchestrator that coordinates multiple sub-agents for comprehensive company research.
-    
+
     This orchestrator provides three main execution modes:
     1. execute_from_prompt(): Process natural language user prompts
     2. execute_from_data(): Process structured company data
     3. execute_hybrid(): Automatically choose the best approach
-    
+
     Features:
     - Intelligent prompt analysis and classification
     - Multi-agent coordination with error handling
@@ -172,11 +169,11 @@
     - Interactive mode for testing
     - MCP tool integration for enhanced capabilities
     """
-    
+
     def __init__(self, db=None, extractor_llm=None, output_dir="output/prospecting", enable_debugging: Optional[bool] = None):
         """
         Initialize the prospecting orchestrator with sub-agents and configuration.
-        
+
         Args:
             db: Optional database instance (will use global if not provided)
             extractor_llm: LangChain LLM instance for data extraction
@@ -1308,103 +1374,130 @@
                 found_urls = [found_url]
                 found_by_perplexity = False
                 print(f"üîÑ Using fallback URL: {found_url}")
-            
+
             # Generate company_id from primary domain
             company_id = generate_company_id_from_domain(found_url)
             print(f"üÜî Generated company_id: {company_id}")
-            
+
             return {
-                'success': True,
-                'company_id': company_id,
-                'found_url': found_url,
-                'found_urls': found_urls,
-                'domain_count': len(found_urls),
-                'found_by_perplexity': found_by_perplexity
+                "success": True,
+                "company_id": company_id,
+                "found_url": found_url,
+                "found_urls": found_urls,
+                "domain_count": len(found_urls),
+                "found_by_perplexity": found_by_perplexity,
             }
-            
+
         except Exception as e:
             error_msg = f"Domain discovery failed: {str(e)}"
             print(f"‚ùå {error_msg}")
-            
-            return {
-                'success': False,
-                'error': error_msg
-            }
 
-    async def _run_phase1_parallel(self, company_data: Dict, run_id: str, company_id: str, 
-                                 found_url: str, found_urls: List[str], found_by_perplexity: bool, 
-                                 shared_output_file: str, user_id: str = None, session_id: str = None) -> Dict[str, Any]:
+            return {"success": False, "error": error_msg}
+
+    async def _run_phase1_parallel(
+        self,
+        company_data: Dict,
+        run_id: str,
+        company_id: str,
+        found_url: str,
+        found_urls: List[str],
+        found_by_perplexity: bool,
+        shared_output_file: str,
+        user_id: str = None,
+        session_id: str = None,
+    ) -> Dict[str, Any]:
         """
         Phase 1: Run Web Research and CoreSignal agents in parallel.
         """
         logger.info("Phase 1 parallel execution started", extra={"run_id": run_id, "company_id": company_id})
         print("üîÑ Running Phase 1 agents in parallel...")
-        
+
         try:
             # Run both agents in parallel using asyncio.gather
-            web_research_task = self.sub_agents['web_research'].execute(
-                company_data, run_id=run_id, company_id=company_id,
-                found_url=found_url, found_urls=found_urls, found_by_perplexity=found_by_perplexity,
-                shared_output_file=shared_output_file, user_id=user_id, session_id=session_id
+            web_research_task = self.sub_agents["web_research"].execute(
+                company_data,
+                run_id=run_id,
+                company_id=company_id,
+                found_url=found_url,
+                found_urls=found_urls,
+                found_by_perplexity=found_by_perplexity,
+                shared_output_file=shared_output_file,
+                user_id=user_id,
+                session_id=session_id,
             )
-            
-            coresignal_task = self.sub_agents['coresignal'].execute(
-                company_data, run_id=run_id, company_id=company_id, 
-                found_url=found_url, found_urls=found_urls, user_id=user_id, session_id=session_id
+
+            coresignal_task = self.sub_agents["coresignal"].execute(
+                company_data, run_id=run_id, company_id=company_id, found_url=found_url, found_urls=found_urls, user_id=user_id, session_id=session_id
             )
 
-            youtube_task = self.sub_agents['youtube_media'].execute(
-                company_data, run_id=run_id, company_id=company_id,
-                shared_output_file=shared_output_file, db=self.db, postgres_enabled=get_enable_postgres_storage(),
-                user_id=user_id, session_id=session_id, youtube_url=found_url
+            youtube_task = self.sub_agents["youtube_media"].execute(
+                company_data,
+                run_id=run_id,
+                company_id=company_id,
+                shared_output_file=shared_output_file,
+                db=self.db,
+                postgres_enabled=get_enable_postgres_storage(),
+                user_id=user_id,
+                session_id=session_id,
+                youtube_url=found_url,
             )
-            
+
             # Wait for both to complete
             web_research_result, coresignal_result, youtube_result = await asyncio.gather(
                 web_research_task, coresignal_task, youtube_task, return_exceptions=True
             )
-            
+
             # Handle any exceptions
             if isinstance(web_research_result, Exception):
                 print(f"‚ùå Web Research Agent failed: {web_research_result}")
-                web_research_result = {'success': False, 'error': str(web_research_result)}
-            
+                web_research_result = {"success": False, "error": str(web_research_result)}
+
             if isinstance(coresignal_result, Exception):
                 print(f"‚ùå CoreSignal Agent failed: {coresignal_result}")
-                coresignal_result = {'success': False, 'error': str(coresignal_result)}
+                coresignal_result = {"success": False, "error": str(coresignal_result)}
 
             if isinstance(youtube_result, Exception):
                 print(f"‚ùå YouTube Media Agent failed: {youtube_result}")
-                youtube_result = {'success': False, 'error': str(youtube_result)}
-            
-            print(f"‚úÖ Phase 1 completed - Web Research: {'‚úÖ' if web_research_result.get('success') else '‚ùå'}, CoreSignal: {'‚úÖ' if coresignal_result.get('success') else '‚ùå'}, YouTube: {'‚úÖ' if youtube_result.get('success') else '‚ùå'}")
+                youtube_result = {"success": False, "error": str(youtube_result)}
 
-            logger.info("Phase 1 parallel execution completed", extra={
-                "run_id": run_id, 
-                "company_id": company_id, 
-                "web_research_success": web_research_result.get('success', False),
-                "coresignal_success": coresignal_result.get('success', False),
-                "youtube_success": youtube_result.get('success', False)
-            })
+            print(
+                f"‚úÖ Phase 1 completed - Web Research: {'‚úÖ' if web_research_result.get('success') else '‚ùå'}, CoreSignal: {'‚úÖ' if coresignal_result.get('success') else '‚ùå'}, YouTube: {'‚úÖ' if youtube_result.get('success') else '‚ùå'}"
+            )
 
+            logger.info(
+                "Phase 1 parallel execution completed",
+                extra={
+                    "run_id": run_id,
+                    "company_id": company_id,
+                    "web_research_success": web_research_result.get("success", False),
+                    "coresignal_success": coresignal_result.get("success", False),
+                    "youtube_success": youtube_result.get("success", False),
+                },
+            )
+
             return {
-                'success': True,
-                'web_research_result': web_research_result,
-                'coresignal_result': coresignal_result,
-                'youtube_result': youtube_result
+                "success": True,
+                "web_research_result": web_research_result,
+                "coresignal_result": coresignal_result,
+                "youtube_result": youtube_result,
             }
-            
+
         except Exception as e:
             error_msg = f"Phase 1 parallel execution failed: {str(e)}"
             print(f"‚ùå {error_msg}")
             logger.exception("Phase 1 parallel execution failed", extra={"run_id": run_id, "company_id": company_id})
-            return {
-                'success': False,
-                'error': error_msg
-            }
+            return {"success": False, "error": error_msg}
 
-    async def _run_phase2_parallel(self, company_data: Dict, run_id: str, company_id: str, 
-                                 shared_output_file: str, user_id: str, session_id: str, session_context: SessionContext) -> Dict[str, Any]:
+    async def _run_phase2_parallel(
+        self,
+        company_data: Dict,
+        run_id: str,
+        company_id: str,
+        shared_output_file: str,
+        user_id: str,
+        session_id: str,
+        session_context: SessionContext,
+    ) -> Dict[str, Any]:
         """
         Phase 2: Run Company Enrichment and Person Enrichment agents in parallel.
         """
@@ -1584,52 +1707,52 @@
         print("   ‚Ä¢ General search: 'Find VC firms in London focusing on fintech'")
         print("   ‚Ä¢ Off-topic: 'What's the weather like?'")
         print()
-        
+
         # Generate a unique user ID if not provided
         if not user_id:
             user_id = f"interactive_user_{int(time.time())}"
-        
+
         # Start a new session
         session_context = await self.start_session(user_id)
-        
+
         print(f"üë§ User ID: {user_id}")
         print(f"üÜî Session ID: {session_context.session_id}")
         print()
-        
+
         try:
             while True:
                 try:
                     # Get user input
                     prompt = input("üìù Enter your prompt: ").strip()
-                    
-                    if prompt.lower() in ['quit', 'exit', 'q']:
+
+                    if prompt.lower() in ["quit", "exit", "q"]:
                         print("üëã Goodbye!")
                         break
-                    
+
                     if not prompt:
                         print("‚ö†Ô∏è Please enter a valid prompt.")
                         continue
-                    
+
                     print(f"\nüîç Processing: '{prompt}'")
                     print("-" * 40)
-                    
+
                     # Execute the orchestrator with session context
                     result = await self.execute(prompt=prompt, user_id=user_id, session_context=session_context)
-                    
-                    if result['success']:
+
+                    if result["success"]:
                         print("‚úÖ Success!")
                         print(f"   Workflow Type: {result.get('workflow_type', 'unknown')}")
                         print(f"   Run ID: {result['run_id']}")
                         print(f"   Session ID: {result.get('session_id', 'N/A')}")
                         print(f"   Interaction #: {result.get('interaction_number', 'N/A')}")
-                        
-                        if result.get('workflow_type') == 'company_search':
+
+                        if result.get("workflow_type") == "company_search":
                             print(f"   Companies Found: {len(result.get('companies', []))}")
                             print(f"   Next Step: {result.get('next_step', 'N/A')}")
                             print(f"   Status: Waiting for company selection...")
-                            
+
                             # Handle company selection
-                            companies = result.get('companies', [])
+                            companies = result.get("companies", [])
                             if companies:
                                 print(f"\nüìã Available Companies ({len(companies)} found):")
                                 print("-" * 60)
@@ -1640,30 +1763,30 @@
                                     print(f"     Focus: {company.get('investor_focus', 'N/A')}")
                                     print(f"     Location: {company.get('location', 'N/A')}")
                                     print()
-                                
+
                                 # Get user selection
                                 while True:
                                     try:
                                         selection = input(f"üéØ Select a company to enrich (1-{len(companies)}) or 'skip': ").strip()
-                                        
-                                        if selection.lower() in ['skip', 's', 'no']:
+
+                                        if selection.lower() in ["skip", "s", "no"]:
                                             print("‚è≠Ô∏è Skipping company selection.")
                                             break
-                                        
+
                                         selected_index = int(selection)
                                         if 1 <= selected_index <= len(companies):
-                                            print(f"‚úÖ Selected company: {companies[selected_index-1].get('company_name')}")
+                                            print(f"‚úÖ Selected company: {companies[selected_index - 1].get('company_name')}")
                                             print("üîÑ Starting enrichment process...")
-                                            
+
                                             # Call the company selection handler with session context
                                             selection_result = await self.handle_user_company_selection(
-                                                run_id=result['run_id'],
+                                                run_id=result["run_id"],
                                                 user_id=user_id,
                                                 selected_company_index=selected_index,
-                                                session_context=session_context
+                                                session_context=session_context,
                                             )
-                                            
-                                            if selection_result['success']:
+
+                                            if selection_result["success"]:
                                                 print("‚úÖ Company enrichment completed!")
                                                 print(f"   Company: {selection_result.get('company_name', 'Unknown')}")
                                                 print(f"   Company ID: {selection_result.get('company_id', 'N/A')}")
@@ -1673,7 +1796,7 @@
                                             else:
                                                 print("‚ùå Company enrichment failed!")
                                                 print(f"   Error: {selection_result.get('error', 'Unknown error')}")
-                                            
+
                                             break
                                         else:
                                             print(f"‚ùå Please enter a number between 1 and {len(companies)}")
@@ -1682,35 +1805,36 @@
                                     except KeyboardInterrupt:
                                         print("\n‚è≠Ô∏è Skipping company selection.")
                                         break
-                        
-                        elif result.get('workflow_type') == 'off_topic':
+
+                        elif result.get("workflow_type") == "off_topic":
                             print(f"   Message: {result.get('message', 'No message provided')}")
                             print(f"   Next Step: {result.get('next_step', 'N/A')}")
                             print(f"   Status: Waiting for user input...")
                             print()
                             print("üí° The system is now waiting for your next prompt.")
                             print("   Try asking about a specific company or search criteria.")
-                            
-                        elif result.get('workflow_type') == 'specific_company':
+
+                        elif result.get("workflow_type") == "specific_company":
                             print(f"   Company: {result.get('company_name', 'Unknown')}")
                             print(f"   Company ID: {result.get('company_id', 'N/A')}")
                             print(f"   Output File: {result.get('output_file', 'N/A')}")
                             print(f"   Status: Enrichment completed!")
-                            
+
                     else:
                         print("‚ùå Failed!")
                         print(f"   Error: {result.get('error', 'Unknown error')}")
-                        
+
                 except KeyboardInterrupt:
                     print("\nüëã Goodbye!")
                     break
                 except Exception as e:
                     print(f"‚ùå Exception: {e}")
                     import traceback
+
                     traceback.print_exc()
-                
+
                 print("\n" + "=" * 60)
-        
+
         finally:
             # End the session when the loop exits
             await self.end_session(session_context)
@@ -1725,14 +1849,15 @@
     print("=" * 60)
     print("Starting interactive mode...")
     print()
-    
+
     # Generate a unique user ID for this session
     user_id = f"session_user_{int(time.time())}"
-    
+
     # Run interactive mode
     orchestrator = ProspectingOrchestrator()
     await orchestrator.execute_interactive(user_id=user_id)
 
+
 if __name__ == "__main__":
     try:
         asyncio.run(main())
@@ -1741,4 +1866,5 @@
     except Exception as e:
         print(f"‚ùå Error: {e}")
         import sys
-        sys.exit(1) 
+
+        sys.exit(1)

--- app/agents/sub_agents/__init__.py
+++ app/agents/sub_agents/__init__.py
@@ -7,4 +7,13 @@
 from .company_search_agent import CompanySearchAgent
 from .youtube_media_agent import YouTubeMediaAgent
 
-__all__ = ["WebResearchAgent", "UserPromptExtractorAgent", "BaseSubAgent", "CoreSignalSubAgent", "CompanyEnrichAgent", "PersonEnrichAgent", "CompanySearchAgent", "YouTubeMediaAgent"] 
+__all__ = [
+    "WebResearchAgent",
+    "UserPromptExtractorAgent",
+    "BaseSubAgent",
+    "CoreSignalSubAgent",
+    "CompanyEnrichAgent",
+    "PersonEnrichAgent",
+    "CompanySearchAgent",
+    "YouTubeMediaAgent",
+]

--- app/agents/sub_agents/base_sub_agent.py
+++ app/agents/sub_agents/base_sub_agent.py
@@ -8,12 +8,13 @@
 from bs4 import BeautifulSoup
 from app.utils.db_utils import ProspectingDB
 
+
 class BaseSubAgent(ABC):
     """
     Base class for modular sub-agents that perform specific prospecting tasks.
     Each sub-agent should be self-contained and output results to files.
     """
-    
+
     def __init__(self, output_dir: str = "output", db: Optional[ProspectingDB] = None):
         self.output_dir = Path(output_dir)
         self.output_dir.mkdir(exist_ok=True)
@@ -22,54 +23,54 @@
             print(f"üîó {self.__class__.__name__}: Initialized with database instance: {id(self.db)}")
         else:
             print(f"üîó {self.__class__.__name__}: Initialized without database, will use global instance when needed")
-    
+
     @abstractmethod
     async def execute(self, company_data: Dict[str, Any]) -> Dict[str, Any]:
         """
         Execute the sub-agent's specific task.
-        
+
         Args:
             company_data: Dictionary containing company information
                          (name, website, location, etc.)
-        
+
         Returns:
             Dictionary with execution results and output file paths
         """
         pass
-    
+
     async def save_output(self, content: str, filename: str) -> str:
         """
         Save content to a markdown file.
-        
+
         Args:
             content: Content to save
             filename: Name of the output file
-            
+
         Returns:
             Path to the saved file
         """
         file_path = self.output_dir / filename
-        async with aiofiles.open(file_path, 'w', encoding='utf-8') as f:
+        async with aiofiles.open(file_path, "w", encoding="utf-8") as f:
             await f.write(content)
         return str(file_path)
-    
+
     @property
     @abstractmethod
     def agent_name(self) -> str:
         """Return the name of this sub-agent."""
         pass
-    
+
     async def append_markdown(self, output_file: str, section_title: str, content: str):
         """
         Helper to append content to a markdown file with proper formatting and a datetime stamp.
-        
+
         Args:
             output_file: Path to the markdown file
             section_title: Title for this section
             content: Content to append
         """
         timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
-        
+
         # Format content based on type or patterns
         formatted_content = content
         if "```json" in content and "\n```" in content:
@@ -93,7 +94,7 @@
             except:
                 # Not valid JSON, leave as is
                 pass
-        
+
         async with asyncio.Lock():
             with open(output_file, "a", encoding="utf-8") as f:
                 f.write(f"\n### {section_title}\n")
@@ -103,4 +104,4 @@
 {formatted_content}
 ```
 ---
-""") 
\ No newline at end of file
+""")

--- app/agents/sub_agents/company_enrich_agent.py
+++ app/agents/sub_agents/company_enrich_agent.py
@@ -9,21 +9,30 @@
 from .base_sub_agent import BaseSubAgent
 from app.utils.db_utils import ProspectingDB
 from app.prompts.data_process_prompts import (
-    get_llm_data_consolidation_system_prompt, 
+    get_llm_data_consolidation_system_prompt,
     get_llm_data_consolidation_user_prompt,
     get_narrative_generation_system_prompt,
-    get_narrative_generation_user_prompt
+    get_narrative_generation_user_prompt,
 )
 from app.prompts.data_retrieval_prompts import get_linkedin_analysis_prompt
 from app.utils.qdrant_utils import search_chunks_in_qdrant
 from app.utils.global_db import get_global_db
 from app.utils.langsmith_config import trace_operation, initialize_langsmith
 from app.utils.logging_config import get_logger
-from app.utils.config import get_openai_api_key, get_gemini_api_key, get_google_api_key, get_enable_postgres_storage, get_enable_linkedin_rag, get_enable_llm_consolidation, get_enable_narrative_generation
+from app.utils.config import (
+    get_openai_api_key,
+    get_gemini_api_key,
+    get_google_api_key,
+    get_enable_postgres_storage,
+    get_enable_linkedin_rag,
+    get_enable_llm_consolidation,
+    get_enable_narrative_generation,
+)
 import os
 from app.utils.progress_store import ProgressStore
 # import google.generativeai as genai
 
+
 class CompanyEnrichAgent(BaseSubAgent):
     """
     Company Enrichment Agent that intelligently blends Perplexity and Coresignal data

