input_file: /home/devel/cicd-ai-assistant/sample-cicd-artifacts/ruff-format-cicd-short.txt
group_by_file: True
count: 3

=== FixSignal 1/3 ===
{'signal_type': 'format',
 'severity': 'low',
 'file_path': 'app/agents/prospecting_orchestrator.py',
 'span': {'start': {'row': 38, 'column': 1}, 'end': {'row': 1739, 'column': 1}},
 'rule_code': 'FORMAT',
 'message': '10 formatting region(s) to update (782 lines affected)',
 'docs_url': 'https://docs.astral.sh/ruff/formatter/',
 'fix': {'applicability': 'safe',
         'message': 'Apply 10 formatting change(s)',
         'edits': [{'span': {'start': {'row': 38, 'column': 1}, 'end': {'row': 48, 'column': 1}},
                    'content': '\n'
                               'logger = get_logger(__name__)\n'
                               '\n'
                               '\n'
                               '# Session context data structure\n'
                               'class SessionContext:\n'
                               '    """Session context for managing user interactions within a session."""\n'
                               '\n'
                               '    def __init__(self, session_id: str, user_id: str):\n'
                               '        self.session_id = session_id\n'
                               '        self.user_id = user_id\n'},
                   {'span': {'start': {'row': 50, 'column': 1}, 'end': {'row': 99, 'column': 1}},
                    'content': '        self.status = "active"\n'
                               '        self.last_activity = datetime.now()\n'
                               '        self.ria_detection_result: Optional[Dict[str, Any]] = None\n'
                               '\n'
                               '    def increment_interaction(self) -> str:\n'
                               '        """Increment interaction counter and return run_id for this interaction."""\n'
                               '        self.interaction_count += 1\n'
                               '        self.last_activity = datetime.now()\n'
                               '        return f"{self.session_id}_{self.interaction_count:03d}"\n'
                               '\n'
                               '    def to_dict(self) -> Dict[str, Any]:\n'
                               '        """Convert session context to dictionary for storage."""\n'
                               '        return {\n'
                               '            "session_id": self.session_id,\n'
                               '            "user_id": self.user_id,\n'
                               '            "start_time": self.start_time.isoformat(),\n'
                               '            "interaction_count": self.interaction_count,\n'
                               '            "status": self.status,\n'
                               '            "last_activity": self.last_activity.isoformat(),\n'
                               '        }\n'
                               '\n'
                               '    @classmethod\n'
                               '    def from_dict(cls, data: Dict[str, Any]) -> "SessionContext":\n'
                               '        """Create session context from dictionary."""\n'
                               '        session = cls(data["session_id"], data["user_id"])\n'
                               '        session.start_time = datetime.fromisoformat(data["start_time"])\n'
                               '        session.interaction_count = data["interaction_count"]\n'
                               '        session.status = data["status"]\n'
                               '        session.last_activity = datetime.fromisoformat(data["last_activity"])\n'
                               '        return session\n'
                               '\n'
                               '\n'
                               'class PromptAnalyzer:\n'
                               '    """\n'
                               '    Analyzes user prompts to determine if they contain specific company names or '
                               'general search requests.\n'
                               '    """\n'
                               '\n'
                               '    def __init__(self):\n'
                               '        self.llm = ChatOpenAI(model="gpt-4o-mini", temperature=0, '
                               'api_key=get_openai_api_key())\n'
                               '\n'
                               '    async def analyze_prompt(self, prompt: str) -> Dict[str, Any]:\n'
                               '        """\n'
                               '        Analyze a user prompt to determine the type of request using LLM.\n'
                               '\n'
                               '        Args:\n'
                               "            prompt: User's input prompt\n"
                               '\n'
                               '        Returns:\n'
                               '            Dictionary with analysis results:\n'
                               '            - prompt_type: "specific_company", "general_search", or "off_topic"\n'},
                   {'span': {'start': {'row': 104, 'column': 1}, 'end': {'row': 171, 'column': 1}},
                    'content': '            result = await self._llm_based_classification(prompt)\n'
                               '            logger.info("Prompt analysis completed", extra={"prompt_type": '
                               'result.get("prompt_type"), "confidence": result.get("confidence", 0.0)})\n'
                               '            return result\n'
                               '\n'
                               '        except Exception as e:\n'
                               '            logger.exception("Prompt analysis failed")\n'
                               '            print(f"‚ö†Ô∏è Prompt analysis failed: {e}")\n'
                               '            # Fallback to off_topic classification\n'
                               '            return {"prompt_type": "off_topic", "confidence": 0.0, "extracted_data": '
                               '{}}\n'
                               '\n'
                               '    async def _llm_based_classification(self, prompt: str) -> Dict[str, Any]:\n'
                               '        """\n'
                               '        Use LLM to classify the prompt into one of four categories.\n'
                               '        """\n'
                               '        system_prompt = get_prompt_analysis_system_prompt()\n'
                               '        user_prompt = f"Analyze this prompt: {prompt}"\n'
                               '\n'
                               '        try:\n'
                               '            with trace_operation("prompt_analysis", {"prompt_length": len(prompt), '
                               '"model": "gpt-4o-mini"}):\n'
                               '                messages = [SystemMessage(content=system_prompt), '
                               'HumanMessage(content=user_prompt)]\n'
                               '                response = await self.llm.ainvoke(messages)\n'
                               '\n'
                               '            # Parse JSON response\n'
                               '            response_text = response.content.strip()\n'
                               '            if "```json" in response_text:\n'
                               '                json_start = response_text.find("```json") + 7\n'
                               '                json_end = response_text.find("```", json_start)\n'
                               '                response_text = response_text[json_start:json_end].strip()\n'
                               '\n'
                               '            result = json.loads(response_text)\n'
                               '\n'
                               '            # Add off_topic message if needed\n'
                               '            if result["prompt_type"] == "off_topic":\n'
                               '                result["extracted_data"]["message"] = (\n'
                               '                    "I can help you with company research in two ways:\\n\\n1. '
                               "**Specific Company Research**: Provide a company name and I'll research and enrich "
                               "that specific company (e.g., 'Research Sequoia Capital' or 'Tell me about "
                               "BlackRock')\\n\\n2. **General Company Search**: Search for companies matching specific "
                               "criteria (e.g., 'Find VC firms in London focusing on fintech' or 'Show me private "
                               "equity firms in healthcare')\\n\\nPlease provide either a specific company name to "
                               'research or search criteria for finding companies."\n'
                               '                )\n'
                               '\n'
                               '            return result\n'
                               '\n'
                               '        except Exception as e:\n'
                               '            print(f"‚ö†Ô∏è LLM classification failed: {e}")\n'
                               '            return {\n'
                               '                "prompt_type": "off_topic",\n'
                               '                "confidence": 0.0,\n'
                               '                "extracted_data": {\n'
                               '                    "message": "I can help you with company research in two '
                               "ways:\\n\\n1. **Specific Company Research**: Provide a company name and I'll research "
                               "and enrich that specific company (e.g., 'Research Sequoia Capital' or 'Tell me about "
                               "BlackRock')\\n\\n2. **General Company Search**: Search for companies matching specific "
                               "criteria (e.g., 'Find VC firms in London focusing on fintech' or 'Show me private "
                               "equity firms in healthcare')\\n\\nPlease provide either a specific company name to "
                               'research or search criteria for finding companies."\n'
                               '                },\n'
                               '            }\n'
                               '\n'
                               '\n'
                               'class ProspectingOrchestrator:\n'
                               '    """\n'
                               '    Enhanced prospecting orchestrator that coordinates multiple sub-agents for '
                               'comprehensive company research.\n'
                               '\n'
                               '    This orchestrator provides three main execution modes:\n'
                               '    1. execute_from_prompt(): Process natural language user prompts\n'
                               '    2. execute_from_data(): Process structured company data\n'
                               '    3. execute_hybrid(): Automatically choose the best approach\n'
                               '\n'
                               '    Features:\n'
                               '    - Intelligent prompt analysis and classification\n'
                               '    - Multi-agent coordination with error handling\n'},
                   {'span': {'start': {'row': 172, 'column': 1}, 'end': {'row': 183, 'column': 1}},
                    'content': '    - Interactive mode for testing\n'
                               '    - MCP tool integration for enhanced capabilities\n'
                               '    """\n'
                               '\n'
                               '    def __init__(self, db=None, extractor_llm=None, output_dir="output/prospecting", '
                               'enable_debugging: Optional[bool] = None):\n'
                               '        """\n'
                               '        Initialize the prospecting orchestrator with sub-agents and configuration.\n'
                               '\n'
                               '        Args:\n'
                               '            db: Optional database instance (will use global if not provided)\n'
                               '            extractor_llm: LangChain LLM instance for data extraction\n'},
                   {'span': {'start': {'row': 1308, 'column': 1}, 'end': {'row': 1411, 'column': 1}},
                    'content': '                found_urls = [found_url]\n'
                               '                found_by_perplexity = False\n'
                               '                print(f"üîÑ Using fallback URL: {found_url}")\n'
                               '\n'
                               '            # Generate company_id from primary domain\n'
                               '            company_id = generate_company_id_from_domain(found_url)\n'
                               '            print(f"üÜî Generated company_id: {company_id}")\n'
                               '\n'
                               '            return {\n'
                               '                "success": True,\n'
                               '                "company_id": company_id,\n'
                               '                "found_url": found_url,\n'
                               '                "found_urls": found_urls,\n'
                               '                "domain_count": len(found_urls),\n'
                               '                "found_by_perplexity": found_by_perplexity,\n'
                               '            }\n'
                               '\n'
                               '        except Exception as e:\n'
                               '            error_msg = f"Domain discovery failed: {str(e)}"\n'
                               '            print(f"‚ùå {error_msg}")\n'
                               '\n'
                               '            return {"success": False, "error": error_msg}\n'
                               '\n'
                               '    async def _run_phase1_parallel(\n'
                               '        self,\n'
                               '        company_data: Dict,\n'
                               '        run_id: str,\n'
                               '        company_id: str,\n'
                               '        found_url: str,\n'
                               '        found_urls: List[str],\n'
                               '        found_by_perplexity: bool,\n'
                               '        shared_output_file: str,\n'
                               '        user_id: str = None,\n'
                               '        session_id: str = None,\n'
                               '    ) -> Dict[str, Any]:\n'
                               '        """\n'
                               '        Phase 1: Run Web Research and CoreSignal agents in parallel.\n'
                               '        """\n'
                               '        logger.info("Phase 1 parallel execution started", extra={"run_id": run_id, '
                               '"company_id": company_id})\n'
                               '        print("üîÑ Running Phase 1 agents in parallel...")\n'
                               '\n'
                               '        try:\n'
                               '            # Run both agents in parallel using asyncio.gather\n'
                               '            web_research_task = self.sub_agents["web_research"].execute(\n'
                               '                company_data,\n'
                               '                run_id=run_id,\n'
                               '                company_id=company_id,\n'
                               '                found_url=found_url,\n'
                               '                found_urls=found_urls,\n'
                               '                found_by_perplexity=found_by_perplexity,\n'
                               '                shared_output_file=shared_output_file,\n'
                               '                user_id=user_id,\n'
                               '                session_id=session_id,\n'
                               '            )\n'
                               '\n'
                               '            coresignal_task = self.sub_agents["coresignal"].execute(\n'
                               '                company_data, run_id=run_id, company_id=company_id, '
                               'found_url=found_url, found_urls=found_urls, user_id=user_id, session_id=session_id\n'
                               '            )\n'
                               '\n'
                               '            youtube_task = self.sub_agents["youtube_media"].execute(\n'
                               '                company_data,\n'
                               '                run_id=run_id,\n'
                               '                company_id=company_id,\n'
                               '                shared_output_file=shared_output_file,\n'
                               '                db=self.db,\n'
                               '                postgres_enabled=get_enable_postgres_storage(),\n'
                               '                user_id=user_id,\n'
                               '                session_id=session_id,\n'
                               '                youtube_url=found_url,\n'
                               '            )\n'
                               '\n'
                               '            # Wait for both to complete\n'
                               '            web_research_result, coresignal_result, youtube_result = await '
                               'asyncio.gather(\n'
                               '                web_research_task, coresignal_task, youtube_task, '
                               'return_exceptions=True\n'
                               '            )\n'
                               '\n'
                               '            # Handle any exceptions\n'
                               '            if isinstance(web_research_result, Exception):\n'
                               '                print(f"‚ùå Web Research Agent failed: {web_research_result}")\n'
                               '                web_research_result = {"success": False, "error": '
                               'str(web_research_result)}\n'
                               '\n'
                               '            if isinstance(coresignal_result, Exception):\n'
                               '                print(f"‚ùå CoreSignal Agent failed: {coresignal_result}")\n'
                               '                coresignal_result = {"success": False, "error": '
                               'str(coresignal_result)}\n'
                               '\n'
                               '            if isinstance(youtube_result, Exception):\n'
                               '                print(f"‚ùå YouTube Media Agent failed: {youtube_result}")\n'
                               '                youtube_result = {"success": False, "error": str(youtube_result)}\n'
                               '\n'
                               '            print(\n'
                               '                f"‚úÖ Phase 1 completed - Web Research: {\'‚úÖ\' if '
                               "web_research_result.get('success') else '‚ùå'}, CoreSignal: {'‚úÖ' if "
                               "coresignal_result.get('success') else '‚ùå'}, YouTube: {'‚úÖ' if "
                               'youtube_result.get(\'success\') else \'‚ùå\'}"\n'
                               '            )\n'
                               '\n'
                               '            logger.info(\n'
                               '                "Phase 1 parallel execution completed",\n'
                               '                extra={\n'
                               '                    "run_id": run_id,\n'
                               '                    "company_id": company_id,\n'
                               '                    "web_research_success": web_research_result.get("success", '
                               'False),\n'
                               '                    "coresignal_success": coresignal_result.get("success", False),\n'
                               '                    "youtube_success": youtube_result.get("success", False),\n'
                               '                },\n'
                               '            )\n'
                               '\n'
                               '            return {\n'
                               '                "success": True,\n'
                               '                "web_research_result": web_research_result,\n'
                               '                "coresignal_result": coresignal_result,\n'
                               '                "youtube_result": youtube_result,\n'
                               '            }\n'
                               '\n'
                               '        except Exception as e:\n'
                               '            error_msg = f"Phase 1 parallel execution failed: {str(e)}"\n'
                               '            print(f"‚ùå {error_msg}")\n'
                               '            logger.exception("Phase 1 parallel execution failed", extra={"run_id": '
                               'run_id, "company_id": company_id})\n'
                               '            return {"success": False, "error": error_msg}\n'
                               '\n'
                               '    async def _run_phase2_parallel(\n'
                               '        self,\n'
                               '        company_data: Dict,\n'
                               '        run_id: str,\n'
                               '        company_id: str,\n'
                               '        shared_output_file: str,\n'
                               '        user_id: str,\n'
                               '        session_id: str,\n'
                               '        session_context: SessionContext,\n'
                               '    ) -> Dict[str, Any]:\n'
                               '        """\n'
                               '        Phase 2: Run Company Enrichment and Person Enrichment agents in parallel.\n'
                               '        """\n'},
                   {'span': {'start': {'row': 1584, 'column': 1}, 'end': {'row': 1636, 'column': 1}},
                    'content': '        print("   ‚Ä¢ General search: \'Find VC firms in London focusing on fintech\'")\n'
                               '        print("   ‚Ä¢ Off-topic: \'What\'s the weather like?\'")\n'
                               '        print()\n'
                               '\n'
                               '        # Generate a unique user ID if not provided\n'
                               '        if not user_id:\n'
                               '            user_id = f"interactive_user_{int(time.time())}"\n'
                               '\n'
                               '        # Start a new session\n'
                               '        session_context = await self.start_session(user_id)\n'
                               '\n'
                               '        print(f"üë§ User ID: {user_id}")\n'
                               '        print(f"üÜî Session ID: {session_context.session_id}")\n'
                               '        print()\n'
                               '\n'
                               '        try:\n'
                               '            while True:\n'
                               '                try:\n'
                               '                    # Get user input\n'
                               '                    prompt = input("üìù Enter your prompt: ").strip()\n'
                               '\n'
                               '                    if prompt.lower() in ["quit", "exit", "q"]:\n'
                               '                        print("üëã Goodbye!")\n'
                               '                        break\n'
                               '\n'
                               '                    if not prompt:\n'
                               '                        print("‚ö†Ô∏è Please enter a valid prompt.")\n'
                               '                        continue\n'
                               '\n'
                               '                    print(f"\\nüîç Processing: \'{prompt}\'")\n'
                               '                    print("-" * 40)\n'
                               '\n'
                               '                    # Execute the orchestrator with session context\n'
                               '                    result = await self.execute(prompt=prompt, user_id=user_id, '
                               'session_context=session_context)\n'
                               '\n'
                               '                    if result["success"]:\n'
                               '                        print("‚úÖ Success!")\n'
                               '                        print(f"   Workflow Type: {result.get(\'workflow_type\', '
                               '\'unknown\')}")\n'
                               '                        print(f"   Run ID: {result[\'run_id\']}")\n'
                               '                        print(f"   Session ID: {result.get(\'session_id\', '
                               '\'N/A\')}")\n'
                               '                        print(f"   Interaction #: {result.get(\'interaction_number\', '
                               '\'N/A\')}")\n'
                               '\n'
                               '                        if result.get("workflow_type") == "company_search":\n'
                               '                            print(f"   Companies Found: {len(result.get(\'companies\', '
                               '[]))}")\n'
                               '                            print(f"   Next Step: {result.get(\'next_step\', '
                               '\'N/A\')}")\n'
                               '                            print(f"   Status: Waiting for company selection...")\n'
                               '\n'
                               '                            # Handle company selection\n'
                               '                            companies = result.get("companies", [])\n'
                               '                            if companies:\n'
                               '                                print(f"\\nüìã Available Companies ({len(companies)} '
                               'found):")\n'
                               '                                print("-" * 60)\n'},
                   {'span': {'start': {'row': 1640, 'column': 1}, 'end': {'row': 1670, 'column': 1}},
                    'content': '                                    print(f"     Focus: '
                               '{company.get(\'investor_focus\', \'N/A\')}")\n'
                               '                                    print(f"     Location: {company.get(\'location\', '
                               '\'N/A\')}")\n'
                               '                                    print()\n'
                               '\n'
                               '                                # Get user selection\n'
                               '                                while True:\n'
                               '                                    try:\n'
                               '                                        selection = input(f"üéØ Select a company to '
                               'enrich (1-{len(companies)}) or \'skip\': ").strip()\n'
                               '\n'
                               '                                        if selection.lower() in ["skip", "s", "no"]:\n'
                               '                                            print("‚è≠Ô∏è Skipping company selection.")\n'
                               '                                            break\n'
                               '\n'
                               '                                        selected_index = int(selection)\n'
                               '                                        if 1 <= selected_index <= len(companies):\n'
                               '                                            print(f"‚úÖ Selected company: '
                               '{companies[selected_index - 1].get(\'company_name\')}")\n'
                               '                                            print("üîÑ Starting enrichment process...")\n'
                               '\n'
                               '                                            # Call the company selection handler with '
                               'session context\n'
                               '                                            selection_result = await '
                               'self.handle_user_company_selection(\n'
                               '                                                run_id=result["run_id"],\n'
                               '                                                user_id=user_id,\n'
                               '                                                '
                               'selected_company_index=selected_index,\n'
                               '                                                session_context=session_context,\n'
                               '                                            )\n'
                               '\n'
                               '                                            if selection_result["success"]:\n'
                               '                                                print("‚úÖ Company enrichment '
                               'completed!")\n'
                               '                                                print(f"   Company: '
                               '{selection_result.get(\'company_name\', \'Unknown\')}")\n'
                               '                                                print(f"   Company ID: '
                               '{selection_result.get(\'company_id\', \'N/A\')}")\n'},
                   {'span': {'start': {'row': 1673, 'column': 1}, 'end': {'row': 1680, 'column': 1}},
                    'content': '                                            else:\n'
                               '                                                print("‚ùå Company enrichment failed!")\n'
                               '                                                print(f"   Error: '
                               '{selection_result.get(\'error\', \'Unknown error\')}")\n'
                               '\n'
                               '                                            break\n'
                               '                                        else:\n'
                               '                                            print(f"‚ùå Please enter a number between 1 '
                               'and {len(companies)}")\n'},
                   {'span': {'start': {'row': 1682, 'column': 1}, 'end': {'row': 1717, 'column': 1}},
                    'content': '                                    except KeyboardInterrupt:\n'
                               '                                        print("\\n‚è≠Ô∏è Skipping company selection.")\n'
                               '                                        break\n'
                               '\n'
                               '                        elif result.get("workflow_type") == "off_topic":\n'
                               '                            print(f"   Message: {result.get(\'message\', \'No message '
                               'provided\')}")\n'
                               '                            print(f"   Next Step: {result.get(\'next_step\', '
                               '\'N/A\')}")\n'
                               '                            print(f"   Status: Waiting for user input...")\n'
                               '                            print()\n'
                               '                            print("üí° The system is now waiting for your next '
                               'prompt.")\n'
                               '                            print("   Try asking about a specific company or search '
                               'criteria.")\n'
                               '\n'
                               '                        elif result.get("workflow_type") == "specific_company":\n'
                               '                            print(f"   Company: {result.get(\'company_name\', '
                               '\'Unknown\')}")\n'
                               '                            print(f"   Company ID: {result.get(\'company_id\', '
                               '\'N/A\')}")\n'
                               '                            print(f"   Output File: {result.get(\'output_file\', '
                               '\'N/A\')}")\n'
                               '                            print(f"   Status: Enrichment completed!")\n'
                               '\n'
                               '                    else:\n'
                               '                        print("‚ùå Failed!")\n'
                               '                        print(f"   Error: {result.get(\'error\', \'Unknown '
                               'error\')}")\n'
                               '\n'
                               '                except KeyboardInterrupt:\n'
                               '                    print("\\nüëã Goodbye!")\n'
                               '                    break\n'
                               '                except Exception as e:\n'
                               '                    print(f"‚ùå Exception: {e}")\n'
                               '                    import traceback\n'
                               '\n'
                               '                    traceback.print_exc()\n'
                               '\n'
                               '                print("\\n" + "=" * 60)\n'
                               '\n'
                               '        finally:\n'
                               '            # End the session when the loop exits\n'
                               '            await self.end_session(session_context)\n'},
                   {'span': {'start': {'row': 1725, 'column': 1}, 'end': {'row': 1739, 'column': 1}},
                    'content': '    print("=" * 60)\n'
                               '    print("Starting interactive mode...")\n'
                               '    print()\n'
                               '\n'
                               '    # Generate a unique user ID for this session\n'
                               '    user_id = f"session_user_{int(time.time())}"\n'
                               '\n'
                               '    # Run interactive mode\n'
                               '    orchestrator = ProspectingOrchestrator()\n'
                               '    await orchestrator.execute_interactive(user_id=user_id)\n'
                               '\n'
                               '\n'
                               'if __name__ == "__main__":\n'
                               '    try:\n'
                               '        asyncio.run(main())\n'}]}}

=== FixSignal 2/3 ===
{'signal_type': 'format',
 'severity': 'low',
 'file_path': 'app/agents/sub_agents/base_sub_agent.py',
 'span': {'start': {'row': 8, 'column': 1}, 'end': {'row': 100, 'column': 1}},
 'rule_code': 'FORMAT',
 'message': '3 formatting region(s) to update (147 lines affected)',
 'docs_url': 'https://docs.astral.sh/ruff/formatter/',
 'fix': {'applicability': 'safe',
         'message': 'Apply 3 formatting change(s)',
         'edits': [{'span': {'start': {'row': 8, 'column': 1}, 'end': {'row': 20, 'column': 1}},
                    'content': 'from bs4 import BeautifulSoup\n'
                               'from app.utils.db_utils import ProspectingDB\n'
                               '\n'
                               '\n'
                               'class BaseSubAgent(ABC):\n'
                               '    """\n'
                               '    Base class for modular sub-agents that perform specific prospecting tasks.\n'
                               '    Each sub-agent should be self-contained and output results to files.\n'
                               '    """\n'
                               '\n'
                               '    def __init__(self, output_dir: str = "output", db: Optional[ProspectingDB] = '
                               'None):\n'
                               '        self.output_dir = Path(output_dir)\n'
                               '        self.output_dir.mkdir(exist_ok=True)\n'},
                   {'span': {'start': {'row': 22, 'column': 1}, 'end': {'row': 76, 'column': 1}},
                    'content': '            print(f"üîó {self.__class__.__name__}: Initialized with database instance: '
                               '{id(self.db)}")\n'
                               '        else:\n'
                               '            print(f"üîó {self.__class__.__name__}: Initialized without database, will '
                               'use global instance when needed")\n'
                               '\n'
                               '    @abstractmethod\n'
                               '    async def execute(self, company_data: Dict[str, Any]) -> Dict[str, Any]:\n'
                               '        """\n'
                               "        Execute the sub-agent's specific task.\n"
                               '\n'
                               '        Args:\n'
                               '            company_data: Dictionary containing company information\n'
                               '                         (name, website, location, etc.)\n'
                               '\n'
                               '        Returns:\n'
                               '            Dictionary with execution results and output file paths\n'
                               '        """\n'
                               '        pass\n'
                               '\n'
                               '    async def save_output(self, content: str, filename: str) -> str:\n'
                               '        """\n'
                               '        Save content to a markdown file.\n'
                               '\n'
                               '        Args:\n'
                               '            content: Content to save\n'
                               '            filename: Name of the output file\n'
                               '\n'
                               '        Returns:\n'
                               '            Path to the saved file\n'
                               '        """\n'
                               '        file_path = self.output_dir / filename\n'
                               '        async with aiofiles.open(file_path, "w", encoding="utf-8") as f:\n'
                               '            await f.write(content)\n'
                               '        return str(file_path)\n'
                               '\n'
                               '    @property\n'
                               '    @abstractmethod\n'
                               '    def agent_name(self) -> str:\n'
                               '        """Return the name of this sub-agent."""\n'
                               '        pass\n'
                               '\n'
                               '    async def append_markdown(self, output_file: str, section_title: str, content: '
                               'str):\n'
                               '        """\n'
                               '        Helper to append content to a markdown file with proper formatting and a '
                               'datetime stamp.\n'
                               '\n'
                               '        Args:\n'
                               '            output_file: Path to the markdown file\n'
                               '            section_title: Title for this section\n'
                               '            content: Content to append\n'
                               '        """\n'
                               '        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")\n'
                               '\n'
                               '        # Format content based on type or patterns\n'
                               '        formatted_content = content\n'
                               '        if "```json" in content and "\\n```" in content:\n'},
                   {'span': {'start': {'row': 93, 'column': 1}, 'end': {'row': 100, 'column': 1}},
                    'content': '            except:\n'
                               '                # Not valid JSON, leave as is\n'
                               '                pass\n'
                               '\n'
                               '        async with asyncio.Lock():\n'
                               '            with open(output_file, "a", encoding="utf-8") as f:\n'
                               '                f.write(f"\\n### {section_title}\\n")\n'}]}}

=== FixSignal 3/3 ===
{'signal_type': 'format',
 'severity': 'low',
 'file_path': 'app/agents/sub_agents/company_enrich_agent.py',
 'span': {'start': {'row': 9, 'column': 1}, 'end': {'row': 30, 'column': 1}},
 'rule_code': 'FORMAT',
 'message': '1 formatting region(s) to update (51 lines affected)',
 'docs_url': 'https://docs.astral.sh/ruff/formatter/',
 'fix': {'applicability': 'safe',
         'message': 'Apply 1 formatting change(s)',
         'edits': [{'span': {'start': {'row': 9, 'column': 1}, 'end': {'row': 30, 'column': 1}},
                    'content': 'from .base_sub_agent import BaseSubAgent\n'
                               'from app.utils.db_utils import ProspectingDB\n'
                               'from app.prompts.data_process_prompts import (\n'
                               '    get_llm_data_consolidation_system_prompt,\n'
                               '    get_llm_data_consolidation_user_prompt,\n'
                               '    get_narrative_generation_system_prompt,\n'
                               '    get_narrative_generation_user_prompt,\n'
                               ')\n'
                               'from app.prompts.data_retrieval_prompts import get_linkedin_analysis_prompt\n'
                               'from app.utils.qdrant_utils import search_chunks_in_qdrant\n'
                               'from app.utils.global_db import get_global_db\n'
                               'from app.utils.langsmith_config import trace_operation, initialize_langsmith\n'
                               'from app.utils.logging_config import get_logger\n'
                               'from app.utils.config import (\n'
                               '    get_openai_api_key,\n'
                               '    get_gemini_api_key,\n'
                               '    get_google_api_key,\n'
                               '    get_enable_postgres_storage,\n'
                               '    get_enable_linkedin_rag,\n'
                               '    get_enable_llm_consolidation,\n'
                               '    get_enable_narrative_generation,\n'
                               ')\n'
                               'import os\n'
                               'from app.utils.progress_store import ProgressStore\n'
                               '# import google.generativeai as genai\n'
                               '\n'
                               '\n'
                               'class CompanyEnrichAgent(BaseSubAgent):\n'
                               '    """\n'
                               '    Company Enrichment Agent that intelligently blends Perplexity and Coresignal '
                               'data\n'}]}}
