{
  "group": {
    "tool_id": "ruff",
    "signal_type": "lint",
    "group_size": 3
  },
  "signals": [
    {
      "signal": {
        "tool_id": "ruff",
        "signal_type": "lint",
        "severity": "low",
        "rule_code": "F401",
        "message": "`re` imported but unused",
        "docs_url": "https://docs.astral.sh/ruff/rules/unused-import",
        "file_path": "app/agents/prospecting_orchestrator.py",
        "span": {
          "start": {
            "row": 8,
            "column": 8
          },
          "end": {
            "row": 8,
            "column": 10
          }
        }
      },
      "file_read_error": null,
      "code_context": {
        "window": {
          "file_path": "app/agents/prospecting_orchestrator.py",
          "start_row": 3,
          "end_row": 13,
          "text": "Coordinates all sub-agents in the prospecting workflow with intelligent prompt routing.\n\"\"\"\n\nimport asyncio\nimport uuid\nimport re\nimport json\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nimport os\n"
        },
        "imports": {
          "file_path": "app/agents/prospecting_orchestrator.py",
          "start_row": 1,
          "end_row": 38,
          "text": "\"\"\"\nProspecting Orchestrator v2: Enhanced with Company Search Integration\nCoordinates all sub-agents in the prospecting workflow with intelligent prompt routing.\n\"\"\"\n\nimport asyncio\nimport uuid\nimport re\nimport json\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nimport os\nimport time\nimport signal\nimport atexit\n\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.messages import SystemMessage, HumanMessage\n\nfrom app.agents.sub_agents.web_research_agent import WebResearchAgent\nfrom app.agents.sub_agents.youtube_media_agent import YouTubeMediaAgent\nfrom app.utils.langsmith_config import trace_operation, create_main_run, initialize_langsmith\nfrom app.agents.sub_agents.coresignal_agent import CoreSignalSubAgent\nfrom app.agents.sub_agents.company_enrich_agent import CompanyEnrichAgent\nfrom app.agents.sub_agents.person_enrich_agent import PersonEnrichAgent\nfrom app.agents.sub_agents.company_search_agent import CompanySearchAgent\nfrom app.agents.sub_agents.ria_detection_agent import RIADetectionAgent\nfrom app.utils.domain_utils import generate_company_id_from_domain\nfrom app.tools.search_module import find_company_homepage_url_perplexity\nfrom app.utils.global_db import get_global_db\nfrom app.utils.db_utils import ProspectingDB\nfrom app.prompts.data_process_prompts import get_prompt_analysis_system_prompt\nfrom app.utils.logging_config import get_logger\nfrom app.utils.config import get_openai_api_key, get_enable_postgres_storage, get_enable_debugging\nfrom app.utils.progress_store import ProgressStore\nfrom app.utils.rate_limit import RateLimiter\n\n"
        },
        "enclosing_function": null
      },
      "fix_context": {
        "exists": true,
        "applicability": "safe",
        "tool_message": "Remove unused import: `re`",
        "edits": [
          {
            "span": {
              "start": {
                "row": 8,
                "column": 1
              },
              "end": {
                "row": 9,
                "column": 1
              }
            },
            "content": ""
          }
        ]
      }
    },
    {
      "signal": {
        "tool_id": "ruff",
        "signal_type": "lint",
        "severity": "low",
        "rule_code": "F401",
        "message": "`pathlib.Path` imported but unused",
        "docs_url": "https://docs.astral.sh/ruff/rules/unused-import",
        "file_path": "app/agents/prospecting_orchestrator.py",
        "span": {
          "start": {
            "row": 11,
            "column": 21
          },
          "end": {
            "row": 11,
            "column": 25
          }
        }
      },
      "file_read_error": null,
      "code_context": {
        "window": {
          "file_path": "app/agents/prospecting_orchestrator.py",
          "start_row": 6,
          "end_row": 16,
          "text": "import asyncio\nimport uuid\nimport re\nimport json\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nimport os\nimport time\nimport signal\nimport atexit\n"
        },
        "imports": {
          "file_path": "app/agents/prospecting_orchestrator.py",
          "start_row": 1,
          "end_row": 38,
          "text": "\"\"\"\nProspecting Orchestrator v2: Enhanced with Company Search Integration\nCoordinates all sub-agents in the prospecting workflow with intelligent prompt routing.\n\"\"\"\n\nimport asyncio\nimport uuid\nimport re\nimport json\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nimport os\nimport time\nimport signal\nimport atexit\n\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.messages import SystemMessage, HumanMessage\n\nfrom app.agents.sub_agents.web_research_agent import WebResearchAgent\nfrom app.agents.sub_agents.youtube_media_agent import YouTubeMediaAgent\nfrom app.utils.langsmith_config import trace_operation, create_main_run, initialize_langsmith\nfrom app.agents.sub_agents.coresignal_agent import CoreSignalSubAgent\nfrom app.agents.sub_agents.company_enrich_agent import CompanyEnrichAgent\nfrom app.agents.sub_agents.person_enrich_agent import PersonEnrichAgent\nfrom app.agents.sub_agents.company_search_agent import CompanySearchAgent\nfrom app.agents.sub_agents.ria_detection_agent import RIADetectionAgent\nfrom app.utils.domain_utils import generate_company_id_from_domain\nfrom app.tools.search_module import find_company_homepage_url_perplexity\nfrom app.utils.global_db import get_global_db\nfrom app.utils.db_utils import ProspectingDB\nfrom app.prompts.data_process_prompts import get_prompt_analysis_system_prompt\nfrom app.utils.logging_config import get_logger\nfrom app.utils.config import get_openai_api_key, get_enable_postgres_storage, get_enable_debugging\nfrom app.utils.progress_store import ProgressStore\nfrom app.utils.rate_limit import RateLimiter\n\n"
        },
        "enclosing_function": null
      },
      "fix_context": {
        "exists": true,
        "applicability": "safe",
        "tool_message": "Remove unused import: `pathlib.Path`",
        "edits": [
          {
            "span": {
              "start": {
                "row": 11,
                "column": 1
              },
              "end": {
                "row": 12,
                "column": 1
              }
            },
            "content": ""
          }
        ]
      }
    },
    {
      "signal": {
        "tool_id": "ruff",
        "signal_type": "lint",
        "severity": "low",
        "rule_code": "F541",
        "message": "f-string without any placeholders",
        "docs_url": "https://docs.astral.sh/ruff/rules/f-string-missing-placeholders",
        "file_path": "app/agents/prospecting_orchestrator.py",
        "span": {
          "start": {
            "row": 494,
            "column": 23
          },
          "end": {
            "row": 494,
            "column": 57
          }
        }
      },
      "file_read_error": null,
      "code_context": {
        "window": {
          "file_path": "app/agents/prospecting_orchestrator.py",
          "start_row": 489,
          "end_row": 499,
          "text": "                        print(f\"\u2139\ufe0f No user profile found for user: {user_id}\")\n                except Exception as e:\n                    print(f\"\u26a0\ufe0f Error retrieving user profile: {e}\")\n                \n                # Step 1: Analyze prompt and determine workflow\n                print(f\"\ud83d\udd0d Step 1: Analyzing user prompt\")\n                prompt_analysis = await self.prompt_analyzer.analyze_prompt(prompt)\n                workflow_type = prompt_analysis['prompt_type']\n                print(f\"\u2705 Prompt analysis complete: {workflow_type} (confidence: {prompt_analysis['confidence']:.2f})\")\n                \n                logger.info(\"Workflow routing\", extra={\"run_id\": run_id, \"workflow_type\": workflow_type, \"confidence\": prompt_analysis.get(\"confidence\", 0.0)})\n"
        },
        "imports": {
          "file_path": "app/agents/prospecting_orchestrator.py",
          "start_row": 1,
          "end_row": 38,
          "text": "\"\"\"\nProspecting Orchestrator v2: Enhanced with Company Search Integration\nCoordinates all sub-agents in the prospecting workflow with intelligent prompt routing.\n\"\"\"\n\nimport asyncio\nimport uuid\nimport re\nimport json\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nimport os\nimport time\nimport signal\nimport atexit\n\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.messages import SystemMessage, HumanMessage\n\nfrom app.agents.sub_agents.web_research_agent import WebResearchAgent\nfrom app.agents.sub_agents.youtube_media_agent import YouTubeMediaAgent\nfrom app.utils.langsmith_config import trace_operation, create_main_run, initialize_langsmith\nfrom app.agents.sub_agents.coresignal_agent import CoreSignalSubAgent\nfrom app.agents.sub_agents.company_enrich_agent import CompanyEnrichAgent\nfrom app.agents.sub_agents.person_enrich_agent import PersonEnrichAgent\nfrom app.agents.sub_agents.company_search_agent import CompanySearchAgent\nfrom app.agents.sub_agents.ria_detection_agent import RIADetectionAgent\nfrom app.utils.domain_utils import generate_company_id_from_domain\nfrom app.tools.search_module import find_company_homepage_url_perplexity\nfrom app.utils.global_db import get_global_db\nfrom app.utils.db_utils import ProspectingDB\nfrom app.prompts.data_process_prompts import get_prompt_analysis_system_prompt\nfrom app.utils.logging_config import get_logger\nfrom app.utils.config import get_openai_api_key, get_enable_postgres_storage, get_enable_debugging\nfrom app.utils.progress_store import ProgressStore\nfrom app.utils.rate_limit import RateLimiter\n\n"
        },
        "enclosing_function": {
          "file_path": "app/agents/prospecting_orchestrator.py",
          "start_row": 397,
          "end_row": 554,
          "text": "    async def execute(self, prompt: str, user_id: str, session_context: SessionContext, run_id: str | None = None) -> Dict[str, Any]:\n        \"\"\"\n        Execute the prospecting orchestrator with session-aware run_id generation.\n        \n        Args:\n            prompt: User's input prompt\n            user_id: User identifier for multi-tenant isolation\n            session_context: Session context for session-aware execution\n            \n        Returns:\n            Dictionary with execution results including session information\n        \"\"\"\n        start_time = datetime.now()\n        \n        # Always get global database instance\n        self.db = await get_global_db()\n        print(f\"\ud83d\udd17 ProspectingOrchestrator.execute: Using global database instance: {id(self.db)}\")\n        \n        # Use provided run_id from router if available; otherwise generate from session context\n        if not run_id:\n            run_id = f\"{session_context.session_id}_run_{session_context.interaction_count + 1:03d}\"\n        output_file = f\"prospecting_results_{session_context.session_id}_{session_context.interaction_count:03d}.json\"\n        \n        print(f\"\ud83d\udd04 Session: {session_context.session_id}\")\n        print(f\"\ud83d\udc64 User: {session_context.user_id}\")\n        print(f\"\ud83d\udcdd Interaction: {session_context.interaction_count}\")\n        print(f\"\ud83c\udd94 Run ID: {run_id}\")\n        \n        print(f\"\ud83d\udcc4 Output file: {output_file}\")\n        print(f\"\ud83d\udcac User prompt: {prompt}\")\n        \n        logger.info(\"Orchestrator execution started\", extra={\"run_id\": run_id, \"user_id\": user_id, \"session_id\": session_context.session_id, \"prompt_length\": len(prompt)})\n        try:\n            await ProgressStore.instance().set_progress(self.db, run_id, 10)\n        except Exception:\n            pass\n        \n        # Store session interaction if session context is provided\n        await self.store_session_interaction(\n            session_context, \n            run_id, \n            prompt, \n            \"prospecting_orchestration\"\n        )\n        \n        # Ensure user_id is available\n        if not user_id:\n            user_id = session_context.user_id\n        \n        # Create shared output file\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        if self.enable_debugging:\n            # Create debug file in output/prospecting directory\n            debug_dir = \"output/prospecting\"\n            os.makedirs(debug_dir, exist_ok=True)\n            shared_output_file = f\"{debug_dir}/debug_{timestamp}.md\"\n            print(f\"\ud83d\udc1b Debug file created: {shared_output_file}\")\n        else:\n            shared_output_file = None\n        \n        # Ensure output directory exists only when debugging output is enabled\n        if self.enable_debugging:\n            os.makedirs(self.output_dir, exist_ok=True)\n        \n        # Create main LangSmith run context\n        run_metadata = {\n            'prompt': prompt,\n            'workflow_type': 'prospecting_orchestration',\n            'session_id': session_context.session_id,\n            'interaction_count': session_context.interaction_count\n        }\n        \n        with create_main_run(run_id, user_id, session_context.session_id, run_metadata):\n            try:\n                # Retrieve and display user bio\n                user_bio = None\n                try:\n                    user_bio = await self.db.get_user_profile(user_id)\n                    if user_bio:\n                        print(f\"\\n\ud83d\udc64 User Profile for {user_id}:\")\n                        print(\"=\" * 60)\n                        print(f\"\ud83c\udfe2 Firm Description ({len(user_bio['firm_description'])} characters):\")\n                        print(\"-\" * 40)\n                        print(user_bio['firm_description'])\n                        print(f\"\\n\ud83c\udfaf Key Differentiators ({len(user_bio['key_differentiators'])} characters):\")\n                        print(\"-\" * 40)\n                        print(user_bio['key_differentiators'])\n                        print(f\"\\n\ud83c\udfaf Key Objectives ({len(user_bio['key_objectives'])} characters):\")\n                        print(\"-\" * 40)\n                        print(user_bio['key_objectives'])\n                        print(\"=\" * 60)\n                    else:\n                        print(f\"\u2139\ufe0f No user profile found for user: {user_id}\")\n                except Exception as e:\n                    print(f\"\u26a0\ufe0f Error retrieving user profile: {e}\")\n                \n                # Step 1: Analyze prompt and determine workflow\n                print(f\"\ud83d\udd0d Step 1: Analyzing user prompt\")\n                prompt_analysis = await self.prompt_analyzer.analyze_prompt(prompt)\n                workflow_type = prompt_analysis['prompt_type']\n                print(f\"\u2705 Prompt analysis complete: {workflow_type} (confidence: {prompt_analysis['confidence']:.2f})\")\n                \n                logger.info(\"Workflow routing\", extra={\"run_id\": run_id, \"workflow_type\": workflow_type, \"confidence\": prompt_analysis.get(\"confidence\", 0.0)})\n                \n                # Step 2: Route to appropriate workflow\n                if workflow_type == 'specific_company':\n                    return await self._execute_specific_company_workflow(\n                        prompt_analysis['extracted_data'], run_id, user_id, shared_output_file, self.db, get_enable_postgres_storage(), session_context, workflow_type\n                    )\n                elif workflow_type == 'general_search':\n                    return await self._execute_company_search_workflow(\n                        prompt_analysis['extracted_data'], run_id, user_id, shared_output_file, self.db, get_enable_postgres_storage(), session_context, workflow_type\n                    )\n                elif workflow_type == 'off_topic':\n                    return {\n                        'success': True,\n                        'workflow_type': 'off_topic',\n                        'message': prompt_analysis['extracted_data'].get('message', 'Off-topic request'),\n                        'prompt_analysis': prompt_analysis,\n                        'run_id': run_id,\n                        'user_id': user_id,\n                        'session_id': session_context.session_id,\n                        'interaction_number': session_context.interaction_count,\n                        'execution_time_ms': int((datetime.now() - start_time).total_seconds() * 1000),\n                        'next_step': 'wait_for_user_input'\n                    }\n                else:\n                    # Fallback for any unexpected types\n                    return {\n                        'success': False,\n                        'error': 'Unexpected prompt type - please provide a specific company name or clear search criteria',\n                        'prompt_analysis': prompt_analysis,\n                        'run_id': run_id,\n                        'user_id': user_id,\n                        'session_id': session_context.session_id,\n                        'execution_time_ms': int((datetime.now() - start_time).total_seconds() * 1000)\n                    }\n                        \n            except Exception as e:\n                import traceback\n                print(f\"\\n\u274c [ProspectingOrchestrator ERROR] Exception in execute():\\n{traceback.format_exc()}\")\n                \n                execution_time_ms = int((datetime.now() - start_time).total_seconds() * 1000)\n                \n                logger.exception(\"Orchestrator execution failed\", extra={\"run_id\": run_id, \"user_id\": user_id, \"session_id\": session_context.session_id})\n                \n                return {\n                    'success': False,\n                    'error': str(e),\n                    'run_id': run_id,\n                    'user_id': user_id,\n                    'session_id': session_context.session_id,\n                    'execution_time_ms': execution_time_ms\n                }\n            finally:\n                # Note: Database connection is managed globally, no need to close here\n                pass\n\n"
        }
      },
      "fix_context": {
        "exists": true,
        "applicability": "safe",
        "tool_message": "Remove extraneous `f` prefix",
        "edits": [
          {
            "span": {
              "start": {
                "row": 494,
                "column": 23
              },
              "end": {
                "row": 494,
                "column": 57
              }
            },
            "content": "\"\ud83d\udd0d Step 1: Analyzing user prompt\""
          }
        ]
      }
    }
  ]
}